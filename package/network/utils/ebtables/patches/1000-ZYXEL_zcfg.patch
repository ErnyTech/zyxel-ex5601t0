Index: ebtables-2018-06-27-48cff25d/extensions/ebt_AUTOMAP.c
===================================================================
--- /dev/null
+++ ebtables-2018-06-27-48cff25d/extensions/ebt_AUTOMAP.c
@@ -0,0 +1,136 @@
+/*
+ * Description: EBTables auto priority mapping module for userspace.
+ *  Authors:  Jeff Liu <Jeff.Liu@mitrastar.com.tw>
+ *           The following is the original disclaimer.
+ *
+ * Shared library add-on to ebtables for AUTOMAP
+ *
+ * (C) 2011 by Jeff Liu <Jeff.Liu@mitrastar.com.tw>
+ *
+ * This program is distributed under the terms of GNU GPL v2, 1991
+ *
+ */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include "../include/ebtables_u.h"
+#include "../include/linux/netfilter_bridge/ebt_AUTOMAP.h"
+
+static int automapType_supplied;
+
+#define AUTOMAP_TYPE  '1'
+
+static struct option opts[] =
+{
+	{ "automap-type" , required_argument, 0, AUTOMAP_TYPE },
+	{ 0 }
+};
+
+static void print_help()
+{
+	printf(
+	"AUTOMAP target options:\n"
+	" --automap-type :\n"
+	"			 Auto priority mapping by defined type(1:802.1P 2:DSCP 4:IP Length)\n");
+}
+
+static void init(struct ebt_entry_target *target)
+{
+	struct ebt_automap_t_info *automapinfo =
+	   (struct ebt_automap_t_info *)target->data;
+
+	automapinfo->type = AUTOMAP_TYPE_PKTLEN;
+	automapinfo->marktable[0]=0x0;   /* Queue priority 0*/
+	automapinfo->marktable[1]=0x1;   /* Queue priority 1*/
+	automapinfo->marktable[2]=0x2;   /* Queue priority 2*/
+	automapinfo->marktable[3]=0x3;   /* Queue priority 3*/
+	automapinfo->marktable[4]=0x4;   /* Queue priority 4*/
+	automapinfo->marktable[5]=0x5;   /* Queue priority 5*/
+	automapinfo->marktable[6]=0x6;   /* Queue priority 6*/
+	automapinfo->marktable[6]=0x7;   /* Queue priority 7*/
+	automapType_supplied = 0;
+}
+
+static int
+parse(int c, char **argv, int argc,
+   const struct ebt_u_entry *entry, unsigned int *flags,
+   struct ebt_entry_target **target)
+{
+	struct ebt_automap_t_info *automapinfo =
+	   (struct ebt_automap_t_info *)(*target)->data;
+	int type;
+
+	switch (c) {
+	case AUTOMAP_TYPE:
+		ebt_check_option2(flags, AUTOMAP_TYPE);
+		type = strtol(argv[optind - 1], NULL, 0);
+		if((type!=AUTOMAP_TYPE_DSCP)&&
+				(type!=AUTOMAP_TYPE_8021P)&&
+				(type!=AUTOMAP_TYPE_PKTLEN)){
+			ebt_print_error("Invalid mapping type (1:802.1P 2:DSCP 4:IP Length)");
+		}
+		automapinfo->type = type;
+		automapType_supplied = 1;
+		break;
+	 default:
+		return 0;
+	}
+	return 1;
+}
+
+static void
+final_check(const struct ebt_u_entry *entry,
+   const struct ebt_entry_target *target, const char *name,
+   unsigned int hookmask, unsigned int time)
+{
+	if (time == 0 && automapType_supplied == 0)
+		ebt_print_error("No automap type supplied");
+}
+
+
+/* Prints out the targinfo. */
+static void
+print(const struct ebt_u_entry *entry,
+   const struct ebt_entry_target *target)
+{
+	const struct ebt_automap_t_info *automapinfo = (const struct ebt_automap_t_info*)target->data;
+	if(automapinfo->type == AUTOMAP_TYPE_DSCP)
+		printf("automap type is DSCP");
+	else if(automapinfo->type == AUTOMAP_TYPE_8021P)
+		printf("automap type is 8021P");
+	else if(automapinfo->type == AUTOMAP_TYPE_PKTLEN)
+		printf("automap type is PKTLEN");
+}
+
+static int
+compare(const struct ebt_entry_target *t1,
+  	 const struct ebt_entry_target *t2)
+{
+	struct ebt_automap_t_info *automapinfo1 =
+	   (struct ebt_automap_t_info *)t1->data;
+	struct ebt_automap_t_info *automapinfo2 =
+	   (struct ebt_automap_t_info *)t2->data;
+
+	return automapinfo1->type == automapinfo2->type;
+}
+
+static
+struct  ebt_u_target automap_target =
+{
+    EBT_AUTOMAP_TARGET,
+    sizeof(struct ebt_automap_t_info),
+    print_help,
+    init,
+    parse,
+    final_check,
+    print,
+    compare,
+    opts
+};
+
+__attribute__((constructor)) static void extension_init(void)
+{
+	ebt_register_target(&automap_target);
+}
Index: ebtables-2018-06-27-48cff25d/extensions/ebt_ftos.c
===================================================================
--- /dev/null
+++ ebtables-2018-06-27-48cff25d/extensions/ebt_ftos.c
@@ -0,0 +1,183 @@
+/*
+ * Description: EBTables time extension module for userspace.
+ *  Authors:  Song Wang <songw@broadcom.com>, ported from FTOS patch netfilter/iptables
+ *           The following is the original disclaimer.
+ *
+ * Shared library add-on to iptables for FTOS
+ *
+ * (C) 2000 by Matthew G. Marsh <mgm@paktronix.com>
+ *
+ * This program is distributed under the terms of GNU GPL v2, 1991
+ *
+ * libipt_FTOS.c borrowed heavily from libipt_TOS.c  11/09/2000
+ *
+ */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include "../include/ebtables_u.h"
+#include "../include/linux/netfilter_bridge/ebt_ftos_t.h"
+
+static int ftos_supplied;
+
+#define FTOS_TRGT    '1'
+#define FTOS_SET     '2'
+#define FTOS_WMM     '4'
+#define FTOS_8021Q   '8'
+static struct option opts[] =
+{
+	{ "ftos-target" , required_argument, 0, FTOS_TRGT },
+	{ "set-ftos"    , required_argument, 0, FTOS_SET },
+	{ "wmm-ftos"    , no_argument      , 0, FTOS_WMM },
+	{ "8021q-ftos"  , no_argument      , 0, FTOS_8021Q },
+	{ 0 }
+};
+
+static void print_help()
+{
+	printf(
+	"ftos target options:\n"
+	" --set-ftos value     : Set TOS byte in IP packet header \n"
+	"			 This value can be in decimal (ex: 32)\n"
+	"			 in hex (ex: 0x20)\n"
+	" --ftos-target target : ACCEPT, DROP, RETURN or CONTINUE\n");
+}
+
+static void init(struct ebt_entry_target *target)
+{
+	struct ebt_ftos_t_info *ftosinfo =
+	   (struct ebt_ftos_t_info *)target->data;
+
+	ftosinfo->target = EBT_CONTINUE;
+	ftosinfo->ftos = 0;
+	ftos_supplied = 0;
+}
+
+#define OPT_FTOS_TARGET       0x01
+#define OPT_FTOS_SETFTOS      0x02
+#define OPT_FTOS_WMMFTOS      0x04
+#define OPT_FTOS_8021QFTOS    0x08
+
+static int
+parse(int c, char **argv, int argc,
+   const struct ebt_u_entry *entry, unsigned int *flags,
+   struct ebt_entry_target **target)
+{
+	struct ebt_ftos_t_info *ftosinfo =
+	   (struct ebt_ftos_t_info *)(*target)->data;
+	char *end;
+
+	switch (c) {
+	case FTOS_TRGT:
+#if 1	/* porting from MSTC */
+		ebt_check_option2(flags, OPT_FTOS_TARGET);
+#else
+		ebt_check_option2(flags, FTOS_TRGT);
+#endif
+		if (FILL_TARGET(optarg, ftosinfo->target))
+			ebt_print_error("Illegal --ftos-target target");
+		break;
+	case FTOS_SET:
+		ebt_check_option2(flags, FTOS_SET);
+		ftosinfo->ftos = (uint8_t)strtoul(optarg, &end, 0);
+        ftosinfo->ftos_set = OPT_FTOS_SETFTOS;
+		if (*end != '\0' || end == optarg)
+			ebt_print_error("Bad FTOS value '%s'", optarg);
+		ftos_supplied = 1;
+                break;
+    case FTOS_WMM:
+        ebt_check_option2(flags, OPT_FTOS_SETFTOS);
+        ftosinfo->ftos_set = FTOS_WMM;
+        //printf("LEON DEBUG: wmm-ftos..........\n");
+        ftos_supplied = 1;
+        break;
+    case FTOS_8021Q:
+        ebt_check_option2(flags, OPT_FTOS_8021QFTOS);
+        ftosinfo->ftos_set = FTOS_8021Q;
+        //printf("LEON DEBUG: 8021q-ftos..........\n");
+        ftos_supplied = 1;
+        break;
+	 default:
+		return 0;
+	}
+	return 1;
+}
+
+static void
+final_check(const struct ebt_u_entry *entry,
+   const struct ebt_entry_target *target, const char *name,
+   unsigned int hookmask, unsigned int time)
+{
+	struct ebt_ftos_t_info *ftosinfo = (struct ebt_ftos_t_info *)target->data;
+
+	if (time == 0 && ftos_supplied == 0)
+		ebt_print_error("No ftos value supplied");
+	if (BASE_CHAIN && ftosinfo->target == EBT_RETURN)
+		ebt_print_error("--ftos-target RETURN not allowed on base chain");
+}
+
+
+/* Prints out the targinfo. */
+static void
+print(const struct ebt_u_entry *entry,
+   const struct ebt_entry_target *target)
+{
+	const struct ebt_ftos_t_info *ftosinfo = (const struct ebt_ftos_t_info*)target->data;
+    if(ftosinfo->ftos_set == FTOS_WMM)
+        printf("WMM mapping to Tos");
+    else if(ftosinfo->ftos_set == FTOS_8021Q)
+        printf("802.1Q mapping to Tos");
+    else
+	printf("TOS set 0x%x", ftosinfo->ftos);
+
+	if (ftosinfo->target == EBT_ACCEPT)
+		return;
+	printf(" --ftos-target %s", TARGET_NAME(ftosinfo->target));
+}
+
+static int
+compare(const struct ebt_entry_target *t1,
+  	 const struct ebt_entry_target *t2)
+{
+	struct ebt_ftos_t_info *ftosinfo1 =
+	   (struct ebt_ftos_t_info *)t1->data;
+	struct ebt_ftos_t_info *ftosinfo2 =
+	   (struct ebt_ftos_t_info *)t2->data;
+
+	return ftosinfo1->target == ftosinfo2->target &&
+	   ftosinfo1->ftos == ftosinfo2->ftos &&
+	   ftosinfo1->ftos_set == ftosinfo2->ftos_set;
+}
+
+#if 0
+/* Saves the union ipt_targinfo in parsable form to stdout. */
+static void
+save(const struct ipt_ip *ip, const struct ipt_entry_target *target)
+{
+	const struct ipt_FTOS_info *finfo =
+		(const struct ipt_FTOS_info *)target->data;
+
+	printf("--set-ftos 0x%02x ", finfo->ftos);
+}
+#endif
+
+static
+struct  ebt_u_target ftos_target =
+{
+    EBT_FTOS_TARGET,
+    sizeof(struct ebt_ftos_t_info),
+    print_help,
+    init,
+    parse,
+    final_check,
+    print,
+    compare,
+    opts
+};
+
+__attribute__((constructor)) static void extension_init(void)
+{
+	ebt_register_target(&ftos_target);
+}
Index: ebtables-2018-06-27-48cff25d/extensions/ebt_policer.c
===================================================================
--- /dev/null
+++ ebtables-2018-06-27-48cff25d/extensions/ebt_policer.c
@@ -0,0 +1,509 @@
+/* Shared library add-on to ebtables to add policer support, ZyXEL Stan, 20100107 */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <getopt.h>
+#include "../include/ebtables_u.h"
+#include "../include/linux/netfilter_bridge/ebt_policer.h"
+
+#define EBT_POLICER_RATE_KBPS        10       /* Policer default rate in kbps. */
+#define EBT_POLICER_BURST_KBYTE      10       /* Policer default burst in kbyte. */
+#define EBT_POLICER_MAX_INPUT_VALUE  10000000 /* Max rate value user can input in kbps or mbps. */
+#define EBT_POLICER_MAX_BURST_SIZE   20000    /* Max burst size value user can input in kbytes. */
+
+#if 1//__MSTC__, Jones For compilation
+#define FLAG_MODE          0x01
+#define FLAG_POLICER       0x02
+#define FLAG_POLICER_BURST 0x04
+#define FLAG_CRATE         0x08
+#define FLAG_CBS_BURST     0x10
+#define FLAG_PRATE         0x20
+#define FLAG_PBS_BURST     0x40
+#define FLAG_EBS_BURST     0x80
+
+#define MODE_TBF   0
+#define MODE_SRTCM 1
+#define MODE_TRTCM 2
+
+static struct option opts[] = {
+    { "mode",          required_argument, 0, '#' },
+    { "policer",       required_argument, 0, '%' },
+    { "policer-burst", required_argument, 0, '$' },
+    { "crate",         required_argument, 0, '1' },
+    { "cbs-burst",     required_argument, 0, '2' },
+    { "prate",         required_argument, 0, '3' },
+    { "pbs-burst",     required_argument, 0, '4' },
+    { "ebs-burst",     required_argument, 0, '5' },
+    { 0 }
+};
+#else
+#define FLAG_POLICER		         0x01
+#define FLAG_POLICER_BURST	         0x02
+
+#define ARG_POLICER	                 '1'
+#define ARG_POLICER_BURST            '2'
+
+static struct option opts[] = {
+    { "policer",		required_argument, 0, ARG_POLICER },
+    { "policer-burst",	required_argument, 0, ARG_POLICER_BURST },
+    { 0 }
+};
+#endif
+
+#if 1//__MSTC__, Jones For compilation
+/* Function which prints out usage message. */
+static void print_help(void)
+{
+	printf(
+	    "policer options:\n"
+	    "--mode name                     mode name match, default is tbf.\n"
+	    "                                If you want to use tbf mode, you can skip this option.\n"
+	    "                                [Support tbf, srtcm, trtcm.]\n"
+	    "tbf mode: \n"
+	    "--policer rate			max data rate match, default %ukbps\n"
+	    "                                [Bits per second followed by kbps or mbps.\n"
+	    "                                Support 1kbps to 10000000kbps or 1mbps to 10000mbps.] \n"
+	    "--policer-burst size		size to match in a burst, default %ukb\n"
+	    "                                [Kilo-bytes followed by kb.\n"
+	    "                                Support 1kb to 20000kb.]\n"
+	    "srtcm mode: \n"
+	    "The nfmark field of red packet is marked as 0x4000, \n"
+	    "yellow packet is 0x8000 and green packet is 0xC000.\n"
+	    "--crate rate			committed data rate match, default %ukbps\n"
+	    "--cbs-burst size		size to match in CBS burst, default %ukb\n"
+	    "--ebs-burst size		size to match in EBS burst, default %ukb\n"
+	    "trtcm mode: \n"
+	    "The nfmark field of red packet is marked as 0x4000, \n"
+	    "yellow packet is 0x8000 and green packet is 0xC000.\n"
+	    "--crate rate			committed data rate match, default %ukbps\n"
+	    "--cbs-burst size		size to match in CBS burst, default %ukb\n"
+	    "--prate rate			peak data rate match, default %ukbps\n"
+	    "                                [Msut be equal or greater than crate.]\n"
+	    "--pbs-burst size		size to match in PBS burst, default %ukb\n\n",
+	    EBT_POLICER_RATE_KBPS, EBT_POLICER_BURST_KBYTE,
+	    EBT_POLICER_RATE_KBPS, EBT_POLICER_BURST_KBYTE, EBT_POLICER_BURST_KBYTE,
+	    EBT_POLICER_RATE_KBPS, EBT_POLICER_BURST_KBYTE, EBT_POLICER_RATE_KBPS, EBT_POLICER_BURST_KBYTE);
+}
+#else
+/* Function which prints out usage message. */
+static void print_help(void)
+{
+	printf(
+	    "policer options:\n"
+	    "--policer rate			max data rate match: default %ukbps\n"
+	    "                                [Bits per second followed by kbps or mbps.\n"
+	    "                                Support 1kbps to 1000000kbps or 1mbps to 1000000mbps.] \n"
+	    "--policer-burst size		size to match in a burst, default %ukb\n"
+	    "                                [Kilo-bytes followed by kb.\n"
+	    "                                Support 1kb to 1000kb.]\n"
+	    "\n", EBT_POLICER_RATE_KBPS, EBT_POLICER_BURST_KBYTE);
+}
+#endif
+
+/* parse_rate(): to check the rate and preprocess the rate. */
+static int parse_rate(const char *rate, uint32_t *val)
+{
+	const char *kbps;
+	const char *mbps;
+	uint32_t r;
+	uint32_t mult = 1;
+
+	kbps = strstr(rate, "kbps"); /* String comparison. */
+	mbps = strstr(rate, "mbps"); /* String comparison. */
+
+	if ((!kbps && !mbps) || (kbps && mbps)) {
+		return 0;
+	}
+	else if (kbps) {
+		if (strlen(kbps + 4) != 0) {
+			return 0;
+		}
+		mult = 1; /* kbps scale */
+	}
+	else if (mbps) {
+		if (strlen(mbps + 4) != 0) {
+			return 0;
+		}
+		mult = 1000; /* mbps scale */
+	}
+
+	r = strtoul(rate, NULL, 0);
+
+	if (!r) {
+		return 0;
+	}
+
+	if (r > EBT_POLICER_MAX_INPUT_VALUE) { /* prevent user enter greater than IPT_POLICER_MAX_INPUT_VALUE */
+		return 0;
+	}
+	*val = r * mult;
+	return 1;
+}
+
+#if 1//__MSTC__, Jones For compilation
+/* Initialize the match. */
+static void init(struct ebt_entry_match *m)
+{
+	struct ebt_policer_info *r = (struct ebt_policer_info *)m->data;
+	/* Default mode is TBF. */
+	r->policerMode = MODE_TBF;
+
+	/* Prepare default rate string, such as 10kbps. */
+	char rate_buf[16];
+	sprintf(rate_buf, "%dkbps", EBT_POLICER_RATE_KBPS);
+
+	parse_rate(rate_buf, &r->rate);
+	r->burst = EBT_POLICER_BURST_KBYTE;
+	/* For srtcm and trtcm. */
+	r->pRate = r->rate;
+	r->pbsBurst = EBT_POLICER_BURST_KBYTE;
+#if 1 /* Init creditCap to check if the rule is new or not. __OBM__. ZyXEL, Stan Su, 20100611. */
+	r->creditCap = 0;
+#endif
+
+}
+/* end init */
+#else
+/* Initialize the match. */
+static void init(struct ebt_entry_match *m)
+{
+	struct ebt_policer_info *r = (struct ebt_policer_info *)m->data;
+
+	/* Prepare default rate string, such as 10kbps. */
+	char rate_buf[16];
+	sprintf(rate_buf, "%dkbps", EBT_POLICER_RATE_KBPS);
+
+	parse_rate(rate_buf, &r->avg);
+	r->burst = EBT_POLICER_BURST_KBYTE;
+}
+#endif
+
+#if 1//__MSTC__, Jones For compilation
+static int parse(int c, char **argv, int argc,
+                 const struct ebt_u_entry *entry,
+                 unsigned int *flags,
+                 struct ebt_entry_match **match)
+{
+	struct ebt_policer_info *r = (struct ebt_policer_info *)(*match)->data;
+	const char *str1;
+	char *remainder;
+
+	switch(c) {
+	case '#':
+		/* Check Mode */
+		ebt_check_option2(flags, FLAG_MODE);
+		if (ebt_check_inverse2(optarg)) {
+			ebt_print_error("Unexpected `!' after --mode");
+		}
+		if (strcmp(optarg, "tbf") == 0) {
+			r->policerMode = MODE_TBF;
+		}
+		else if (strcmp(optarg, "srtcm") == 0) {
+			r->policerMode = MODE_SRTCM;
+		}
+		else if (strcmp(optarg, "trtcm") == 0) {
+			r->policerMode = MODE_TRTCM;
+		}
+		else {
+			ebt_print_error("bad mode '%s'", optarg);
+		}
+		break;
+
+	case '%':
+		if (r->policerMode == 0) {
+			/* Check parameter of tbf */
+			ebt_check_option2(flags, FLAG_POLICER);
+			if (ebt_check_inverse2(optarg)) {
+				ebt_print_error("Unexpected `!' after --policer");
+			}
+			if (!parse_rate(optarg, &r->rate)) {
+				ebt_print_error("bad rate '%s'", optarg);
+			}
+			break;
+		}
+		else {
+			return 0;
+			break;
+		}
+
+	case '$':
+		if (r->policerMode == 0) {
+			/* Check parameter of tbf */
+			ebt_check_option2(flags, FLAG_POLICER_BURST);
+			if (ebt_check_inverse2(optarg)) {
+				ebt_print_error("Unexpected `!' after --policer-burst");
+			}
+			str1 = optarg;
+			r->burst = strtoul(str1, &remainder, 0);
+			if (strcmp(remainder, "kb") !=0 || r->burst > EBT_POLICER_MAX_BURST_SIZE || r->burst <= 0) {
+				ebt_print_error("bad --policer-burst `%s'", optarg);
+			}
+			break;
+		}
+		else {
+			return 0;
+			break;
+		}
+
+	case '1':
+		if (r->policerMode == 1 || r->policerMode == 2) {
+			/* Check parameter of srtcm or trtcm */
+			ebt_check_option2(flags, FLAG_CRATE);
+			if (ebt_check_inverse2(optarg)) {
+				ebt_print_error("Unexpected `!' after --crate");
+			}
+			if (!parse_rate(optarg, &r->rate)) {
+				ebt_print_error("bad committed information rate '%s'", optarg);
+			}
+			break;
+		}
+		else {
+			return 0;
+			break;
+		}
+
+	case '2':
+		if (r->policerMode == 1 || r->policerMode == 2) {
+			/* Check parameter of srtcm or trtcm */
+			ebt_check_option2(flags, FLAG_CBS_BURST);
+			if (ebt_check_inverse2(optarg)) {
+				ebt_print_error("Unexpected `!' after --cbs-burst");
+			}
+			str1 = optarg;
+			r->burst = strtoul(str1, &remainder, 0);
+			if (strcmp(remainder, "kb") !=0 || r->burst > EBT_POLICER_MAX_BURST_SIZE || r->burst <= 0) {
+				ebt_print_error("bad --cbs-burst `%s'", optarg);
+			}
+			break;
+		}
+		else {
+			return 0;
+			break;
+		}
+
+	case '3':
+		if (r->policerMode == 2) {
+			/* Check parameter of trtcm */
+			ebt_check_option2(flags, FLAG_PRATE);
+			if (ebt_check_inverse2(optarg)) {
+				ebt_print_error("Unexpected `!' after --prate");
+			}
+			if (!parse_rate(optarg, &r->pRate)) {
+				ebt_print_error("bad peak information rate '%s'", optarg);
+			}
+			if (r->rate > r->pRate) {
+				ebt_print_error("prate msut be equal or greater than crate");
+			}
+			break;
+		}
+		else {
+			return 0;
+			break;
+		}
+
+	case '4':
+		if (r->policerMode == 2) {
+			/* Check parameter of trtcm */
+			ebt_check_option2(flags, FLAG_PBS_BURST);
+			if (ebt_check_inverse2(optarg)) {
+				ebt_print_error("Unexpected `!' after --pbs-burst");
+			}
+			str1 = optarg;
+			r->pbsBurst = strtoul(str1, &remainder, 0);
+			if (strcmp(remainder, "kb") !=0 || r->pbsBurst > EBT_POLICER_MAX_BURST_SIZE || r->pbsBurst <= 0) {
+				ebt_print_error("bad --pbs-burst `%s'", optarg);
+			}
+			break;
+		}
+		else {
+			return 0;
+			break;
+		}
+
+	case '5':
+		if (r->policerMode == 1) {
+			/* Check parameter of srtcm */
+			ebt_check_option2(flags, FLAG_EBS_BURST);
+			if (ebt_check_inverse2(optarg)) {
+				ebt_print_error("Unexpected `!' after --ebs-burst");
+			}
+			str1 = optarg;
+			r->pbsBurst = strtoul(str1, &remainder, 0);
+			if (strcmp(remainder, "kb") !=0 || r->pbsBurst > EBT_POLICER_MAX_BURST_SIZE || r->pbsBurst <= 0) {
+				ebt_print_error("bad --ebs-burst `%s'", optarg);
+			}
+			break;
+		}
+		else {
+			return 0;
+			break;
+		}
+
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+/* end parse */
+#else
+static int parse(int c, char **argv, int argc,
+                 const struct ebt_u_entry *entry,
+                 unsigned int *flags,
+                 struct ebt_entry_match **match)
+{
+	struct ebt_policer_info *r = (struct ebt_policer_info *)(*match)->data;
+	const char *str1;
+	char *remainder;
+
+	switch(c) {
+	case ARG_POLICER:
+		check_option(flags, FLAG_POLICER);
+		if (check_inverse(optarg)) {
+			print_error("Unexpected `!' after --policer");
+		}
+		if (!parse_rate(optarg, &r->avg)) {
+			print_error("bad rate `%s'", optarg);
+		}
+		break;
+
+	case ARG_POLICER_BURST:
+		check_option(flags, FLAG_POLICER_BURST);
+		if (check_inverse(optarg)) {
+			print_error("Unexpected `!' after --policer-burst");
+		}
+
+		str1 = optarg;
+		r->burst = strtol(str1, &remainder, 0);
+		if (strcmp(remainder, "kb") != 0 || r->burst > EBT_POLICER_MAX_BURST_SIZE || r->burst <= 0) {
+			print_error("bad --policer-burst `%s'", optarg);
+		}
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+#endif
+
+/* Final check; nothing. */
+static void final_check(const struct ebt_u_entry *entry,
+                        const struct ebt_entry_match *match,
+                        const char *name,
+                        unsigned int hookmask,
+                        unsigned int time)
+{
+	/* empty */
+}
+
+struct rates
+{
+    const char *name;
+    uint32_t mult;
+};
+
+static struct rates g_rates[] =
+{
+    { "kbps", 1 },
+    { "mbps", 1000 },
+    { "gbps", 1000000 },
+};
+
+static void print_rate(uint32_t period)
+{
+	unsigned int i;
+
+	for (i = 1; i < sizeof(g_rates) / sizeof(struct rates); i ++)
+		if (period < g_rates[i].mult
+			    || period / g_rates[i].mult < period % g_rates[i].mult ) {
+			break;
+		}
+
+	printf("%u%s ", period / g_rates[i - 1].mult , g_rates[i - 1].name);
+}
+
+#if 1//__MSTC__, Jones For compilation
+/* Prints out the matchinfo. */
+static void
+print(const struct ebt_u_entry *entry, const struct ebt_entry_match *match)
+{
+	struct ebt_policer_info *r = (struct ebt_policer_info *)match->data;
+
+	switch(r->policerMode) {
+	case MODE_TBF:
+		printf("policer: rate ");
+		print_rate(r->rate);
+		printf("burst %ukbytes ", r->burst);
+		break;
+
+	case MODE_SRTCM:
+		printf("srtcm: cRate ");
+		print_rate(r->rate);
+		printf("cbs-burst %ukbytes ", r->burst);
+		printf("ebs-burst %ukbytes ", r->pbsBurst);
+		break;
+
+	case MODE_TRTCM:
+		printf("trtcm: cRate ");
+		print_rate(r->rate);
+		printf("cbs-burst %ukbytes ", r->burst);
+		printf("pRate ");
+		print_rate(r->pRate);
+		printf("pbs-burst %ukbytes ", r->pbsBurst);
+		break;
+	}
+}
+/* end print */
+#else
+/* Prints out the matchinfo. */
+static void
+print(const struct ebt_u_entry *entry, const struct ebt_entry_match *match)
+{
+	struct ebt_policer_info *r = (struct ebt_policer_info *)match->data;
+
+	printf("policer: rate ");
+	print_rate(r->avg);
+	printf("burst %ukbytes ", r->burst);
+}
+#endif
+static int compare(const struct ebt_entry_match* m1, const struct ebt_entry_match *m2)
+{
+	struct ebt_policer_info* li1 = (struct ebt_policer_info*)m1->data;
+	struct ebt_policer_info* li2 = (struct ebt_policer_info*)m2->data;
+#if 1//__MSTC__, Jones For compilation
+	if (li1->rate!= li2->rate) {
+		return 0;
+	}
+#else
+       if (li1->avg != li2->avg) {
+		return 0;
+	}
+#endif
+	if (li1->burst != li2->burst) {
+		return 0;
+	}
+	return 1;
+}
+
+static struct ebt_u_match policer_match =
+{
+    .name         = EBT_POLICER_MATCH,
+    .size         = sizeof(struct ebt_policer_info),
+    .help         = print_help,
+    .init         = init,
+    .parse        = parse,
+    .final_check  = final_check,
+    .print        = print,
+    .compare      = compare,
+    .extra_ops    = opts,
+};
+
+//static void _init(void) __attribute((constructor));
+__attribute__((constructor)) static void extension_init(void)
+{
+	ebt_register_match(&policer_match);
+}
+
Index: ebtables-2018-06-27-48cff25d/extensions/ebt_tc.c
===================================================================
--- /dev/null
+++ ebtables-2018-06-27-48cff25d/extensions/ebt_tc.c
@@ -0,0 +1,126 @@
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <getopt.h>
+#include "../include/ebtables_u.h"
+#include "../include/linux/netfilter_bridge/ebt_tc.h"
+
+
+static struct option opts[] =
+{
+	{ "set-tc" , required_argument, 0, '1' },
+	{ 0 }
+};
+
+static void print_help()
+{
+	printf(
+	"tc target options:\n"
+	" --set-tc value     : Set tc value\n");
+}
+
+
+static void init(struct ebt_entry_target *target)
+{
+	struct ebt_tc_info *tcinfo =
+	   (struct ebt_tc_info *)target->data;
+
+	tcinfo->target = EBT_CONTINUE;
+}
+
+static void
+parse_tc(const unsigned char *s, struct ebt_tc_info *tcinfo){
+	char *buffer;
+	char *end, *cp;
+
+	buffer = strdup(s);
+#if 0
+	if ((cp = strchr(buffer, '/')) == NULL){
+		ftosinfo->ftos = strtol(buffer, &end, 0);
+		ftosinfo->mask = 0xff;
+	}
+	else {
+		*cp = '\0';
+		cp++;
+		ftosinfo->ftos = buffer[0] ? strtol(buffer, &end, 0) : 0;
+		if (ebt_errormsg[0] != '\0')
+			return;
+		ftosinfo->mask = cp[0] ? strtol(cp, &end, 0) : 0xFF;
+		if (ebt_errormsg[0] != '\0')
+			return;
+	}
+#else
+	tcinfo->tc = strtol(buffer, &end, 0);
+
+	/* add for debug */
+	printf( "tcinfo->tc is 0x%x\n", tcinfo->tc );
+#endif
+	free(buffer);
+}
+
+static int parse(int c, char **argv, int argc,
+   const struct ebt_u_entry *entry, unsigned int *flags,
+   struct ebt_entry_target **target)
+{
+	struct ebt_tc_info *tcinfo =
+	   (struct ebt_tc_info *)(*target)->data;
+	char *end;
+
+	switch (c) {
+	case '1':
+		parse_tc(optarg, tcinfo);
+		break;
+
+	 default:
+		return 0;
+	}
+
+	return 1;
+}
+
+static void final_check(const struct ebt_u_entry *entry,
+   const struct ebt_entry_target *target, const char *name,
+   unsigned int hookmask, unsigned int time)
+{
+	return;
+}
+
+static void print(const struct ebt_u_entry *entry,
+   const struct ebt_entry_target *target)
+{
+	struct ebt_tc_info *tcinfo =
+	   (struct ebt_tc_info *)target->data;
+
+	printf("--set-tc 0x%x", tcinfo->tc);
+
+}
+
+static int compare(const struct ebt_entry_target *t1,
+   const struct ebt_entry_target *t2)
+{
+	struct ebt_tc_info *tcinfo1 =
+	   (struct ebt_tc_info *)t1->data;
+	struct ebt_tc_info *tcinfo2 =
+	   (struct ebt_tc_info *)t2->data;
+
+	return tcinfo1->tc == tcinfo2->tc;
+}
+
+static struct ebt_u_target tc_target =
+{
+	.name		= EBT_TC_TARGET,
+	.size		= sizeof(struct ebt_tc_info),
+	.help		= print_help,
+	.init		= init,
+	.parse		= parse,
+	.final_check	= final_check,
+	.print		= print,
+	.compare	= compare,
+	.extra_ops	= opts,
+};
+
+__attribute__((constructor)) static void extension_init(void)
+{
+	ebt_register_target(&tc_target);
+}
Index: ebtables-2018-06-27-48cff25d/include/linux/netfilter_bridge/ebt_AUTOMAP.h
===================================================================
--- /dev/null
+++ ebtables-2018-06-27-48cff25d/include/linux/netfilter_bridge/ebt_AUTOMAP.h
@@ -0,0 +1,51 @@
+/* Used by ebt_AUTOMAP.c, MitraStar Jeff, 20110114*/
+#ifndef __LINUX_BRIDGE_EBT_AUTOMAP_H
+#define __LINUX_BRIDGE_EBT_AUTOMAP_H
+
+#define EBT_AUTOMAP_TARGET "AUTOMAP"
+
+#define AUTOMAP_TYPE_8021P  0x1
+#define AUTOMAP_TYPE_DSCP   0x2
+#define AUTOMAP_TYPE_PKTLEN 0x4
+
+#define DSCP_MASK_SHIFT   5
+#define ETHERPRI_MARK_SHIFT   12
+
+
+		/*
+		Auto Priority Mapping Table
+
+
+			DSCP	|   Packet Length	| 802.1P	|     Queue     |
+		   ---------------------------------------------
+					|				|   001	|       0 		|
+					|				|		|			|
+					|				|   010	|       1		|
+					|				|		|			|
+			0x00       |       >1100		|   000	|       2		|
+					|				|		|			|
+			0x08       |       250-1100	|   011	|       3		|
+					|				|		|			|
+			0x10       |				|   100	|       4		|
+					|				|		|			|
+			0x18       |       <250		|   101	|       5		|
+					|				|		|			|
+		0x20,0x28	|				|   110	|       6		|
+					|				|		|			|
+		0x30,0x38  	|				|   111	|       7		|
+		*/
+
+
+/* accoding to tr181 8021p to DSCP mapping table(upstream), higher value higher priority*/
+unsigned short vlan8021pToPriorityQueue[8] = {2,0,1,3,4,5,6,7};
+unsigned short dscpPrecedenceToPriorityQueue[8] = {2,3,4,5,6,6,7,7};
+
+
+/* target info */
+struct ebt_automap_t_info {
+	int type;
+	int marktable[8];
+};
+
+#endif
+
Index: ebtables-2018-06-27-48cff25d/include/linux/netfilter_bridge/ebt_ftos_t.h
===================================================================
--- /dev/null
+++ ebtables-2018-06-27-48cff25d/include/linux/netfilter_bridge/ebt_ftos_t.h
@@ -0,0 +1,18 @@
+#ifndef __LINUX_BRIDGE_EBT_FTOS_T_H
+#define __LINUX_BRIDGE_EBT_FTOS_T_H
+
+struct ebt_ftos_t_info
+{
+    int           ftos_set;
+	unsigned char ftos;
+	// EBT_ACCEPT, EBT_DROP or EBT_CONTINUE or EBT_RETURN
+	int target;
+};
+#define EBT_FTOS_TARGET "ftos"
+
+#define FTOS_TARGET       0x01
+#define FTOS_SETFTOS      0x02
+#define FTOS_WMMFTOS      0x04
+#define FTOS_8021QFTOS    0x08
+
+#endif
Index: ebtables-2018-06-27-48cff25d/include/linux/netfilter_bridge/ebt_policer.h
===================================================================
--- /dev/null
+++ ebtables-2018-06-27-48cff25d/include/linux/netfilter_bridge/ebt_policer.h
@@ -0,0 +1,39 @@
+/* Used by ebt_policer.c, ZyXEL Stan, 20100107*/
+#ifndef __LINUX_BRIDGE_EBT_POLICER_H
+#define __LINUX_BRIDGE_EBT_POLICER_H
+
+#define EBT_POLICER_MATCH "policer"
+
+#define BITS_PER_BYTE 8
+#define KILO_SCALE    1000
+
+struct ebt_policer_info
+{
+#if 1//__MSTC__, Jones For compilation
+       int policerMode;
+
+	/* For srTCM and trTCM, rate means cRate and burst means cbsBurst.
+       For srTCM, pbsBurst means ebsBurst. */
+       uint32_t rate, pRate;
+	uint32_t burst, pbsBurst;  /* Period multiplier for upper limit. */
+
+       /* Used internally by the kernel */
+       unsigned long prev;
+
+	/* For srTCM and trTCM, credit means cbsCredit and creditCap means cbsCreditCap.
+	   For srTCM, pbsCreditCap means ebsCreditCap. */
+	uint32_t credit, pbsCredit;
+	uint32_t creditCap, pbsCreditCap, only_for_bugfix_1, only_for_bugfix_2;
+#else
+	uint32_t avg;    /* Average secs between packets * scale */
+	uint32_t burst;  /* Period multiplier for upper limit. */
+
+	/* Used internally by the kernel */
+	unsigned long prev;
+	uint32_t credit;
+	uint32_t credit_cap, cost;
+#endif
+};
+
+#endif
+
Index: ebtables-2018-06-27-48cff25d/extensions/ebt_ip.c
===================================================================
--- ebtables-2018-06-27-48cff25d.orig/extensions/ebt_ip.c
+++ ebtables-2018-06-27-48cff25d/extensions/ebt_ip.c
@@ -16,7 +16,7 @@
 #include <getopt.h>
 #include <netdb.h>
 #include "../include/ebtables_u.h"
-#include <linux/netfilter_bridge/ebt_ip.h>
+#include "../include/linux/netfilter_bridge/ebt_ip.h"
 
 #define IP_SOURCE '1'
 #define IP_DEST   '2'
@@ -26,6 +26,16 @@
 #define IP_DPORT  '6'
 #define IP_ICMP   '7'
 #define IP_IGMP   '8'
+#define IP_myDSCP '9'
+#if 1 /* ZyXEL QoS, John */
+#define IP_LENGTH 'A'
+#define IP_TCP_FLAGS 'B'
+#define IP_DHCP_OPT60 'C'
+#define IP_DHCP_OPT61 'D'
+#define IP_DHCP_OPT77 'E'
+#define IP_DHCP_OPT125 'F'
+
+#endif
 
 static const struct option opts[] =
 {
@@ -42,6 +52,16 @@ static const struct option opts[] =
 	{ "ip-dport"            , required_argument, 0, IP_DPORT  },
 	{ "ip-icmp-type"        , required_argument, 0, IP_ICMP   },
 	{ "ip-igmp-type"        , required_argument, 0, IP_IGMP   },
+	{ "ip-dscp"             , required_argument, 0, IP_myDSCP },
+#if 1 /* ZyXEL QoS, John */
+	{ "ip-length"           , required_argument, 0, IP_LENGTH },
+	{ "ip-len"              , required_argument, 0, IP_LENGTH },
+	{ "ip-tcp-flags"        , required_argument, 0, IP_TCP_FLAGS  },
+	{ "ip-dhcp-opt60"       , required_argument, 0, IP_DHCP_OPT60 },
+	{ "ip-dhcp-opt61"       , required_argument, 0, IP_DHCP_OPT61 },
+	{ "ip-dhcp-opt77"       , required_argument, 0, IP_DHCP_OPT77 },
+	{ "ip-dhcp-opt125"      , required_argument, 0, IP_DHCP_OPT125 },
+#endif
 	{ 0 }
 };
 
@@ -162,6 +182,335 @@ static void print_port_range(uint16_t *p
 		printf("%d:%d ", ports[0], ports[1]);
 }
 
+#if 1 /* ZyXEL QoS, John (porting from MSTC)*/
+static uint16_t parse_length(const char *name)
+{
+	char *end;
+	int length;
+
+	length = strtol(name, &end, 10);
+
+	if (*end != '\0'){
+		ebt_print_error("Problem with specified length '%s'", name);
+		return 0; /* never reached */
+	}else if (length >= 0 || length <= 0xFFFF) {
+		return length;
+	}
+}
+
+static void
+parse_length_range( const char *lengthstring, uint16_t *length)
+{
+	char *buffer;
+	char *cp;
+
+	buffer = strdup(lengthstring);
+	if ((cp = strchr(buffer, ':')) == NULL)
+		length[0] = length[1] = parse_length(buffer);
+	else {
+		*cp = '\0';
+		cp++;
+		length[0] = buffer[0] ? parse_length( buffer) : 0;
+		length[1] = cp[0] ? parse_length( cp) : 0xFFFF;
+
+		if (length[0] > length[1])
+			ebt_print_error("Invalid lengthrange (min > max)");
+	}
+	free(buffer);
+}
+
+static void print_length_range(uint16_t *length)
+{
+	if (length[0] == length[1])
+		printf("%d ", length[0]);
+	else
+		printf("%d:%d ", length[0], length[1]);
+}
+
+struct tcp_flag_names {
+	const char *name;
+	unsigned int flag;
+};
+
+static struct tcp_flag_names tcp_flag_table[]
+= { { "FIN", 0x01 },
+    { "SYN", 0x02 },
+    { "RST", 0x04 },
+    { "PSH", 0x08 },
+    { "ACK", 0x10 },
+    { "URG", 0x20 },
+    { "ALL", 0x3F },
+    { "NONE", 0 },
+};
+
+static unsigned int
+parse_tcp_flag(const char *flags)
+{
+	unsigned int ret = 0;
+	char *ptr;
+	char *buffer;
+
+	buffer = strdup(flags);
+
+	for (ptr = strtok(buffer, ","); ptr; ptr = strtok(NULL, ",")) {
+		unsigned int i;
+		for (i = 0;
+		     i < sizeof(tcp_flag_table)/sizeof(struct tcp_flag_names);
+		     i++) {
+			if (strcasecmp(tcp_flag_table[i].name, ptr) == 0) {
+				ret |= tcp_flag_table[i].flag;
+				break;
+			}
+		}
+		if (i == sizeof(tcp_flag_table)/sizeof(struct tcp_flag_names))
+			ebt_print_error("Unknown TCP flag `%s'", ptr);
+		}
+
+	free(buffer);
+	return ret;
+}
+
+static void
+parse_tcp_flags(struct ebt_ip_info *ipinfo,
+		const char *mask,
+		const char *cmp)
+{
+	ipinfo->tcp_flg_mask = parse_tcp_flag(mask);
+	ipinfo->tcp_flg_cmp = parse_tcp_flag(cmp);
+}
+
+static void
+print_tcpf(uint8_t flags)
+{
+	int have_flag = 0;
+
+	while (flags) {
+		unsigned int i;
+
+		for (i = 0; (flags & tcp_flag_table[i].flag) == 0; i++);
+
+		if (have_flag)
+			printf(",");
+		printf("%s", tcp_flag_table[i].name);
+		have_flag = 1;
+
+		flags &= ~tcp_flag_table[i].flag;
+	}
+
+	if (!have_flag)
+		printf("NONE");
+}
+
+static void
+print_tcp_flags(uint8_t mask, uint8_t cmp)
+{
+	if (mask ) {
+		print_tcpf(mask);
+		printf(" ");
+		print_tcpf(cmp);
+		printf(" ");
+	}
+}
+
+static int
+dhcp_isxdigit(char *cfgstr){
+        int i =0;
+        printf("\n=========\n");
+        for(i=0; i<strlen(cfgstr); i++){
+                printf("%c",*(cfgstr+i));
+                if(!isxdigit(*(cfgstr+i))){
+                        return -1;
+                }
+        }
+        return 0;
+}
+
+static void
+parse_dhcp_opt60(struct cfgopt *cfg60, char *classidentifier, char *NextArg){
+
+        if(NextArg!=NULL && *NextArg != '-')
+                ebt_print_error("For DHCP Option 60 the class identifer string"
+                                        " must be speified by \"<Vendor Class Identifer>\"");
+
+        cfg60->len = strlen(classidentifier);
+
+        memset(cfg60->cfgdata, 0, sizeof(cfg60->cfgdata));
+        strcpy(cfg60->cfgdata, classidentifier);
+}
+
+static void
+parse_dhcp_opt61(struct cfgopt *cfg61, char *type, char *clientid, char *NextArg){
+
+        int i = 0, data_len = 0;
+        char data[8];
+
+        if(NextArg!=NULL && *NextArg != '-')
+                ebt_print_error("For DHCP Option 61, you must specify <Type> <Client ID>. ");
+
+        if(strlen(clientid)%2)
+                        ebt_print_error("For DHCP Option 61, you must specify client id with even digits. ");
+
+        if(dhcp_isxdigit(type) || dhcp_isxdigit(clientid))
+                ebt_print_error("For DHCP Option 61, you must specify value with hexadecimal. ");
+
+        memset(cfg61->cfgdata, 0, sizeof(cfg61->cfgdata));
+        memset(data, 0, sizeof(data));
+
+        data_len = strlen(clientid)/2;
+
+        cfg61->len = data_len + 1; /* Length is type + clientid */
+        cfg61->cfgdata[0] = strtol(type, NULL, 16);
+
+        for( i=0; i<data_len; i++){
+                strncpy(data, clientid+(i*2), 2);
+                data[2] = '\0';
+                cfg61->cfgdata[i+1] = strtol(data, NULL, 16);
+        }
+
+}
+
+static void
+parse_dhcp_opt77(struct cfgopt *cfg77, char *UserClassData, char *NextArg)
+{
+        int i=0, data_len=0;
+        char cfg[255],data[8];
+
+        if(NextArg!=NULL && *NextArg != '-')
+                ebt_print_error("For DHCP Option 77, you must specify <User Class Data>");
+
+        if(strlen(UserClassData)%2)
+                        ebt_print_error("For DHCP Option 77, you must specify user class data with even digits");
+
+        if(dhcp_isxdigit(UserClassData))
+                ebt_print_error("For DHCP Option 77, you must specify value with hexadecimal. ");
+
+        memset(cfg77->cfgdata, 0, sizeof(cfg77->cfgdata));
+        memset(cfg, 0, sizeof(cfg));
+        memset(data, 0, sizeof(data));
+
+        strcpy(cfg,UserClassData);
+
+        data_len = strlen(cfg)/2;/* length of user class data */
+
+        cfg77->len = data_len;
+
+        for( i=0; i<data_len; i++){
+                strncpy(data, cfg+(i*2), 2);
+                data[2] = '\0';
+                cfg77->cfgdata[i] = strtol(data, NULL, 16);
+        }
+
+
+}
+
+static void
+parse_dhcp_opt125(struct cfgopt *cfg125, char *EnterpriseNum, char *VendorClassData, char *NextArg)
+{
+        int i=0, data_len=0;
+        char cfg[255],data[8];
+
+        if(NextArg!=NULL && *NextArg != '-')
+                ebt_print_error("For DHCP Option 125, you must specify <Enterprise Number> <Vendor Class Data>");
+
+        if(strlen(EnterpriseNum)!=8)
+                ebt_print_error("For DHCP Option 125, Enterprise Number is 8 hexaecimal digits");
+
+        if(strlen(VendorClassData)%2)
+                        ebt_print_error("For DHCP Option 125, you must specify vendor class data with even digits");
+
+        if(dhcp_isxdigit(EnterpriseNum) || dhcp_isxdigit(VendorClassData))
+                        ebt_print_error("For DHCP Option 125, you must specify value with hexadecimal. ");
+
+        memset(cfg125->cfgdata, 0, sizeof(cfg125->cfgdata));
+        memset(cfg, 0, sizeof(cfg));
+        memset(data, 0, sizeof(data));
+
+        sprintf(cfg, "%s%02x%s", EnterpriseNum, strlen(VendorClassData)/2,VendorClassData);
+
+        data_len = strlen(cfg)/2; /* Length is enterprise number + data length + vendor class data */
+
+        cfg125->len = data_len;
+
+        for( i=0; i<data_len; i++){
+                strncpy(data, cfg+(i*2), 2);
+                data[2] = '\0';
+                cfg125->cfgdata[i] = strtol(data, NULL, 16);
+        }
+}
+
+static void print_dhcp_opt60(struct ebt_ip_info *info)
+{
+        if(info->invflags & EBT_IP_DHCP_OPT60)
+                printf("! ");
+
+        printf("\"%s\"", info->cfg60.cfgdata);
+        printf(" ");
+}
+
+
+static void print_dhcp_opt61(struct ebt_ip_info *info
+)
+{
+        int i=0;
+        uint8_t hv=0, bv=0;
+
+        if(info->invflags & EBT_IP_DHCP_OPT61)
+                printf("! ");
+
+        for(i=0; i<info->cfg61.len; i++){
+                hv = (*((info->cfg61.cfgdata)+i) >> 4) & 0x0f;
+                bv = (*((info->cfg61.cfgdata)+i)) & 0x0f;
+                printf("%1X",hv);
+                printf("%1X",bv);
+
+                if(i==0)
+                        printf(" ");
+        }
+        printf(" ");
+}
+
+static void print_dhcp_opt77(struct ebt_ip_info *info)
+{
+        int i=0;
+        uint8_t hv=0, bv=0;
+
+        if(info->invflags & EBT_IP_DHCP_OPT77)
+                printf("! ");
+
+        for(i=0; i<info->cfg77.len; i++){
+                hv = (*((info->cfg77.cfgdata)+i) >> 4) & 0x0f;
+                bv = (*((info->cfg77.cfgdata)+i)) & 0x0f;
+                printf("%1X",hv);
+                printf("%1X",bv);
+        }
+        printf(" ");
+}
+
+static void print_dhcp_opt125(struct ebt_ip_info *info)
+{
+        int i=0;
+        uint8_t hv=0, bv=0;
+
+        if(info->invflags & EBT_IP_DHCP_OPT125)
+                printf("! ");
+
+        for(i=0; i<info->cfg125.len; i++){
+                hv = (*((info->cfg125.cfgdata)+i) >> 4) & 0x0f;
+                bv = (*((info->cfg125.cfgdata)+i)) & 0x0f;
+                printf("%1X",hv);
+                printf("%1X",bv);
+
+                if(i==3){
+                        printf(" ");
+                        i++; /* skip length parameter*/
+                }
+        }
+        printf(" ");
+}
+
+
+#endif
+
 static void print_help()
 {
 	printf(
@@ -169,11 +518,22 @@ static void print_help()
 "--ip-src    [!] address[/mask]: ip source specification\n"
 "--ip-dst    [!] address[/mask]: ip destination specification\n"
 "--ip-tos    [!] tos           : ip tos specification\n"
+"--ip-dscp   [!] dscp          : ip dscp specification\n"
 "--ip-proto  [!] protocol      : ip protocol specification\n"
 "--ip-sport  [!] port[:port]   : tcp/udp source port or port range\n"
 "--ip-dport  [!] port[:port]   : tcp/udp destination port or port range\n"
 "--ip-icmp-type [!] type[[:type]/code[:code]] : icmp type/code or type/code range\n"
-"--ip-igmp-type [!] type[:type]               : igmp type or type range\n");
+"--ip-igmp-type [!] type[:type]               : igmp type or type range\n"
+#if 1 /* ZyXEL QoS, John (porting from MSTC)*/
+"--ip-len       [!] length[:length] : ip length or legth range\n"
+"--ip-tcp-flags [!] mask comp	   : when TCP flags & mask == comp\n"
+"				     (Flags: SYN ACK FIN RST URG PSH ALL NONE)\n"
+" --ip-dhcp-opt60  [!] <Class Id> : Match option 60 packet with class id (String)\n"
+" --ip-dhcp-opt61  [!] <Type> <Client Id> : Match option 61 packet with type and client id (Hexadecimal)\n"
+" --ip-dhcp-opt77  [!] <User Class Data>  : Match option 77 packet with user class data (Hexadecimal)\n"
+" --ip-dhcp-opt125 [!] <Enterprise Number> <Vendor Class Data> : Match option 125 packet with enterprise number and vendor class data (Hexadecimal)\n"
+#endif
+);
 
 	printf("\nValid ICMP Types:\n");
 	ebt_print_icmp_types(icmp_codes, ARRAY_SIZE(icmp_codes));
@@ -196,11 +556,25 @@ static void init(struct ebt_entry_match
 #define OPT_SPORT  0x10
 #define OPT_DPORT  0x20
 #define OPT_ICMP   0x40
-#define OPT_IGMP   0x80
+#define OPT_IGMP   0x80 //
+// ZYXEL
+#define OPT_DSCP   0x100
+#if 1 /* ZyXEL QoS, John (porting from MSTC)*/
+#define OPT_LENGTH 0X200
+#define OPT_TCP_FLAGS 0X400
+#define OPT_DHCP_OPT60 0X800
+#define OPT_DHCP_OPT61 0X1000
+#define OPT_DHCP_OPT77 0X2000
+#define OPT_DHCP_OPT125 0X4000
+#endif
+
 static int parse(int c, char **argv, int argc, const struct ebt_u_entry *entry,
    unsigned int *flags, struct ebt_entry_match **match)
 {
 	struct ebt_ip_info *ipinfo = (struct ebt_ip_info *)(*match)->data;
+#if 1 /* ZyXEL QoS, John (porting from MSTC)*/
+	struct cfgopt *cfgptr = NULL;
+#endif
 	char *end;
 	long int i;
 
@@ -276,6 +650,17 @@ static int parse(int c, char **argv, int
 		ipinfo->bitmask |= EBT_IP_TOS;
 		break;
 
+	case IP_myDSCP:
+		ebt_check_option2(flags, OPT_DSCP);
+		if (ebt_check_inverse2(optarg))
+			ipinfo->invflags |= EBT_IP_DSCP;
+		i = strtol(optarg, &end, 16);
+		if (i < 0 || i > 255 || (i & 0x3) || *end != '\0')
+			ebt_print_error("Problem with specified IP dscp");
+		ipinfo->dscp = i;
+		ipinfo->bitmask |= EBT_IP_DSCP;
+		break;
+
 	case IP_PROTO:
 		ebt_check_option2(flags, OPT_PROTO);
 		if (ebt_check_inverse2(optarg))
@@ -293,6 +678,73 @@ static int parse(int c, char **argv, int
 		}
 		ipinfo->bitmask |= EBT_IP_PROTO;
 		break;
+#if 1 /* ZyXEL QoS, John (porting from MSTC)*/
+                case IP_LENGTH:
+		ebt_check_option2(flags, OPT_LENGTH);
+		if (ebt_check_inverse2(optarg))
+			ipinfo->invflags |= EBT_IP_LENGTH;
+		if (optind > argc)
+			ebt_print_error("Missing IP length argument");
+		parse_length_range(argv[optind - 1], ipinfo->length);
+		ipinfo->bitmask |= EBT_IP_LENGTH;
+		break;
+	case IP_TCP_FLAGS:
+		ebt_check_option2(flags, OPT_TCP_FLAGS);
+		if (ebt_check_inverse2(optarg))
+			ipinfo->invflags |= EBT_IP_TCP_FLAGS;
+		if (optind > argc)
+			ebt_print_error("Missing TCP flags argument");
+		parse_tcp_flags(ipinfo, argv[optind - 1], argv[optind]);
+		optind++;/* Because it has two argument */
+		ipinfo->bitmask |= EBT_IP_TCP_FLAGS;
+		break;
+	case IP_DHCP_OPT60:
+		ebt_check_option2(flags, OPT_DHCP_OPT60);
+		if (ebt_check_inverse2(optarg))
+		    ipinfo->invflags |= EBT_IP_DHCP_OPT60;
+		if (optind > argc)
+		    ebt_print_error("Missing DHCP Option 60 argument");
+		cfgptr = &(ipinfo->cfg60);
+		parse_dhcp_opt60(cfgptr, argv[optind - 1], argv[optind]);
+		ipinfo->bitmask |= EBT_IP_DHCP_OPT60;
+		memset(ipinfo->SrcMacArray, 0, sizeof(ipinfo->SrcMacArray));
+		break;
+	case IP_DHCP_OPT61:
+		ebt_check_option2(flags, OPT_DHCP_OPT61);
+		if (ebt_check_inverse2(optarg))
+		    ipinfo->invflags |= EBT_IP_DHCP_OPT61;
+		if (optind > argc)
+		    ebt_print_error("Missing DHCP Option 61 argument");
+		optind +=1;
+		cfgptr = &(ipinfo->cfg61);
+		parse_dhcp_opt61(cfgptr, argv[optind - 2], argv[optind - 1], argv[optind]);
+		ipinfo->bitmask |= EBT_IP_DHCP_OPT61;
+		memset(ipinfo->SrcMacArray, 0, sizeof(ipinfo->SrcMacArray));
+		break;
+	case IP_DHCP_OPT77:
+		ebt_check_option2(flags, OPT_DHCP_OPT77);
+		if (ebt_check_inverse2(optarg))
+		    ipinfo->invflags |= EBT_IP_DHCP_OPT77;
+		if (optind > argc)
+		    ebt_print_error("Missing DHCP Option 77 argument");
+		cfgptr = &(ipinfo->cfg77);
+		parse_dhcp_opt77(cfgptr, argv[optind - 1], argv[optind]);
+		ipinfo->bitmask |= EBT_IP_DHCP_OPT77;
+		memset(ipinfo->SrcMacArray, 0, sizeof(ipinfo->SrcMacArray));
+		break;
+	case IP_DHCP_OPT125:
+		ebt_check_option2(flags, OPT_DHCP_OPT125);
+		if (ebt_check_inverse2(optarg))
+		    ipinfo->invflags |= EBT_IP_DHCP_OPT125;
+		if (optind > argc)
+		    ebt_print_error("Missing DHCP Option 125 argument");
+		optind +=1;
+		cfgptr = &(ipinfo->cfg125);
+		parse_dhcp_opt125(cfgptr, argv[optind - 2], argv[optind - 1], argv[optind]);
+		ipinfo->bitmask |= EBT_IP_DHCP_OPT125;
+		memset(ipinfo->SrcMacArray, 0, sizeof(ipinfo->SrcMacArray));
+		break;
+#endif
 	default:
 		return 0;
 	}
@@ -331,6 +783,14 @@ static void final_check(const struct ebt
 		ebt_print_error("For IGMP filtering the IP protocol must be "
 				"2 (igmp)");
 	}
+#if 1 /* ZyXEL QoS, John (porting from MSTC)*/
+	else  if (ipinfo->bitmask & EBT_IP_TCP_FLAGS &&
+		(!(ipinfo->bitmask & EBT_IP_PROTO) ||
+		ipinfo->invflags & EBT_IP_PROTO ||
+		ipinfo->protocol!=IPPROTO_TCP )) {
+		ebt_print_error("For TCP flags filtering the IP protocol must be 6 (tcp)");
+	}
+#endif
 }
 
 static void print(const struct ebt_u_entry *entry,
@@ -402,6 +862,45 @@ static void print(const struct ebt_u_ent
 		ebt_print_icmp_type(igmp_types, ARRAY_SIZE(igmp_types),
 				    ipinfo->igmp_type, NULL);
 	}
+	if (ipinfo->bitmask & EBT_IP_DSCP) {
+		printf("--ip-dscp ");
+		if (ipinfo->invflags & EBT_IP_DSCP)
+			printf("! ");
+		printf("0x%02X ", ipinfo->dscp);
+	}
+
+#if 1 /* ZyXEL QoS, John (porting from MSTC)*/
+	if (ipinfo->bitmask & EBT_IP_LENGTH) {
+		printf("--ip-len ");
+		if (ipinfo->invflags & EBT_IP_LENGTH) {
+			printf("! ");
+		}
+		print_length_range(ipinfo->length);
+	}
+	if (ipinfo->bitmask & EBT_IP_TCP_FLAGS) {
+		printf("--ip-tcp-flags ");
+		if (ipinfo->invflags & EBT_IP_TCP_FLAGS) {
+			printf("! ");
+		}
+		print_tcp_flags(ipinfo->tcp_flg_mask, ipinfo->tcp_flg_cmp);
+	}
+	 if(ipinfo->bitmask & EBT_IP_DHCP_OPT60){
+		printf("--ip-dhcp-opt60 ");
+		print_dhcp_opt60(ipinfo);
+	}
+	if(ipinfo->bitmask & EBT_IP_DHCP_OPT61){
+		printf("--ip-dhcp-opt61 ");
+		print_dhcp_opt61(ipinfo);
+	}
+	if(ipinfo->bitmask & EBT_IP_DHCP_OPT77){
+		printf("--ip-dhcp-opt77 ");
+		print_dhcp_opt77(ipinfo);
+	}
+	if(ipinfo->bitmask & EBT_IP_DHCP_OPT125){
+		printf("--ip-dhcp-opt125 ");
+		print_dhcp_opt125(ipinfo);
+	}
+#endif
 }
 
 static int compare(const struct ebt_entry_match *m1,
@@ -456,6 +955,23 @@ static int compare(const struct ebt_entr
 		    ipinfo1->igmp_type[1] != ipinfo2->igmp_type[1])
 			return 0;
 	}
+	if (ipinfo1->bitmask & EBT_IP_DSCP) {
+		if (ipinfo1->dscp != ipinfo2->dscp)
+			return 0;
+	}
+
+#if 1 /* ZyXEL QoS, John (porting from MSTC)*/
+	if (ipinfo1->bitmask & EBT_IP_LENGTH) {
+		if (ipinfo1->length[0] != ipinfo2->length[0] ||
+			ipinfo1->length[1] != ipinfo2->length[1])
+			return 0;
+	}
+	if (ipinfo1->bitmask & EBT_IP_TCP_FLAGS) {
+		if (ipinfo1->tcp_flg_cmp!= ipinfo2->tcp_flg_cmp ||
+		   ipinfo1->tcp_flg_mask!= ipinfo2->tcp_flg_mask)
+			return 0;
+	}
+#endif
 	return 1;
 }
 
Index: ebtables-2018-06-27-48cff25d/extensions/ebt_ip6.c
===================================================================
--- ebtables-2018-06-27-48cff25d.orig/extensions/ebt_ip6.c
+++ ebtables-2018-06-27-48cff25d/extensions/ebt_ip6.c
@@ -11,14 +11,20 @@
  *
  */
 
+#include <errno.h>
+#include <inttypes.h>
+#include <limits.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <getopt.h>
 #include <netdb.h>
 #include "../include/ebtables_u.h"
+#if 1 /* ZyXEL QoS, John */
+#include "../include/linux/netfilter_bridge/ebt_ip6.h"
+#else
 #include <linux/netfilter_bridge/ebt_ip6.h>
-
+#endif
 
 
 #define IP_SOURCE '1'
@@ -28,6 +34,9 @@
 #define IP_SPORT  '5'
 #define IP_DPORT  '6'
 #define IP_ICMP6  '7'
+#if 1 /* ZyXEL QoS, John (porting from MSTC)*/
+#define IP_LENGTH '8'
+#endif
 
 static const struct option opts[] =
 {
@@ -43,7 +52,11 @@ static const struct option opts[] =
 	{ "ip6-sport"            , required_argument, 0, IP_SPORT  },
 	{ "ip6-destination-port" , required_argument, 0, IP_DPORT  },
 	{ "ip6-dport"            , required_argument, 0, IP_DPORT  },
-	{ "ip6-icmp-type"	 , required_argument, 0, IP_ICMP6  },
+	{ "ip6-icmp-type"        , required_argument, 0, IP_ICMP6  },
+#if 1 /* ZyXEL QoS, John (porting from MSTC)*/
+	{ "ip6-length"           , required_argument, 0, IP_LENGTH },
+	{ "ip6-len"            	 , required_argument, 0, IP_LENGTH },
+#endif
 	{ 0 }
 };
 
@@ -112,7 +125,7 @@ parse_port_range(const char *protocol, c
 {
 	char *buffer;
 	char *cp;
-	
+
 	buffer = strdup(portstring);
 	if ((cp = strchr(buffer, ':')) == NULL)
 		ports[0] = ports[1] = parse_port(protocol, buffer);
@@ -125,13 +138,50 @@ parse_port_range(const char *protocol, c
 		ports[1] = cp[0] ? parse_port(protocol, cp) : 0xFFFF;
 		if (ebt_errormsg[0] != '\0')
 			return;
-		
+
 		if (ports[0] > ports[1])
 			ebt_print_error("Invalid portrange (min > max)");
 	}
 	free(buffer);
 }
 
+static char*
+parse_num(const char *str, long min, long max, long *num)
+{
+	char *end;
+
+	errno = 0;
+	*num = strtol(str, &end, 10);
+	if (errno && (*num == LONG_MIN || *num == LONG_MAX)) {
+		ebt_print_error("Invalid number %s: %s", str, strerror(errno));
+		return NULL;
+	}
+	if (min <= max) {
+		if (*num > max || *num < min) {
+			ebt_print_error("Value %ld out of range (%ld, %ld)", *num, min, max);
+			return NULL;
+		}
+	}
+	if (*num == 0 && str == end)
+		return NULL;
+	return end;
+}
+
+static char *
+parse_range(const char *str, long min, long max, long num[])
+{
+	char *next;
+
+	next = parse_num(str, min, max, num);
+	if (next == NULL)
+		return NULL;
+	if (next && *next == ':')
+		next = parse_num(next+1, min, max, &num[1]);
+	else
+		num[1] = num[0];
+	return next;
+}
+
 static void print_port_range(uint16_t *ports)
 {
 	if (ports[0] == ports[1])
@@ -140,6 +190,51 @@ static void print_port_range(uint16_t *p
 		printf("%d:%d ", ports[0], ports[1]);
 }
 
+#if 1 /* ZyXEL QoS, John (porting from MSTC)*/
+static uint16_t parse_length(const char *name)
+{
+	char *end;
+	int length;
+
+	length = strtol(name, &end, 10);
+
+	if (*end != '\0'){
+		ebt_print_error("Problem with specified length '%s'", name);
+		return 0; /* never reached */
+	}else if (length >= 0 || length <= 0xFFFF) {
+		return length;
+	}
+}
+
+static void
+parse_length_range( const char *lengthstring, uint16_t *length)
+{
+	char *buffer;
+	char *cp;
+
+	buffer = strdup(lengthstring);
+	if ((cp = strchr(buffer, ':')) == NULL)
+		length[0] = length[1] = parse_length(buffer);
+	else {
+		*cp = '\0';
+		cp++;
+		length[0] = buffer[0] ? parse_length( buffer) : 0;
+		length[1] = cp[0] ? parse_length( cp) : 0xFFFF;
+
+		if (length[0] > length[1])
+			ebt_print_error("Invalid lengthrange (min > max)");
+	}
+	free(buffer);
+}
+
+static void print_length_range(uint16_t *length)
+{
+	if (length[0] == length[1])
+		printf("%d ", length[0]);
+	else
+		printf("%d:%d ", length[0], length[1]);
+}
+#endif
 static void print_help()
 {
 	printf(
@@ -150,7 +245,11 @@ static void print_help()
 "--ip6-proto  [!] protocol      : ipv6 protocol specification\n"
 "--ip6-sport  [!] port[:port]   : tcp/udp source port or port range\n"
 "--ip6-dport  [!] port[:port]   : tcp/udp destination port or port range\n"
-"--ip6-icmp-type [!] type[[:type]/code[:code]] : ipv6-icmp type/code or type/code range\n");
+"--ip6-icmp-type [!] type[[:type]/code[:code]] : ipv6-icmp type/code or type/code range\n"
+#if 1 /* ZyXEL QoS, John (porting from MSTC)*/
+"--ip6-len    [!] length[:length] : ip length or legth range\n"
+#endif
+);
 
 	printf("\nValid ICMPv6 Types:\n");
 	ebt_print_icmp_types(icmpv6_codes, ARRAY_SIZE(icmpv6_codes));
@@ -174,6 +273,10 @@ static void init(struct ebt_entry_match
 #define OPT_PROTO  0x08
 #define OPT_SPORT  0x10
 #define OPT_DPORT  0x20
+#if 1 /* ZyXEL QoS, John (porting from MSTC)*/
+#define OPT_LENGTH 0x40
+#endif
+
 static int parse(int c, char **argv, int argc, const struct ebt_u_entry *entry,
    unsigned int *flags, struct ebt_entry_match **match)
 {
@@ -258,6 +361,17 @@ static int parse(int c, char **argv, int
 		}
 		ipinfo->bitmask |= EBT_IP6_PROTO;
 		break;
+#if 1 /* ZyXEL QoS, John (porting from MSTC)*/
+	case IP_LENGTH:
+		ebt_check_option2(flags, OPT_LENGTH);
+		if (ebt_check_inverse2(optarg))
+			ipinfo->invflags |= EBT_IP6_LENGTH;
+		if (optind > argc)
+			ebt_print_error("Missing IP length argument");
+		parse_length_range(argv[optind - 1], ipinfo->length);
+		ipinfo->bitmask |= EBT_IP6_LENGTH;
+		break;
+#endif
 	default:
 		return 0;
 	}
@@ -348,6 +462,15 @@ static void print(const struct ebt_u_ent
 		ebt_print_icmp_type(icmpv6_codes, ARRAY_SIZE(icmpv6_codes),
 				    ipinfo->icmpv6_type, ipinfo->icmpv6_code);
 	}
+#if 1 /* ZyXEL QoS, John (porting from MSTC)*/
+	if (ipinfo->bitmask & EBT_IP6_LENGTH) {
+		printf("--ip6-len ");
+		if (ipinfo->invflags & EBT_IP6_LENGTH) {
+			printf("! ");
+		}
+		print_length_range(ipinfo->length);
+	}
+#endif
 }
 
 static int compare(const struct ebt_entry_match *m1,
@@ -397,6 +520,13 @@ static int compare(const struct ebt_entr
 		    ipinfo1->icmpv6_code[1] != ipinfo2->icmpv6_code[1])
 			return 0;
 	}
+#if 1 /* ZyXEL QoS, John (porting from MSTC)*/
+	if (ipinfo1->bitmask & EBT_IP6_LENGTH) {
+		if (ipinfo1->length[0] != ipinfo2->length[0] ||
+				ipinfo1->length[1] != ipinfo2->length[1])
+			return 0;
+	}
+#endif
 	return 1;
 }
 
Index: ebtables-2018-06-27-48cff25d/include/linux/netfilter_bridge/ebt_ip.h
===================================================================
--- ebtables-2018-06-27-48cff25d.orig/include/linux/netfilter_bridge/ebt_ip.h
+++ ebtables-2018-06-27-48cff25d/include/linux/netfilter_bridge/ebt_ip.h
@@ -26,17 +26,139 @@
 #define EBT_IP_DPORT 0x20
 #define EBT_IP_ICMP 0x40
 #define EBT_IP_IGMP 0x80
+
+#if 1 /* ZyXEL QoS, John (porting from MSTC) */
+
+#if 1 //defined(X_CONFIG_BCM_KF_NETFILTER) || !defined(X_CONFIG_BCM_IN_KERNEL)
+#define EBT_IP_DSCP  0x100
+#endif
+
+#define EBT_IP_LENGTH 0x200
+#define EBT_IP_TCP_FLAGS 0x400
+#define EBT_IP_DHCP_OPT60 0x800
+#define EBT_IP_DHCP_OPT61 0x1000
+#define EBT_IP_DHCP_OPT77 0x2000
+#define EBT_IP_DHCP_OPT125 0x4000
+
+#if 1 //defined(X_CONFIG_BCM_KF_NETFILTER) || !defined(X_CONFIG_BCM_IN_KERNEL)
+#define EBT_IP_MASK (EBT_IP_SOURCE | EBT_IP_DEST | EBT_IP_TOS | EBT_IP_PROTO |\
+ EBT_IP_SPORT | EBT_IP_DPORT | EBT_IP_ICMP | EBT_IP_IGMP | EBT_IP_DSCP | EBT_IP_LENGTH | EBT_IP_TCP_FLAGS |\
+ EBT_IP_DHCP_OPT60 | EBT_IP_DHCP_OPT61 | EBT_IP_DHCP_OPT77 | EBT_IP_DHCP_OPT125)
+#else
+#define EBT_IP_MASK (EBT_IP_SOURCE | EBT_IP_DEST | EBT_IP_TOS | EBT_IP_PROTO |\
+ EBT_IP_SPORT | EBT_IP_DPORT | EBT_IP_ICMP | EBT_IP_IGMP | EBT_IP_LENGTH | EBT_IP_TCP_FLAGS |\
+ EBT_IP_DHCP_OPT60 | EBT_IP_DHCP_OPT61 | EBT_IP_DHCP_OPT77 | EBT_IP_DHCP_OPT125)
+#endif
+
+#define DHCP_OPTION_MAX_LEN 556 /* IP header(20) + UDP header(8)+ DHCP header(528) */
+
+#define DHCP_PADDING                            0x00
+#define DHCP_VENDOR                             0x3c    /*option 60 */
+#define DHCP_CLIENT_ID                          0x3d    /*option 61 */
+#define DHCP_USER_CLASS_ID                      0x4d    /*option 77 */
+#define DHCP_VENDOR_IDENTIFYING 				0x7d    /*option 125 */
+#define DHCP_OPTION_OVER                        0x34
+#define DHCP_END                                0xFF
+
+#define OPTION_FIELD            0
+#define FILE_FIELD              1
+#define SNAME_FIELD             2
+
+
+
+/* miscellaneous defines */
+#define OPT_CODE 0
+#define OPT_LEN 1
+#define OPT_DATA 2
+
+#define OPTION_MAC_ENTRY 32
+
+/* each option data shift length */
+#define DHCP_OPT_LEN_FIELD_LEN  1
+#define DHCP_OPT125_ENTERPRISE_NUM_LEN 4
+#define DHCP_OPT125_DATA_SHIFT DHCP_OPT125_ENTERPRISE_NUM_LEN + DHCP_OPT_LEN_FIELD_LEN
+
+#else
+
+#if defined(CONFIG_BCM_KF_NETFILTER) || !defined(CONFIG_BCM_IN_KERNEL)
+#define EBT_IP_DSCP  0x100
+#define EBT_IP_MASK (EBT_IP_SOURCE | EBT_IP_DEST | EBT_IP_TOS | EBT_IP_PROTO |\
+ EBT_IP_SPORT | EBT_IP_DPORT | EBT_IP_ICMP | EBT_IP_IGMP | EBT_IP_DSCP )
+#else
 #define EBT_IP_MASK (EBT_IP_SOURCE | EBT_IP_DEST | EBT_IP_TOS | EBT_IP_PROTO |\
-		     EBT_IP_SPORT | EBT_IP_DPORT | EBT_IP_ICMP | EBT_IP_IGMP)
+ EBT_IP_SPORT | EBT_IP_DPORT | EBT_IP_ICMP | EBT_IP_IGMP)
+#endif
+
+#endif // ZYXEL
 #define EBT_IP_MATCH "ip"
 
 /* the same values are used for the invflags */
+#if 1 /* ZyXEL QoS, John (porting from MSTC) */
+struct cfgopt{
+        uint8_t len;
+        char cfgdata[254];
+};
+
+struct dhcpMessage {
+        uint8_t op;
+        uint8_t htype;
+        uint8_t hlen;
+        uint8_t hops;
+        uint32_t xid;
+        uint16_t secs;
+        uint16_t flags;
+        uint32_t ciaddr;
+        uint32_t yiaddr;
+        uint32_t siaddr;
+        uint32_t giaddr;
+        uint8_t chaddr[16];
+        uint8_t sname[64];
+        uint8_t file[128];
+        uint32_t cookie;
+        uint8_t options[308]; /* 312 - cookie */
+};
+
+struct ebt_ip_info
+{
+	__be32 saddr;
+	__be32 daddr;
+	__be32 smsk;
+	__be32 dmsk;
+	__u8  tos;
+#if 1 //defined(X_CONFIG_BCM_KF_NETFILTER) || !defined(X_CONFIG_BCM_IN_KERNEL)
+	__u8  dscp; /* brcm */
+#endif
+	__u8  protocol;
+	__u16  bitmask;
+	__u16  invflags;
+	union {
+		__u16 sport[2];
+		__u8 icmp_type[2];
+		__u8 igmp_type[2];
+	};
+	union {
+		__u16 dport[2];
+		__u8 icmp_code[2];
+	};
+	__u8  tcp_flg_mask;
+	__u8  tcp_flg_cmp;
+	__u16 length[2];
+	struct cfgopt cfg60; //option 60
+    struct cfgopt cfg61; //option 61
+    struct cfgopt cfg77; //option 77
+    struct cfgopt cfg125; //option 125
+    char SrcMacArray[OPTION_MAC_ENTRY][ETH_ALEN];
+};
+#else
 struct ebt_ip_info {
 	__be32 saddr;
 	__be32 daddr;
 	__be32 smsk;
 	__be32 dmsk;
 	__u8  tos;
+#if defined(CONFIG_BCM_KF_NETFILTER) || !defined(CONFIG_BCM_IN_KERNEL)
+	__u8  dscp;
+#endif
 	__u8  protocol;
 	__u8  bitmask;
 	__u8  invflags;
@@ -50,5 +172,6 @@ struct ebt_ip_info {
 		__u8 icmp_code[2];
 	};
 };
+#endif
 
 #endif
Index: ebtables-2018-06-27-48cff25d/include/linux/netfilter_bridge/ebt_ip6.h
===================================================================
--- ebtables-2018-06-27-48cff25d.orig/include/linux/netfilter_bridge/ebt_ip6.h
+++ ebtables-2018-06-27-48cff25d/include/linux/netfilter_bridge/ebt_ip6.h
@@ -22,9 +22,25 @@
 #define EBT_IP6_DPORT 0x20
 #define EBT_IP6_ICMP6 0x40
 
+//#if 1 /* ZyXEL QoS, John (porting from MSTC) */
+//#if defined(CONFIG_TC_SDK_7_3_245_300) || defined(CONFIG_TC_SDK_7_3_257_150)
+#define EBT_IP6_LENGTH 0x80
+//#else
+//#define EBT_IP6_LENGTH 0x40
+//#endif
+//#endif
+
+
+#if 1 /* ZyXEL QoS, John (porting from MSTC) */
+#define EBT_IP6_MASK (EBT_IP6_SOURCE | EBT_IP6_DEST | EBT_IP6_TCLASS |\
+		      EBT_IP6_PROTO | EBT_IP6_SPORT | EBT_IP6_DPORT | \
+		      EBT_IP6_ICMP6 | EBT_IP6_LENGTH)
+#else
 #define EBT_IP6_MASK (EBT_IP6_SOURCE | EBT_IP6_DEST | EBT_IP6_TCLASS |\
 		      EBT_IP6_PROTO | EBT_IP6_SPORT | EBT_IP6_DPORT | \
 		      EBT_IP6_ICMP6)
+#endif
+
 #define EBT_IP6_MATCH "ip6"
 
 /* the same values are used for the invflags */
@@ -45,6 +61,9 @@ struct ebt_ip6_info {
 		__u16 dport[2];
 		__u8 icmpv6_code[2];
 	};
+#if 1 /* ZyXEL QoS, John (porting from MSTC) */
+	uint16_t length[2];
+#endif
 };
 
 #endif
Index: ebtables-2018-06-27-48cff25d/extensions/ebt_nfqueue.c
===================================================================
--- /dev/null
+++ ebtables-2018-06-27-48cff25d/extensions/ebt_nfqueue.c
@@ -0,0 +1,130 @@
+/*
+ * Shared library add-on to ebtables for NFQ
+ *
+ * (C) 2012 by Ma Jie Yue <jieyue.majy@xxxxxxxxxxxxxx>
+ *
+ * This program is distributed under the terms of GNU GPLv2, 1991
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <errno.h>
+
+#include "../include/ebtables_u.h"
+//#include <linux/netfilter/x_tables.h>
+
+#define NFQUEUE_QUEUENUM 0x1
+#define NFQUEUE_QUEUEBALANCE 0x2
+
+struct xt_NFQ_info {
+   __u16 queuenum;
+   int target;
+};
+
+static int string_to_number(const char *s, unsigned int min, unsigned int max, unsigned int *ret)
+{
+   long number;
+   char *end;
+   errno = 0;
+   number = strtol(s, &end, 0);
+
+   if (*end == '\0' && end != s) {
+       if (errno != ERANGE && min <= number && number <= max) {
+           *ret = number;
+           return 0;
+       }
+   }
+   return -1;
+}
+
+static void nfqueue_help(void)
+{
+   printf("NFQUEUE target options\n"
+           "  --queue-num value       Send packet to QUEUE number <value>.\n"
+           "                          Valid queue numbers are 0-65535\n");
+}
+
+static void nfqueue_init(struct ebt_entry_target* target) {
+   struct xt_NFQ_info* info = (struct xt_NFQ_info *)target->data;
+
+   info->queuenum = 0;
+}
+
+static const struct option nfqueue_opts[] = {
+   { "queue-num", 1, NULL, 'F' },
+   { "queue-balance", 1, NULL, 'B' },
+   { .name = NULL }
+};
+
+static void parse_num(const char *s, struct xt_NFQ_info *tinfo)
+{
+   unsigned int num = 0;
+   if (string_to_number(s, 0, 65535, &num) < 0) {
+       ebt_print_error("Invalid queue number %s\n", s);
+   }
+
+   tinfo->queuenum = num;
+}
+
+static int nfqueue_parse(int c, char **argv, int argc,
+       const struct ebt_u_entry *entry, unsigned int *flags,
+       struct ebt_entry_target **target)
+{
+   struct xt_NFQ_info *tinfo = (struct xt_NFQ_info *)(*target)->data;
+   tinfo->queuenum = 0;
+
+   switch (c) {
+       case 'F':
+           if (*flags)
+               ebt_print_error2("NFQUEUE target: "
+                               "Only use --queue-num ONCE!");
+           *flags |= NFQUEUE_QUEUENUM;
+           parse_num(optarg, tinfo);
+           break;
+
+       case 'B':
+           ebt_print_error2("NFQUEUE target: "
+                           "--queue-balance not supported (kernel too old?)");
+
+       default:
+           break;
+   }
+   return 1;
+}
+
+static void nfqueue_print(const struct ebt_u_entry* entry, const struct ebt_entry_target *target) {
+   struct xt_NFQ_info *tinfo = (struct xt_NFQ_info *)target->data;
+
+   printf("--queue-num %u ", tinfo->queuenum);
+}
+
+static void nfqueue_check(const struct ebt_u_entry *entry,
+               const struct ebt_entry_target *target, const char *name,
+               unsigned int hookmask, unsigned int time) {
+
+}
+
+static int nfqueue_compare(const struct ebt_entry_target *t1, const struct ebt_entry_target *t2) {
+   struct xt_NFQ_info *info1 = (struct xt_NFQ_info *)t1->data;
+   struct xt_NFQ_info *info2 = (struct xt_NFQ_info *)t2->data;
+
+   return (info1->queuenum == info2->queuenum);
+}
+
+static struct ebt_u_target nfqueue_target = {
+   .name       = "nfqueue",
+   .init       = nfqueue_init,
+   .size       = sizeof(struct xt_NFQ_info),
+   .help       = nfqueue_help,
+   .parse      = nfqueue_parse,
+   .print      = nfqueue_print,
+   .final_check    = nfqueue_check,
+   .compare    = nfqueue_compare,
+   .extra_ops  = nfqueue_opts,
+};
+
+__attribute__((constructor)) static void extension_init(void) {
+   ebt_register_target(&nfqueue_target);
+}
Index: ebtables-2018-06-27-48cff25d/extensions/Makefile
===================================================================
--- ebtables-2018-06-27-48cff25d.orig/extensions/Makefile
+++ ebtables-2018-06-27-48cff25d/extensions/Makefile
@@ -2,6 +2,15 @@
 
 EXT_FUNC+=802_3 nat arp arpreply ip ip6 standard log redirect vlan mark_m mark \
           pkttype stp among limit ulog nflog string
+
+EXT_FUNC+=AUTOMAP ftos policer tc
+ifneq ($(CONFIG_KERNEL_BRIDGE_EBT_NFQUEUE),)
+EXT_FUNC+=nfqueue
+endif
+ifneq ($(CONFIG_KERNEL_BRIDGE_EBT_DHCPOPT),)
+EXT_FUNC+=dhcpopt
+endif
+
 EXT_TABLES+=filter nat broute
 EXT_OBJS+=$(foreach T,$(EXT_FUNC), extensions/ebt_$(T).o)
 EXT_OBJS+=$(foreach T,$(EXT_TABLES), extensions/ebtable_$(T).o)
Index: ebtables-2018-06-27-48cff25d/extensions/ebt_dhcpopt.c
===================================================================
--- /dev/null
+++ ebtables-2018-06-27-48cff25d/extensions/ebt_dhcpopt.c
@@ -0,0 +1,156 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <getopt.h>
+#include <netdb.h>
+#include "../include/ebtables_u.h"
+#include <linux/netfilter_bridge/ebt_ip.h>
+#include <linux/netfilter_bridge/ebt_dhcpopt.h>
+
+#define IP_SOURCE '1'
+#define IP_DEST   '2'
+#define IP_myTOS  '3' /* include/bits/in.h seems to already define IP_TOS */
+#define IP_PROTO  '4'
+#define IP_SPORT  '5'
+#define IP_DPORT  '6'
+#define DHCP_OPTION '7'
+#define OPT_SOURCE 0x01
+#define OPT_DEST   0x02
+#define OPT_TOS    0x04
+#define OPT_PROTO  0x08
+#define OPT_SPORT  0x10
+#define OPT_DPORT  0x20
+#define OPT_DHCP_OPTION  0x40
+
+static struct option opts[] =
+{
+	{ "dhcp_option"           , required_argument, 0, DHCP_OPTION },
+	{ 0 }
+};
+
+static void print_help()
+{
+	printf(
+"DHCP options:\n"
+"--dhcp_option    [!] address[/mask]: ip source specification\n");
+}
+
+static void init(struct ebt_entry_match *match)
+{
+	struct ebt_dhcpopt_info *dhcpoptinfo = (struct ebt_dhcpopt_info *)match->data;
+
+	dhcpoptinfo->invflags = 0;
+	dhcpoptinfo->bitmask = 0;
+}
+
+static int parse(int c, char **argv, int argc, const struct ebt_u_entry *entry,
+   unsigned int *flags, struct ebt_entry_match **match)
+{
+	struct ebt_dhcpopt_info *dhcpoptinfo = (struct ebt_dhcpopt_info *)(*match)->data;
+	char *end;
+	long int i;
+
+	switch (c) {
+	case DHCP_OPTION:
+		ebt_check_option2(flags, OPT_DHCP_OPTION);
+		dhcpoptinfo->bitmask |= EBT_DHCP_OPTION;
+		if (ebt_check_inverse2(optarg))
+			dhcpoptinfo->invflags |= EBT_DHCP_OPTION;
+		if (optind > argc)
+			ebt_print_error2("Missing DHCP_OPTION argument");
+			strcpy(dhcpoptinfo->optionString,argv[optind - 1]);
+		break;
+
+	default:
+		return 0;
+	}
+	return 1;
+}
+
+static void final_check(const struct ebt_u_entry *entry,
+   const struct ebt_entry_match *match, const char *name,
+   unsigned int hookmask, unsigned int time)
+{
+#if 0
+ 	struct ebt_dhcpopt_info *dhcpoptinfo = (struct ebt_dhcpopt_info *)match->data;
+	if (entry->ethproto != ETH_P_IP || entry->invflags & EBT_IPROTO)
+		ebt_print_error2("For IP filtering the protocol must be "
+		            "specified as IPv4");
+#endif
+}
+
+static void print(const struct ebt_u_entry *entry,
+   const struct ebt_entry_match *match)
+{
+	struct ebt_dhcpopt_info *dhcpoptinfo = (struct ebt_dhcpopt_info *)match->data;
+
+	if (dhcpoptinfo->bitmask & EBT_DHCP_OPTION) {
+		printf("--dhcp_option ");
+		if (dhcpoptinfo->invflags & EBT_DHCP_OPTION)
+			printf("! ");
+
+		printf("%s ", dhcpoptinfo->optionString);
+	}
+}
+
+static int compare(const struct ebt_entry_match *m1,
+   const struct ebt_entry_match *m2)
+{
+	struct ebt_ip_info *ipinfo1 = (struct ebt_ip_info *)m1->data;
+	struct ebt_ip_info *ipinfo2 = (struct ebt_ip_info *)m2->data;
+
+	if (ipinfo1->bitmask != ipinfo2->bitmask)
+		return 0;
+	if (ipinfo1->invflags != ipinfo2->invflags)
+		return 0;
+	if (ipinfo1->bitmask & EBT_IP_SOURCE) {
+		if (ipinfo1->saddr != ipinfo2->saddr)
+			return 0;
+		if (ipinfo1->smsk != ipinfo2->smsk)
+			return 0;
+	}
+	if (ipinfo1->bitmask & EBT_IP_DEST) {
+		if (ipinfo1->daddr != ipinfo2->daddr)
+			return 0;
+		if (ipinfo1->dmsk != ipinfo2->dmsk)
+			return 0;
+	}
+	if (ipinfo1->bitmask & EBT_IP_TOS) {
+		if (ipinfo1->tos != ipinfo2->tos)
+			return 0;
+	}
+	if (ipinfo1->bitmask & EBT_IP_PROTO) {
+		if (ipinfo1->protocol != ipinfo2->protocol)
+			return 0;
+	}
+	if (ipinfo1->bitmask & EBT_IP_SPORT) {
+		if (ipinfo1->sport[0] != ipinfo2->sport[0] ||
+		   ipinfo1->sport[1] != ipinfo2->sport[1])
+			return 0;
+	}
+	if (ipinfo1->bitmask & EBT_IP_DPORT) {
+		if (ipinfo1->dport[0] != ipinfo2->dport[0] ||
+		   ipinfo1->dport[1] != ipinfo2->dport[1])
+			return 0;
+	}
+	return 1;
+}
+
+static struct ebt_u_match dhcpopt_match =
+{
+	.name		= EBT_DHCPOPT_MATCH,
+	.size		= sizeof(struct ebt_dhcpopt_info),
+	.help		= print_help,
+	.init		= init,
+	.parse		= parse,
+	.final_check	= final_check,
+	.print		= print,
+	.compare	= compare,
+	.extra_ops	= opts,
+};
+
+__attribute__((constructor)) static void extension_init(void)
+{
+	ebt_register_match(&dhcpopt_match);
+}
+
Index: ebtables-2018-06-27-48cff25d/include/linux/netfilter_bridge/ebt_dhcpopt.h
===================================================================
--- /dev/null
+++ ebtables-2018-06-27-48cff25d/include/linux/netfilter_bridge/ebt_dhcpopt.h
@@ -0,0 +1,18 @@
+#ifndef __LINUX_BRIDGE_EBT_DHCPOPT_H
+#define __LINUX_BRIDGE_EBT_DHCPOPT_H
+
+#define EBT_DHCP_OPTION 0x01
+
+#define EBT_DHCP_OPTION_MASK (EBT_DHCP_OPTION /* |*/)
+#define EBT_DHCPOPT_MATCH "dhcpopt"
+
+/* the same values are used for the invflags */
+struct ebt_dhcpopt_info
+{
+	uint8_t optionNum;
+	uint8_t  bitmask;
+	uint8_t  invflags;
+	char optionString[256];
+};
+#endif
+
Index: ebtables-2018-06-27-48cff25d/include/linux/netfilter_bridge/ebt_tc.h
===================================================================
--- /dev/null
+++ ebtables-2018-06-27-48cff25d/include/linux/netfilter_bridge/ebt_tc.h
@@ -0,0 +1,12 @@
+#ifndef __LINUX_BRIDGE_EBT_TC_H_
+#define __LINUX_BRIDGE_EBT_TC_H_
+
+struct ebt_tc_info
+{
+	unsigned char tc;
+	int target;
+};
+#define EBT_TC_TARGET "tc"
+
+#endif
+
Index: ebtables-2018-06-27-48cff25d/zyxel-memo
===================================================================
--- /dev/null
+++ ebtables-2018-06-27-48cff25d/zyxel-memo
@@ -0,0 +1,11 @@
+
+ZYXEL Enhancements:
+2022/02/10:
+  add zyxel modifications of v2.0.8-2, including
+    001-support_ECONET.patch
+    002-ZYXEL_BUGFIX_ebtables_module_for_QoS_JakeChang.patch
+    003-ZYXEL_BUGFIX_support_QoS_policer_JakeChang.patch
+    008-ZYXEL_ENHANCE_add_ebtables_nfqueue_target_support_RyanYeh.patch
+    011-ZYXEL_FEATURE_Add_DHCPv4_Option_classifier_ShermanJuan.patch
+  , excluding sdk-relating
+
