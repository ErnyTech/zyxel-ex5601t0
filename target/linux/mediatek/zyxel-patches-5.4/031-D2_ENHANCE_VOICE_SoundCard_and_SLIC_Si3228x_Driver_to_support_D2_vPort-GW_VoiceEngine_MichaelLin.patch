Index: linux-5.4.171/sound/soc/codecs/si3218x/Makefile
===================================================================
--- linux-5.4.171.orig/sound/soc/codecs/si3218x/Makefile	2022-02-07 17:55:33.855596500 +0800
+++ linux-5.4.171/sound/soc/codecs/si3218x/Makefile	2022-02-23 09:24:03.604997500 +0800
@@ -3,7 +3,11 @@
 # Add to Makefile of prented folder: obj-$(CONFIG_SND_SOC_PROSLIC) += proslic/
 
 # Platform
-subdir-ccflags-y += -DSI3218X
+#
+#D2 MOD.
+#subdir-ccflags-y += -DSI3218X
+subdir-ccflags-y += -DSI3228X
+#
 subdir-ccflags-y += -DPROSLIC_LINUX_KERNEL
 subdir-ccflags-y += -Iinc
 subdir-ccflags-y += -Iconfig_inc
@@ -12,6 +16,11 @@ subdir-ccflags-y += -Iconfig_inc
 # Basic
 snd-soc-si3218x-objs := proslic_sys_main.o proslic_sys_spi.o proslic_sys_timer.o si3218x.o proslic_spi_api.o proslic_timer_intf_linux.o
 
-obj-$(CONFIG_SND_SOC_SI3218X) += src/proslic.o src/proslic_tstin.o src/si_voice.o src/si_voice_version.o src/si3218x_intf.o src/vdaa.o src/vdaa_constants.o src/si3218x_LCCB_constants.o
-obj-$(CONFIG_SND_SOC_SI3218X) += patch_files/si3218x_patch_A_2017MAY25.o
+#D2 MOD.
+#obj-$(CONFIG_SND_SOC_SI3218X) += src/proslic.o src/proslic_tstin.o src/si_voice.o src/si_voice_version.o src/si3218x_intf.o src/vdaa.o src/vdaa_constants.o src/si3218x_LCCB_constants.o
+#obj-$(CONFIG_SND_SOC_SI3218X) += patch_files/si3218x_patch_A_2017MAY25.o
+obj-$(CONFIG_SND_SOC_SI3218X) += src/proslic.o src/proslic_tstin.o src/si_voice.o src/si_voice_version.o src/si3218x_intf.o src/si3226x_intf.o src/si3228x_intf.o src/vdaa.o src/vdaa_constants.o src/si3218x_LCCB_constants.o src/si3226x_FLBK_constants.o src/si3228x_LCCB_constants.o
+#obj-$(CONFIG_SND_SOC_SI3218X) += patch_files/si3218x_patch_A_2017MAY25.o patch_files/si3226x_patch_C_FB_2017MAY26.o patch_files/si3228x_patch_A_2017MAY26.o
+obj-$(CONFIG_SND_SOC_SI3218X) += patch_files/si3226x_patch_C_FB_2017MAY26.o patch_files/si3228x_patch_A_2017MAY26.o
+#
 obj-$(CONFIG_SND_SOC_SI3218X) += snd-soc-si3218x.o
Index: linux-5.4.171/sound/soc/codecs/si3218x/inc/si3226x.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-5.4.171/sound/soc/codecs/si3218x/inc/si3226x.h	2022-02-22 10:59:20.000000000 +0800
@@ -0,0 +1,276 @@
+/*
+** Copyright (c) 2007-2016 by Silicon Laboratories
+**
+** $Id: si3226x.h 42313 2018-02-10 07:12:50Z oliu $
+**
+** Author(s):
+** laj
+**
+** Distributed by:
+** Silicon Laboratories, Inc
+**
+** This file contains proprietary information.
+** No dissemination allowed without prior written permission from
+** Silicon Laboratories, Inc.
+**
+*/
+
+#ifndef SI3226XH_H
+#define SI3226XH_H
+
+#include "proslic.h"
+
+#define SI3226X_CHAN_PER_DEVICE     2
+
+/*
+** SI3226X DataTypes/Function Definitions
+*/
+
+/*
+** Defines structure for configuring gpio
+*/
+typedef struct
+{
+  uInt8 outputEn;
+  uInt8 analog;
+  uInt8 direction;
+  uInt8 manual;
+  uInt8 polarity;
+  uInt8 openDrain;
+  uInt8 batselmap;
+} Si3226x_GPIO_Cfg;
+
+typedef ProSLIC_DCfeed_Cfg Si3226x_DCfeed_Cfg;
+typedef Si3226x_DCfeed_Cfg *Si3226x_DCfeed_Cfg_ptr;
+/*
+** Defines structure for general configuration and the dcdc converter
+*/
+typedef struct
+{
+  uInt8 device_key;    /* Used to prevent loaded coeffs for another device */
+  bomOptionsType bomOpt;
+  batRailType  batType;
+  ramData bat_hyst;
+  ramData vbatr_expect; /* default - this is overwritten by ring preset */
+  ramData vbath_expect;  /* default - this is overwritten by dc feed preset */
+  ramData pwrsave_timer;
+  ramData offhook_thresh;
+  ramData vbat_track_min;
+  ramData vbat_track_min_rng;
+  ramData pwrsave_dbi;
+  ramData dcdc_ana_scale;
+  ramData vov_bat_pwrsave_min;
+  ramData vov_bat_pwrsave_min_rng;
+  ramData therm_dbi;
+  ramData cpump_dbi;
+  ramData dcdc_verr;
+  ramData dcdc_verr_hyst;
+  ramData dcdc_oithresh_lo;
+  ramData dcdc_oithresh_hi;
+  ramData pd_uvlo;
+  ramData pd_ovlo;
+  ramData pd_oclo;
+  ramData pd_swdrv;
+  ramData dcdc_uvhyst;
+  ramData dcdc_uvthresh;
+  ramData dcdc_ovthresh;
+  ramData dcdc_oithresh;
+  ramData dcdc_swdrv_pol;
+  ramData dcdc_uvpol;
+  ramData dcdc_vref_man;
+  ramData dcdc_vref_ctrl;
+  ramData dcdc_rngtype;
+  ramData dcdc_ana_vref;
+  ramData dcdc_ana_gain;
+  ramData dcdc_ana_toff;
+  ramData dcdc_ana_tonmin;
+  ramData dcdc_ana_tonmax;
+  ramData dcdc_ana_dshift;
+  ramData dcdc_ana_lpoly;
+  ramData dcdc_aux_invert;
+  ramData dcdc_cpump_lp;
+  ramData dcdc_cpump_pulldown;
+  ramData dcdc_lift_en;
+  ramData coef_p_hvic;
+  ramData p_th_hvic;
+  uInt8 vdc_range;       /* Was cm_clamp  pre 6.5.0 */
+  uInt8 autoRegister;
+  uInt8 irqen1;
+  uInt8 irqen2;
+  uInt8 irqen3;
+  uInt8 irqen4;
+  uInt8 enhance;
+  ramData scale_kaudio;
+  uInt8 zcal_en;
+  ramData lkg_ofhk_offset;
+  ramData lkg_lb_offset;
+  ramData vbath_delta;
+  ramData uvthresh_max;
+  ramData uvthresh_scale;
+  ramData uvthresh_bias;
+} Si3226x_General_Cfg;
+
+
+/*
+** Defines structure for configuring pcm
+*/
+typedef struct
+{
+  uInt8 pcmFormat;
+  uInt8 widebandEn;
+  uInt8 pcm_tri;
+  uInt8 tx_edge;
+  uInt8 alaw_inv;
+} Si3226x_PCM_Cfg;
+
+/*
+** Defines structure for configuring pulse metering
+*/
+typedef struct
+{
+  ramData pm_amp_thresh;
+  uInt8 pm_freq;
+  uInt8 pm_auto;
+  ramData pm_active;
+  ramData pm_inactive;
+} Si3226x_PulseMeter_Cfg;
+
+/*
+** Defines structure for configuring FSK generation
+*/
+typedef ProSLIC_FSK_Cfg Si3226x_FSK_Cfg;
+
+
+/*
+** Defines structure for configuring impedance synthesis
+*/
+typedef struct
+{
+  ramData zsynth_b0;
+  ramData zsynth_b1;
+  ramData zsynth_b2;
+  ramData zsynth_a1;
+  ramData zsynth_a2;
+  uInt8 ra;
+} Si3226x_Zsynth_Cfg;
+
+/*
+** Defines structure for configuring hybrid
+*/
+typedef struct
+{
+  ramData ecfir_c2;
+  ramData ecfir_c3;
+  ramData ecfir_c4;
+  ramData ecfir_c5;
+  ramData ecfir_c6;
+  ramData ecfir_c7;
+  ramData ecfir_c8;
+  ramData ecfir_c9;
+  ramData ecfir_b0;
+  ramData ecfir_b1;
+  ramData ecfir_a1;
+  ramData ecfir_a2;
+} Si3226x_hybrid_Cfg;
+
+/*
+** Defines structure for configuring GCI CI bits
+*/
+typedef struct
+{
+  uInt8 gci_ci;
+} Si3226x_CI_Cfg;
+
+/*
+** Defines structure for configuring audio eq
+*/
+
+typedef struct
+{
+  ramData txaceq_c0;
+  ramData txaceq_c1;
+  ramData txaceq_c2;
+  ramData txaceq_c3;
+
+  ramData rxaceq_c0;
+  ramData rxaceq_c1;
+  ramData rxaceq_c2;
+  ramData rxaceq_c3;
+} Si3226x_audioEQ_Cfg;
+
+
+
+/*
+** Defines structure for configuring audio gain
+*/
+
+typedef ProSLIC_audioGain_Cfg Si3226x_audioGain_Cfg;
+
+
+typedef struct
+{
+  Si3226x_audioEQ_Cfg audioEQ;
+  Si3226x_hybrid_Cfg hybrid;
+  Si3226x_Zsynth_Cfg zsynth;
+  ramData txgain;
+  ramData rxgain;
+  ramData rxachpf_b0_1;
+  ramData  rxachpf_b1_1;
+  ramData  rxachpf_a1_1;
+  int16 txgain_db; /*overall gain associated with this configuration*/
+  int16 rxgain_db;
+} Si3226x_Impedance_Cfg;
+
+
+
+/*
+** Defines structure for configuring tone generator
+*/
+typedef ProSLIC_Tone_Cfg Si3226x_Tone_Cfg;
+
+/*
+** Defines structure for configuring ring generator
+*/
+typedef struct
+{
+  ramData rtper;
+  ramData freq;
+  ramData amp;
+  ramData phas;
+  ramData offset;
+  ramData slope_ring;
+  ramData iring_lim;
+  ramData rtacth;
+  ramData rtdcth;
+  ramData rtacdb;
+  ramData rtdcdb;
+  ramData vov_ring_bat;
+  ramData vov_ring_gnd;
+  ramData vbatr_expect;
+  uInt8 talo;
+  uInt8 tahi;
+  uInt8 tilo;
+  uInt8 tihi;
+  ramData adap_ring_min_i;
+  ramData counter_iring_val;
+  ramData counter_vtr_val;
+  ramData ar_const28;
+  ramData ar_const32;
+  ramData ar_const38;
+  ramData ar_const46;
+  ramData rrd_delay;
+  ramData rrd_delay2;
+  ramData vbat_track_min_rng;
+  uInt8 ringcon;
+  uInt8 userstat;
+  ramData vcm_ring;
+  ramData vcm_ring_fixed;
+  ramData delta_vcm;
+  ramData dcdc_rngtype;
+  ramData vov_dcdc_slope;
+  ramData vov_dcdc_os;
+  ramData vov_ring_bat_max;
+} Si3226x_Ring_Cfg;
+
+#endif
+
Index: linux-5.4.171/sound/soc/codecs/si3218x/inc/si3226x_intf.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-5.4.171/sound/soc/codecs/si3218x/inc/si3226x_intf.h	2022-02-22 10:59:20.000000000 +0800
@@ -0,0 +1,457 @@
+/*
+** Copyright (c) 2007-2017 by Silicon Laboratories
+**
+** $Id: si3226x_intf.h 42313 2018-02-10 07:12:50Z oliu $
+**
+** Si3226x_Intf.h
+** Si3226x ProSLIC interface header file
+**
+** Author(s):
+** laj
+**
+** Distributed by:
+** Silicon Laboratories, Inc
+**
+** This file contains proprietary information.
+** No dissemination allowed without prior written permission from
+** Silicon Laboratories, Inc.
+**
+** File Description:
+** This is the header file for the ProSLIC driver.
+**
+**
+*/
+
+#ifndef SI3226X_INTF_H
+#define SI3226X_INTF_H
+#include "si3226x.h"
+
+/*
+**
+** Si3226x General Constants
+**
+*/
+#define SI3226X_REVA                0
+#define SI3226X_REVB                1
+#define SI3226X_REVC                3    /* This is revC bug - shows revD revision code */
+
+/*
+** Calibration Constants
+*/
+#define SI3226X_CAL_STD_CALR1               0xC0    /* FF */
+#define SI3226X_CAL_STD_CALR2               0x18    /* F8 */
+
+/* Timeouts in 10s of ms */
+#define SI3226X_TIMEOUT_DCDC_UP             200
+#define SI3226X_TIMEOUT_DCDC_DOWN           200
+
+/* The following macros are for backward compatibility */
+#define Si3226x_Cal(PCHAN,INTARG)            ProSLIC_UnsupportedFeatureNoArg((PCHAN),"Si3226x_Cal")
+#define Si3226x_CheckCIDBuffer               ProSLIC_CheckCIDBuffer
+#define Si3226x_DCFeedSetup(PCHAN,PRESET)    Si3226x_DCFeedSetupCfg((PCHAN),Si3226x_DCfeed_Presets,(PRESET))
+#define Si3226x_DisableCID                   ProSLIC_DisableCID
+#define Si3226x_DisableInterrupts            ProSLIC_DisableInterrupts
+#define Si3226x_DTMFReadDigit                ProSLIC_DTMFReadDigit
+#define Si3226x_EnableCID                    ProSLIC_EnableCID
+#define Si3226x_GetInterrupts                ProSLIC_GetInterrupts
+#define Si3226x_GetLBCalResult               ProSLIC_GetLBCalResult
+#define Si3226x_GetPLLFreeRunStatus          ProSLIC_GetPLLFreeRunStatus
+#define Si3226x_GPIOControl                  ProSLIC_GPIOControl
+#define Si3226x_Init(PCHAN,SZ)               Si3226x_Init_with_Options((PCHAN),(SZ),INIT_NO_OPT)
+#define Si3226x_LoadPatch                    ProSLIC_LoadPatch
+#define Si3226x_LoadPreviousLBCal            ProSLIC_LoadPreviousLBCal
+#define Si3226x_LoadPreviousLBCalPacked      ProSLIC_LoadPreviousLBCalPacked
+#define Si3226x_LoadRegTables                ProSLIC_LoadRegTables
+#define Si3226x_ModemDetSetup(PCHAN,PRESET)  ProSLIC_UnsupportedFeatureNoArg((PCHAN),"Si3226x_ModemDetSetup")
+#define Si3226x_ModifyCIDStartBits           ProSLIC_ModifyCIDStartBits
+#define Si3226x_PCMStart                     ProSLIC_PCMStart
+#define Si3226x_PCMStop                      ProSLIC_PCMStop
+#define Si3226x_PCMTimeSlotSetup             ProSLIC_PCMTimeSlotSetup
+#define Si3226x_PLLFreeRunStart              ProSLIC_PLLFreeRunStart
+#define Si3226x_PLLFreeRunStop               ProSLIC_PLLFreeRunStop
+#define Si3226x_PolRev                       ProSLIC_PolRev
+#define Si3226x_PringDebugRAM                ProSLIC_PrintDebugRAM
+#define Si3226x_PrintDebugData               ProSLIC_PrintDebugData
+#define Si3226x_PrintDebugReg                ProSLIC_PrintDebugReg
+#define Si3226x_PulseMeterDisable            ProSLIC_PulseMeterDisable
+#define Si3226x_PulseMeterEnable             ProSLIC_PulseMeterEnable
+#define Si3226x_PulseMeterStart              ProSLIC_PulseMeterStart
+#define Si3226x_PulseMeterStop               ProSLIC_PulseMeterDisable
+#define Si3226x_ReadHookStatus               ProSLIC_ReadHookStatus
+#define Si3226x_ReadRAM                      ProSLIC_ReadRAM
+#define Si3226x_ReadReg                      ProSLIC_ReadReg
+#define Si3226x_Reset                        SiVoice_Reset
+#define Si3226x_RingStart                    ProSLIC_RingStart
+#define Si3226x_RingStop                     ProSLIC_RingStop
+#define Si3226x_SendCID                      ProSLIC_SendCID
+#define Si3226x_SetLoopbackMode              ProSLIC_SetLoopbackMode
+#define Si3226x_SetMuteStatus                ProSLIC_SetMuteStatus
+#define Si3226x_SetPowersaveMode             ProSLIC_SetPowersaveMode
+#define Si3226x_SetProfile(PCHAN,PRESET)     ProSLIC_UnsupportedFeatureNoArg((PCHAN),"Si3226x_SetProfile")
+#define Si3226x_ToneGenStart                 ProSLIC_ToneGenStart
+#define Si3226x_ToneGenStop                  ProSLIC_ToneGenStop
+#define Si3226x_VerifyPatch ProSLIC_VerifyPatch
+#define Si3226x_WriteRAM                     ProSLIC_WriteRAM
+#define Si3226x_WriteReg                     ProSLIC_WriteReg
+
+#define Si3226x_VerifyControlInterface       ProSLIC_VefifyControlInterface
+#define Si3226x_ShutdownChannel              ProSLIC_PowerDownConverter
+#define Si3226x_PowerDownConverter           ProSLIC_PowerDownConverter
+#define Si3226x_Calibrate                    ProSLIC_Calibrate
+#define Si3226x_ToneGenSetup                 ProSLIC_ToneGenSetup
+#define Si3226x_FSKSetup                     ProSLIC_FSKSetup
+#define Si3226x_SetLinefeedStatusBroadcast   ProSLIC_SetLinefeedStatusBroadcast
+#define Si3226x_SetLinefeedStatus            ProSLIC_SetLinefeedStatus
+#define Si3226x_MWIEnable                    ProSLIC_MWIEnable
+#define Si3226x_MWIDisable                   ProSLIC_MWIDisable
+#define Si3226x_SetMWIState                  ProSLIC_SetMWIState
+#define Si3226x_GetMWIState                  ProSLIC_GetMWIState
+#define Si3226x_MWISetup(PCHAN,VPK,LCR)      ProSLIC_MWISetV(PCHAN,VPK)
+
+/* DC Feed */
+#ifndef DISABLE_DCFEED_SETUP
+extern Si3226x_DCfeed_Cfg Si3226x_DCfeed_Presets[];
+#endif
+
+/*
+**
+** PROSLIC INITIALIZATION FUNCTIONS
+**
+*/
+
+/*
+** Function: PROSLIC_ShutdownChannel
+**
+** Description:
+** Safely shutdown channel w/o interruption to
+** other active channels
+**
+** Input Parameters:
+** pProslic: pointer to PROSLIC object
+**
+** Return:
+** none
+*/
+int Si3226x_ShutdownChannel (proslicChanType_ptr hProslic);
+
+/*
+** Function: PROSLIC_Init_MultiBOM
+**
+** Description:
+** Initializes the ProSLIC w/ selected general parameters
+**
+** Input Parameters:
+** pProslic: pointer to PROSLIC object
+** size:     number of channels
+** preset:   general configuration preset
+**
+** Return:
+** none
+*/
+int Si3226x_Init_MultiBOM (proslicChanType_ptr *hProslic,int size,int preset);
+
+/*
+** Function: Si3226x_Init_with_Options
+**
+** Description:
+** Initializes the ProSLIC with an option.
+**
+** Input Parameters:
+** pProslic: pointer to PROSLIC object
+** size - number of continuous channels to initialize
+** init_opt - which initialization type to do.
+**
+** Return:
+** none
+*/
+int Si3226x_Init_with_Options (proslicChanType_ptr *pProslic, int size,
+                               initOptionsType init_opt);
+
+/*
+** Function: Si3226x_PowerUpConverter
+**
+** Description:
+** Powers all DC/DC converters sequentially with delay to minimize
+** peak power draw on VDC.
+**
+** Returns:
+** int (error)
+**
+*/
+int Si3226x_PowerUpConverter(proslicChanType_ptr hProslic);
+
+/*
+** Function: PROSLIC_EnableInterrupts
+**
+** Description:
+** Enables interrupts
+**
+** Input Parameters:
+** hProslic: pointer to Proslic object
+**
+** Return:
+**
+*/
+int Si3226x_EnableInterrupts (proslicChanType_ptr hProslic);
+
+/*
+**
+** PROSLIC CONFIGURATION FUNCTIONS
+**
+*/
+
+/*
+** Function: PROSLIC_RingSetup
+**
+** Description:
+** configure ringing
+**
+** Input Parameters:
+** pProslic: pointer to Proslic object
+** pRingSetup: pointer to ringing config structure
+**
+** Return:
+** none
+*/
+int Si3226x_RingSetup (proslicChanType *pProslic, int preset);
+
+/*
+** Function: PROSLIC_ZsynthSetup
+**
+** Description:
+** configure impedance synthesis
+**
+** Input Parameters:
+** pProslic: pointer to Proslic object
+** pZynth: pointer to zsynth config structure
+**
+** Return:
+** none
+*/
+int Si3226x_ZsynthSetup (proslicChanType *pProslic, int preset);
+
+/*
+** Function: PROSLIC_GciCISetup
+**
+** Description:
+** configure CI bits (GCI mode)
+**
+** Input Parameters:
+** pProslic: pointer to Proslic object
+** pCI: pointer to ringing config structure
+**
+** Return:
+** none
+*/
+int Si3226x_GciCISetup (proslicChanType *pProslic, int preset);
+
+/*
+** Function: PROSLIC_AudioGainSetup
+**
+** Description:
+** configure audio gains
+**
+** Input Parameters:
+** pProslic: pointer to Proslic object
+** pAudio: pointer to audio gains config structure
+**
+** Return:
+** none
+*/
+int Si3226x_TXAudioGainSetup (proslicChanType *pProslic, int preset);
+int Si3226x_RXAudioGainSetup (proslicChanType *pProslic, int preset);
+#define Si3226x_AudioGainSetup ProSLIC_AudioGainSetup
+int Si3226x_TXAudioGainScale (proslicChanType *pProslic, int preset,
+                              uInt32 pga_scale, uInt32 eq_scale);
+int Si3226x_RXAudioGainScale (proslicChanType *pProslic, int preset,
+                              uInt32 pga_scale, uInt32 eq_scale);
+
+/*
+** Function: PROSLIC_DCFeedSetup
+**
+** Description:
+** configure dc feed
+**
+** Input Parameters:
+** pProslic: pointer to Proslic object
+** pDcFeed: pointer to dc feed config structure
+**
+** Return:
+** none
+*/
+int Si3226x_DCFeedSetupCfg (proslicChanType *pProslic,ProSLIC_DCfeed_Cfg *cfg,
+                            int preset);
+
+/*
+** Function: PROSLIC_GPIOSetup
+**
+** Description:
+** configure gpio
+**
+** Input Parameters:
+** pProslic: pointer to Proslic object
+** pGpio: pointer to gpio config structure
+**
+** Return:
+** none
+*/
+int Si3226x_GPIOSetup (proslicChanType *pProslic);
+
+/*
+** Function: PROSLIC_PCMSetup
+**
+** Description:
+** configure pcm
+**
+** Input Parameters:
+** pProslic: pointer to Proslic object
+** pPcm: pointer to pcm config structure
+**
+** Return:
+** none
+*/
+int Si3226x_PCMSetup (proslicChanType *pProslic, int preset);
+
+/*
+**
+** PROSLIC CONTROL FUNCTIONS
+**
+*/
+
+/*
+** Function: PROSLIC_PulseMeterSetup
+**
+** Description:
+** configure pulse metering
+**
+** Input Parameters:
+** pProslic: pointer to Proslic object
+** pPulseCfg: pointer to pulse metering config structure
+**
+** Return:
+** none
+*/
+int Si3226x_PulseMeterSetup (proslicChanType *pProslic, int preset);
+
+/*
+** Function: PROSLIC_dbgSetDCFeed
+**
+** Description:
+** provisionary function for setting up
+** dcfeed given desired open circuit voltage
+** and loop current.
+*/
+int Si3226x_dbgSetDCFeed (proslicChanType *pProslic, uInt32 v_vlim_val,
+                          uInt32 i_ilim_val, int32 preset);
+
+/*
+** Function: PROSLIC_dbgSetDCFeedVopen
+**
+** Description:
+** provisionary function for setting up
+** dcfeed given desired open circuit voltage
+** and loop current.
+*/
+int Si3226x_dbgSetDCFeedVopen (proslicChanType *pProslic, uInt32 v_vlim_val,
+                               int32 preset);
+
+
+/*
+** Function: PROSLIC_dbgSetDCFeedIloop
+**
+** Description:
+** provisionary function for setting up
+** dcfeed given desired open circuit voltage
+** and loop current.
+*/
+int Si3226x_dbgSetDCFeedIloop (proslicChanType *pProslic, uInt32 i_ilim_val,
+                               int32 preset);
+
+
+/*
+** Function: PROSLIC_dbgRingingSetup
+**
+** Description:
+** Provisionary function for setting up
+** Ring type, frequency, amplitude and dc offset.
+** Main use will be by peek/poke applications.
+*/
+int Si3226x_dbgSetRinging (proslicChanType *pProslic,
+                           ProSLIC_dbgRingCfg *ringCfg, int preset);
+
+/*
+** Function: PROSLIC_dbgSetRXGain
+**
+** Description:
+** Provisionary function for setting up
+** RX path gain.
+*/
+int Si3226x_dbgSetRXGain (proslicChanType *pProslic, int32 gain,
+                          int impedance_preset, int audio_gain_preset);
+
+/*
+** Function: PROSLIC_dbgSetTXGain
+**
+** Description:
+** Provisionary function for setting up
+** TX path gain.
+*/
+int Si3226x_dbgSetTXGain (proslicChanType *pProslic, int32 gain,
+                          int impedance_preset, int audio_gain_preset);
+
+
+/*
+** Function: PROSLIC_LineMonitor
+**
+** Description:
+** Monitor line voltages and currents
+*/
+int Si3226x_LineMonitor(proslicChanType *pProslic, proslicMonitorType *monitor);
+
+
+/*
+** Function: PROSLIC_PSTNCheck
+**
+** Description:
+** Continuous monitor of ilong to detect hot pstn line
+*/
+int Si3226x_PSTNCheck(proslicChanType *pProslic,
+                      proslicPSTNCheckObjType *pstnCheckObj);
+
+/*
+** Function: PROSLIC_DiffPSTNCheck
+**
+** Description:
+** Detection of foreign PSTN
+*/
+int Si3226x_DiffPSTNCheck (proslicChanType *pProslic,
+                           proslicDiffPSTNCheckObjType *pPSTNCheck);
+
+/*
+** Function: PROSLIC_SetPowersaveMode
+**
+** Description:
+** Enable or Disable powersave mode
+*/
+int Si3226x_SetPowersaveMode(proslicChanType *pProslic, int pwrsave);
+
+/*
+** Function: PROSLIC_ReadMADCScaled
+**
+** Description:
+** ReadMADC (or other sensed voltage/currents) and
+** return scaled value in int32 format
+*/
+int32 Si3226x_ReadMADCScaled(proslicChanType *pProslic, uInt16 addr,
+                             int32 scale);
+
+/* 
+** Function: Si3226x_GetChipInfo
+** Description: Returns the specific chipset in the Si3226x family.
+** Input parameters: channel pointer
+** output: either RC_SPI_FAIL or RC_NONE.  channel pointer deviceId will be updated.
+**/
+int Si3226x_GetChipInfo(proslicChanType_ptr pProslic);
+
+#endif
+
Index: linux-5.4.171/sound/soc/codecs/si3218x/inc/si3226x_registers.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-5.4.171/sound/soc/codecs/si3218x/inc/si3226x_registers.h	2022-02-22 10:59:20.000000000 +0800
@@ -0,0 +1,1263 @@
+/*
+** Copyright (c) 2007-2016 by Silicon Laboratories
+**
+** $Id: si3226x_registers.h 42313 2018-02-10 07:12:50Z oliu $
+**
+** Si3226_Registers.h
+**
+** Author(s):
+** laj
+**
+** Distributed by:
+** Silicon Laboratories, Inc
+**
+** This file contains proprietary information.
+** No dissemination allowed without prior written permission from
+** Silicon Laboratories, Inc.
+**
+** File Description:
+** This is the header file that contains
+** register and RAM names definitions for
+** the Si3226x ProSLIC.
+**
+**
+**
+*/
+
+#ifndef SI3226REGS_H
+#define SI3226REGS_H
+
+/*
+** This defines the mnemonics for the SI3226 registers
+*/
+enum REGISTERS
+{
+  ID  =  0,
+  RESET  =  1,
+  MSTREN  =  2,
+  MSTRSTAT  =  3,
+  RAMSTAT  =  4,
+  RAM_ADDR_HI  =  5,
+  RAM_DATA_B0  =  6,
+  RAM_DATA_B1  =  7,
+  RAM_DATA_B2  =  8,
+  RAM_DATA_B3  =  9,
+  RAM_ADDR_LO  =  10,
+  PCMMODE  =  11,
+  PCMTXLO  =  12,
+  PCMTXHI  =  13,
+  PCMRXLO  =  14,
+  PCMRXHI  =  15,
+  IRQ  =  16,
+  IRQ0  =  17,
+  IRQ1  =  18,
+  IRQ2  =  19,
+  IRQ3  =  20,
+  IRQ4  =  21,
+  IRQEN1  =  22,
+  IRQEN2  =  23,
+  IRQEN3  =  24,
+  IRQEN4  =  25,
+  CALR0  =  26,
+  CALR1  =  27,
+  CALR2  =  28,
+  CALR3  =  29,
+  LINEFEED  =  30,
+  POLREV  =  31,
+  SPEEDUP_DIS  =  32,
+  SPEEDUP  =  33,
+  LCRRTP  =  34,
+  OFFLOAD  =  35,
+  BATSELMAP  =  36,
+  BATSEL  =  37,
+  RINGCON  =  38,
+  RINGTALO  =  39,
+  RINGTAHI  =  40,
+  RINGTILO  =  41,
+  RINGTIHI  =  42,
+  LOOPBACK  =  43,
+  DIGCON  =  44,
+  RA  =  45,
+  ZCAL_EN  =  46,
+  ENHANCE  =  47,
+  OMODE  =  48,
+  OCON  =  49,
+  O1TALO  =  50,
+  O1TAHI  =  51,
+  O1TILO  =  52,
+  O1TIHI  =  53,
+  O2TALO  =  54,
+  O2TAHI  =  55,
+  O2TILO  =  56,
+  O2TIHI  =  57,
+  FSKDAT  =  58,
+  FSKDEPTH  =  59,
+  TONDTMF  =  60,
+  TONDET  =  61,
+  TONEN  =  62,
+  GCI_CI  =  63,
+  GLOBSTAT1  =  64,
+  GLOBSTAT2  =  65,
+  USERSTAT  =  66,
+  GPIO  =  67,
+  GPIO_CFG1  =  68,
+  GPIO_CFG2  =  69,
+  GPIO_CFG3  =  70,
+  DIAG1  =  71,
+  DIAG2  =  72,
+  CM_CLAMP  =  73,
+  DIAG3  =  74,
+  PMCON  =  75,
+  PCLK_FAULT_CNTL  =  76,
+  REG77  =  77,
+  REG78  =  78,
+  REG79  =  79,
+  AUTO  =  80,
+  JMPEN  =  81,
+  JMP0LO  =  82,
+  JMP0HI  =  83,
+  JMP1LO  =  84,
+  JMP1HI  =  85,
+  JMP2LO  =  86,
+  JMP2HI  =  87,
+  JMP3LO  =  88,
+  JMP3HI  =  89,
+  JMP4LO  =  90,
+  JMP4HI  =  91,
+  JMP5LO  =  92,
+  JMP5HI  =  93,
+  JMP6LO  =  94,
+  JMP6HI  =  95,
+  JMP7LO  =  96,
+  JMP7HI  =  97,
+  PDN  =  98,
+  PDN_STAT  =  99,
+  USERMODE_ENABLE = 126
+};
+
+
+/*
+** This defines the mnemonics for the SI3226x RAM locations (revB)
+*/
+enum SRAM
+{
+  IRNGNG_SENSE  =  0,
+  MADC_VTIPC  =  1,
+  MADC_VRINGC  =  2,
+  MADC_VBAT  =  3,
+  MADC_VLONG  =  4,
+  UNUSED5  =  5,
+  MADC_VDC  =  6,
+  MADC_ILONG  =  7,
+  MADC_ITIP  =  8,
+  MADC_IRING  =  9,
+  MADC_ILOOP  =  10,
+  VDIFF_SENSE  =  11,
+  VTIP  =  12,
+  VRING  =  13,
+  P_Q1_D  =  14,
+  P_Q2_D  =  15,
+  P_Q3_D  =  16,
+  P_Q4_D  =  17,
+  P_Q5_D  =  18,
+  P_Q6_D  =  19,
+  P_Q1  =  20,
+  DIAG_EX1  =  21,
+  DIAG_EX2  =  22,
+  DIAG_LPF_MADC  =  23,
+  DIAG_DMM_I  =  24,
+  DIAG_DMM_V  =  25,
+  OSC1FREQ  =  26,
+  OSC1AMP  =  27,
+  OSC1PHAS  =  28,
+  OSC2FREQ  =  29,
+  OSC2AMP  =  30,
+  OSC2PHAS  =  31,
+  TESTB0_1  =  32,
+  TESTB1_1  =  33,
+  TESTB2_1  =  34,
+  TESTA1_1  =  35,
+  TESTA2_1  =  36,
+  TESTB0_2  =  37,
+  TESTB1_2  =  38,
+  TESTB2_2  =  39,
+  TESTA1_2  =  40,
+  TESTA2_2  =  41,
+  TESTB0_3  =  42,
+  TESTB1_3  =  43,
+  TESTB2_3  =  44,
+  TESTA1_3  =  45,
+  TESTA2_3  =  46,
+  TESTPKO  =  47,
+  TESTAVO  =  48,
+  TESTWLN  =  49,
+  TESTAVBW  =  50,
+  TESTPKFL  =  51,
+  TESTAVFL  =  52,
+  TESTPKTH  =  53,
+  TESTAVTH  =  54,
+  DAC_IN_SYNC1  =  55,
+  BYPASS_REG  =  56,
+  LCRMASK_CNT  =  57,
+  DAC_IN_SYNC  =  58,
+  TEMP  =  59,
+  TEMP_ISR  =  60,
+  P_Q2  =  61,
+  P_Q3  =  62,
+  P_Q4  =  63,
+  P_Q5  =  64,
+  P_Q6  =  65,
+  ILOOP_FILT  =  66,
+  ILONG_FILT  =  67,
+  VBAT_FILT  =  68,
+  VDIFF_FILT  =  69,
+  VCM_FILT  =  70,
+  VBAT_CNT  =  71,
+  V_VLIM_SCALED  =  72,
+  V_VLIM_TRACK  =  73,
+  V_VLIM_MODFEED  =  74,
+  DIAG_P_OUT  =  75,
+  DIAG_COUNT  =  76,
+  ROW0_MAG  =  77,
+  ROW1_MAG  =  78,
+  ROW2_MAG  =  79,
+  ROW3_MAG  =  80,
+  COL0_MAG  =  81,
+  COL1_MAG  =  82,
+  COL2_MAG  =  83,
+  COL3_MAG  =  84,
+  ROW0_2ND_Y1  =  85,
+  ROW1_2ND_Y1  =  86,
+  ROW2_2ND_Y1  =  87,
+  ROW3_2ND_Y1  =  88,
+  COL0_2ND_Y1  =  89,
+  COL1_2ND_Y1  =  90,
+  COL2_2ND_Y1  =  91,
+  COL3_2ND_Y1  =  92,
+  ROW0_2ND_Y2  =  93,
+  ROW1_2ND_Y2  =  94,
+  ROW2_2ND_Y2  =  95,
+  ROW3_2ND_Y2  =  96,
+  COL0_2ND_Y2  =  97,
+  COL1_2ND_Y2  =  98,
+  COL2_2ND_Y2  =  99,
+  COL3_2ND_Y2  =  100,
+  DTMF_IN  =  101,
+  DTMFDTF_D2_1  =  102,
+  DTMFDTF_D1_1  =  103,
+  DTMFDTF_OUT_1  =  104,
+  DTMFDTF_D2_2  =  105,
+  DTMFDTF_D1_2  =  106,
+  DTMFDTF_OUT_2  =  107,
+  DTMFDTF_D2_3  =  108,
+  DTMFDTF_D1_3  =  109,
+  DTMFDTF_OUT_3  =  110,
+  DTMFDTF_OUT  =  111,
+  DTMFLPF_D2_1  =  112,
+  DTMFLPF_D1_1  =  113,
+  DTMFLPF_OUT_1  =  114,
+  DTMFLPF_D2_2  =  115,
+  DTMFLPF_D1_2  =  116,
+  DTMFLPF_OUT_2  =  117,
+  DTMF_ROW  =  118,
+  DTMFHPF_D2_1  =  119,
+  DTMFHPF_D1_1  =  120,
+  DTMFHPF_OUT_1  =  121,
+  DTMFHPF_D2_2  =  122,
+  DTMFHPF_D1_2  =  123,
+  DTMFHPF_OUT_2  =  124,
+  DTMF_COL  =  125,
+  ROW_POWER  =  126,
+  COL_POWER  =  127,
+  GP_TIMER  =  128,
+  SPR_INTERP_DIF  =  129,
+  SPR_INTERP_DIF_OUT  =  130,
+  SPR_INTERP_INT  =  131,
+  SPR_CNT  =  132,
+  ROW0_Y1  =  133,
+  ROW0_Y2  =  134,
+  ROW1_Y1  =  135,
+  ROW1_Y2  =  136,
+  ROW2_Y1  =  137,
+  ROW2_Y2  =  138,
+  ROW3_Y1  =  139,
+  ROW3_Y2  =  140,
+  COL0_Y1  =  141,
+  COL0_Y2  =  142,
+  COL1_Y1  =  143,
+  COL1_Y2  =  144,
+  COL2_Y1  =  145,
+  COL2_Y2  =  146,
+  COL3_Y1  =  147,
+  COL3_Y2  =  148,
+  ROWMAX_MAG  =  149,
+  COLMAX_MAG  =  150,
+  ROW0_2ND_MAG  =  151,
+  COL0_2ND_MAG  =  152,
+  ROW_THR  =  153,
+  COL_THR  =  154,
+  OSC1_Y  =  155,
+  OSC2_Y  =  156,
+  OSC1_X  =  157,
+  OSC1_COEFF  =  158,
+  OSC2_X  =  159,
+  OSC2_COEFF  =  160,
+  RXACIIR_D2_1  =  161,
+  RXACIIR_OUT_1  =  162,
+  RXACIIR_D2_2  =  163,
+  RXACIIR_D1_2  =  164,
+  RXACIIR_OUT_2  =  165,
+  RXACIIR_D2_3  =  166,
+  RXACIIR_D1_3  =  167,
+  RXACIIR_OUT  =  168,
+  RXACIIR_OUT_3  =  169,
+  TXACCOMB_D1  =  170,
+  TXACCOMB_D2  =  171,
+  TXACCOMB_D3  =  172,
+  TXACSINC_OUT  =  173,
+  TXACHPF_D1_2  =  174,
+  TXACHPF_D2_1  =  175,
+  TXACHPF_D2_2  =  176,
+  TXACHPF_OUT  =  177,
+  TXACHPF_OUT_1  =  178,
+  TXACHPF_OUT_2  =  179,
+  TXACIIR_D2_1  =  180,
+  TXACIIR_OUT_1  =  181,
+  TXACIIR_D2_2  =  182,
+  TXACIIR_D1_2  =  183,
+  TXACIIR_OUT_2  =  184,
+  TXACIIR_D2_3  =  185,
+  TXACIIR_D1_3  =  186,
+  TXACIIR_OUT_3  =  187,
+  TXACIIR_OUT  =  188,
+  ECIIR_D1  =  189,
+  ECIIR_D2  =  190,
+  EC_DELAY1  =  191,
+  EC_DELAY2  =  192,
+  EC_DELAY3  =  193,
+  EC_DELAY4  =  194,
+  EC_DELAY5  =  195,
+  EC_DELAY6  =  196,
+  EC_DELAY7  =  197,
+  EC_DELAY8  =  198,
+  EC_DELAY9  =  199,
+  EC_DELAY10  =  200,
+  EC_DELAY11  =  201,
+  ECHO_EST  =  202,
+  EC_OUT  =  203,
+  TESTFILT_OUT_1  =  204,
+  TESTFILT_D1_1  =  205,
+  TESTFILT_D2_1  =  206,
+  TESTFILT_OUT_2  =  207,
+  TESTFILT_D1_2  =  208,
+  TESTFILT_D2_2  =  209,
+  TESTFILT_OUT_3  =  210,
+  TESTFILT_D1_3  =  211,
+  TESTFILT_D2_3  =  212,
+  TESTFILT_PEAK  =  213,
+  TESTFILT_ABS  =  214,
+  TESTFILT_MEANACC  =  215,
+  TESTFILT_COUNT  =  216,
+  TESTFILT_NO_OFFSET  =  217,
+  RING_X  =  218,
+  RING_Y  =  219,
+  RING_INT  =  220,
+  RING_Y_D1  =  221,
+  RING_DIFF  =  222,
+  RING_DELTA  =  223,
+  WTCHDOG_CNT  =  224,
+  RING_WAVE  =  225,
+  UNUSED226  =  226,
+  ONEKHZ_COUNT  =  227,
+  TX2100_Y1  =  228,
+  TX2100_Y2  =  229,
+  TX2100_MAG  =  230,
+  RX2100_Y1  =  231,
+  RX2100_Y2  =  232,
+  RX2100_MAG  =  233,
+  TX2100_POWER  =  234,
+  RX2100_POWER  =  235,
+  TX2100_IN  =  236,
+  RX2100_IN  =  237,
+  RINGTRIP_COUNT  =  238,
+  RINGTRIP_DC1  =  239,
+  RINGTRIP_DC2  =  240,
+  RINGTRIP_AC1  =  241,
+  RINGTRIP_AC2  =  242,
+  RINGTRIP_AC_COUNT  =  243,
+  RINGTRIP_DC_COUNT  =  244,
+  RINGTRIP_AC_RESULT  =  245,
+  RINGTRIP_DC_RESULT  =  246,
+  RINGTRIP_ABS  =  247,
+  TXACEQ_OUT  =  248,
+  LCR_DBI_CNT  =  249,
+  BAT_DBI_CNT  =  250,
+  LONG_DBI_CNT  =  251,
+  TXACEQ_DELAY3  =  252,
+  TXACEQ_DELAY2  =  253,
+  TXACEQ_DELAY1  =  254,
+  RXACEQ_DELAY3  =  255,
+  RXACEQ_DELAY2  =  256,
+  RXACEQ_DELAY1  =  257,
+  RXACEQ_IN  =  258,
+  TXDCCOMB_D1  =  259,
+  TXDCCOMB_D2  =  260,
+  TXDCSINC_OUT  =  261,
+  RXACDIFF_D1  =  262,
+  DC_NOTCH_1  =  263,
+  DC_NOTCH_2  =  264,
+  DC_NOTCH_OUT  =  265,
+  DC_NOTCH_SCALED  =  266,
+  V_FEED_IN  =  267,
+  I_TAR  =  268,
+  CONST_VLIM  =  269,
+  UNITY  =  270,
+  TXACNOTCH_1  =  271,
+  TXACNOTCH_2  =  272,
+  TXACNOTCH_OUT  =  273,
+  ZSYNTH_1  =  274,
+  ZSYNTH_2  =  275,
+  ZSYNTH_OUT_1  =  276,
+  TXACD2_1_0  =  277,
+  TXACD2_1_1  =  278,
+  TXACD2_1_2  =  279,
+  TXACD2_1_3  =  280,
+  TXACD2_1_4  =  281,
+  TXACD2_1_5  =  282,
+  TXACD2_1_OUT  =  283,
+  TXACD2_2_0  =  284,
+  TXACD2_2_1  =  285,
+  TXACD2_2_2  =  286,
+  TXACD2_2_3  =  287,
+  TXACD2_2_4  =  288,
+  TXACD2_2_5  =  289,
+  TXACD2_2_OUT  =  290,
+  TXACD2_3_0  =  291,
+  TXACD2_3_1  =  292,
+  TXACD2_3_2  =  293,
+  TXACD2_3_3  =  294,
+  TXACD2_3_4  =  295,
+  TXACD2_3_5  =  296,
+  TXACD2_3_OUT  =  297,
+  RXACI2_1_1  =  298,
+  RXACI2_1_2  =  299,
+  RXACI2_1_3  =  300,
+  RXACI2_1_4  =  301,
+  RXACI2_1_OUT  =  302,
+  RXACI2_2_1  =  303,
+  RXACI2_2_2  =  304,
+  RXACI2_2_3  =  305,
+  RXACI2_2_4  =  306,
+  RXACI2_2_OUT  =  307,
+  RXACI2_3_1  =  308,
+  RXACI2_3_2  =  309,
+  RXACI2_3_3  =  310,
+  RXACI2_3_4  =  311,
+  RXACI2_3_OUT  =  312,
+  TXACCOMP1  =  313,
+  TXACCOMP_OUT  =  314,
+  RXACCOMP1  =  315,
+  RXACCOMP_OUT  =  316,
+  RXACHPF_D1_2  =  317,
+  RXACHPF_D2_1  =  318,
+  RXACHPF_D2_2  =  319,
+  RXACHPF_OUT  =  320,
+  RXACHPF_OUT_1  =  321,
+  RXACHPF_OUT_2  =  322,
+  RXACEQ_OUT  =  323,
+  METER_I_1  =  324,
+  METER_I_OUT  =  325,
+  METER_LPF_1  =  326,
+  METER_LPF_2  =  327,
+  METER_LPF_OUT_1  =  328,
+  METER_BP_1  =  329,
+  METER_BP_2  =  330,
+  METER_BP_OUT  =  331,
+  METER_SRC_OUT  =  332,
+  UNUSED333  =  333,
+  UNUSED334  =  334,
+  RING_LPF_1  =  335,
+  RING_LPF_2  =  336,
+  RING_LPF_OUT  =  337,
+  RING_INTERP_DIFF  =  338,
+  RING_INTERP_DIFF_OUT  =  339,
+  RING_INTERP_INT  =  340,
+  RING_INTERP_INT_OUT  =  341,
+  V_ILIM_TRACK  =  342,
+  V_RFEED_TRACK  =  343,
+  LF_SPEEDUP_CNT  =  344,
+  DC_SPEEDUP_CNT  =  345,
+  AC_SPEEDUP_CNT  =  346,
+  LCR_SPEEDUP_CNT  =  347,
+  CM_SPEEDUP_CNT  =  348,
+  DC_SPEEDUP_MASK  =  349,
+  ZSYNTH_IN  =  350,
+  I_TAR_SAVE  =  351,
+  UNUSED352  =  352,
+  UNUSED353  =  353,
+  COUNTER_VTR  =  354,
+  I_RING_AVG  =  355,
+  COUNTER_IRING  =  356,
+  COMP_RATIO  =  357,
+  MADC_VBAT_DIV2  =  358,
+  VDIFF_PK_T  =  359,
+  PEAK_CNT  =  360,
+  CM_DBI_CNT  =  361,
+  VCM_LAST  =  362,
+  VBATL_SENSE  =  363,
+  VBATH_SENSE  =  364,
+  VBATR_SENSE  =  365,
+  BAT_SETTLE_CNT  =  366,
+  VBAT_TGT  =  367,
+  VBAT_REQ  =  368,
+  VCM_HIRES  =  369,
+  VCM_LORES  =  370,
+  ILOOP1  =  371,
+  ILONG2  =  372,
+  ITIP1  =  373,
+  IRING1  =  374,
+  CAL_TEMP1  =  375,
+  CAL_TEMP2  =  376,
+  CAL_TEMP3  =  377,
+  CAL_TEMP4  =  378,
+  CAL_TEMP5  =  379,
+  CAL_TEMP6  =  380,
+  CAL_TEMP7  =  381,
+  CMRR_DIVISOR  =  382,
+  CMRR_REMAINDER  =  383,
+  CMRR_Q_PTR  =  384,
+  I_SOURCE1  =  385,
+  I_SOURCE2  =  386,
+  VTR1  =  387,
+  VTR2 =  388,
+  STOP_TIMER1  =  389,
+  STOP_TIMER2  =  390,
+  UNUSED391  =  391,
+  UNUSED392  =  392,
+  CAL_ONHK_Z  =  393,
+  CAL_LB_SETTLE  =  394,
+  CAL_DECLPF_V0  =  395,
+  CAL_DECLPF_V1  =  396,
+  CAL_DECLPF_V2  =  397,
+  CAL_GOERTZEL_V0  =  398,
+  CAL_GOERTZEL_V1  =  399,
+  CAL_DECLPF_Y  =  400,
+  CAL_GOERTZEL_Y  =  401,
+  P_HVIC  =  402,
+  VBATL_MIRROR  =  403,
+  VBATH_MIRROR  =  404,
+  VBATR_MIRROR  =  405,
+  DIAG_EX1_OUT  =  406,
+  DIAG_EX2_OUT  =  407,
+  DIAG_DMM_V_OUT  =  408,
+  DIAG_DMM_I_OUT  =  409,
+  DIAG_P  =  410,
+  DIAG_LPF_V  =  411,
+  DIAG_LPF_I  =  412,
+  DIAG_TONE_FLAG  =  413,
+  ILOOP1_LAST  =  414,
+  RING_ENTRY_VOC  =  415,
+  UNUSED416  =  416,
+  OSC1_X_SAVE  =  417,
+  EZSYNTH_1  =  418,
+  EZSYNTH_2  =  419,
+  ZSYNTH_OUT  =  420,
+  UNUSED421  =  421,
+  CAL_SUBSTATE  =  422,
+  DIAG_EX1_DC_OUT  =  423,
+  DIAG_EX1_DC  =  424,
+  EZSYNTH_B1  =  425,
+  EZSYNTH_B2  =  426,
+  EZSYNTH_A1  =  427,
+  EZSYNTH_A2  =  428,
+  ILOOP1_FILT  =  429,
+  AC_PU_DELTA1_CNT  =  430,
+  AC_PU_DELTA2_CNT  =  431,
+  UNUSED432  =  432,
+  UNUSED433  =  433,
+  UNUSED434  =  434,
+  AC_DAC_GAIN_SAVE  =  435,
+  RING_FLUSH_CNT  =  436,
+  UNUSED437  =  437,
+  DIAG_VAR_OUT  =  438,
+  I_VBAT  =  439,
+  P_OFFLOAD  =  440,
+  CALTMP_LOOPCNT  =  441,
+  CALTMP_LOOPINC  =  442,
+  UNUSED443  =  443,
+  CALTMP_CODEINC  =  444,
+  CALTMP_TAUINC  =  445,
+  CALTMP_TAU  =  446,
+  CAL_TEMP8  =  447,
+  PATCH_ID  =  448,
+  UNUSED449  =  449,
+  UNUSED450  =  450,
+  UNUSED451  =  451,
+  CAL_LB_OFFSET_FWD  =  452,
+  CAL_LB_OFFSET_RVS  =  453,
+  COUNT_SPEEDUP  =  454,
+  SWEEP_COUNT  =  455,
+  AMP_RAMP  =  456,
+  DIAG_LPF_MADC_D  =  457,
+  DIAG_HPF_MADC  =  458,
+  UNUSED459  =  459,
+  TXDEC_OUT  =  460,
+  TXDEC_D1  =  461,
+  TXDEC_D2  =  462,
+  RXDEC_D1  =  463,
+  RXDEC_D2  =  464,
+  OSCINT1_D2_1  =  465,
+  OSCINT1_D1_1  =  466,
+  OSCINT1_OUT_1  =  467,
+  OSCINT1_D2_2  =  468,
+  OSCINT1_D1_2  =  469,
+  OSCINT1_OUT  =  470,
+  OSCINT2_D2_1  =  471,
+  OSCINT2_D1_1  =  472,
+  OSCINT2_OUT_1  =  473,
+  OSCINT2_D2_2  =  474,
+  OSCINT2_D1_2  =  475,
+  OSCINT2_OUT  =  476,
+  OSC1_Y_SAVE  =  477,
+  OSC2_Y_SAVE  =  478,
+  PWRSAVE_CNT  =  479,
+  VBATR_PK  =  480,
+  SPEEDUP_MASK_CNT  =  481,
+  VCM_RING_FIXED  =  482,
+  DELTA_VCM  =  483,
+  MADC_VTIPC_DIAG_OS  =  484,
+  MADC_VRINGC_DIAG_OS  =  485,
+  MADC_VLONG_DIAG_OS  =  486,
+  INIT_GUESS  =  487,
+  Y1  =  488,
+  Y2  =  489,
+  Y3  =  490,
+  UNUSED491  =  491,
+  PWRSAVE_DBI_CNT  =  492,
+  COMP_RATIO_SAVE  =  493,
+  CAL_TEMP9  =  494,
+  CAL_TEMP10  =  495,
+  DAC_OFFSET_TEMP =  496,
+  CAL_DAC_CODE  =  497,
+  DCDAC_OFFSET  =  498,
+  VDIFF_COARSE  =  499,
+  RXACIIR_OUT_4  =  500,
+  CAL_TEMP11  =  501,
+  METER_RAMP =  502,
+  METER_RAMP_DIR  =  503,
+  METER_ON_T  =  504,
+  METER_PK_DET  =  505,
+  METER_PK_DET_T =  506,
+  THERM_CNT  =  507,
+  VDIFF_SENSE_DELAY  =  508,
+  UNUSED509 =  509,
+  CPUMP_DEB_CNT  =  510,
+  UNUSED511  =  511,
+  MINUS_ONE  =  512,
+  ILOOPLPF  =  513,
+  ILONGLPF  =  514,
+  BATLPF  =  515,
+  VDIFFLPF  =  516,
+  VCMLPF  =  517,
+  TXACIIR_B0_1  =  518,
+  TXACIIR_B1_1  =  519,
+  TXACIIR_A1_1  =  520,
+  TXACIIR_B0_2  =  521,
+  TXACIIR_B1_2  =  522,
+  TXACIIR_B2_2  =  523,
+  TXACIIR_A1_2  =  524,
+  TXACIIR_A2_2  =  525,
+  TXACIIR_B0_3  =  526,
+  TXACIIR_B1_3  =  527,
+  TXACIIR_B2_3  =  528,
+  TXACIIR_A1_3  =  529,
+  TXACIIR_A2_3  =  530,
+  TXACHPF_B0_1  =  531,
+  TXACHPF_B1_1  =  532,
+  TXACHPF_A1_1  =  533,
+  TXACHPF_B0_2  =  534,
+  TXACHPF_B1_2  =  535,
+  TXACHPF_B2_2  =  536,
+  TXACHPF_A1_2  =  537,
+  TXACHPF_A2_2  =  538,
+  TXACHPF_GAIN  =  539,
+  TXACEQ_C0  =  540,
+  TXACEQ_C1  =  541,
+  TXACEQ_C2  =  542,
+  TXACEQ_C3  =  543,
+  TXACGAIN  =  544,
+  RXACGAIN  =  545,
+  RXACEQ_C0  =  546,
+  RXACEQ_C1  =  547,
+  RXACEQ_C2  =  548,
+  RXACEQ_C3  =  549,
+  RXACIIR_B0_1  =  550,
+  RXACIIR_B1_1  =  551,
+  RXACIIR_A1_1  =  552,
+  RXACIIR_B0_2  =  553,
+  RXACIIR_B1_2  =  554,
+  RXACIIR_B2_2  =  555,
+  RXACIIR_A1_2  =  556,
+  RXACIIR_A2_2  =  557,
+  RXACIIR_B0_3  =  558,
+  RXACIIR_B1_3  =  559,
+  RXACIIR_B2_3  =  560,
+  RXACIIR_A1_3  =  561,
+  RXACIIR_A2_3  =  562,
+  ECFIR_C2  =  563,
+  ECFIR_C3  =  564,
+  ECFIR_C4  =  565,
+  ECFIR_C5  =  566,
+  ECFIR_C6  =  567,
+  ECFIR_C7  =  568,
+  ECFIR_C8  =  569,
+  ECFIR_C9  =  570,
+  ECIIR_B0  =  571,
+  ECIIR_B1  =  572,
+  ECIIR_A1  =  573,
+  ECIIR_A2  =  574,
+  DTMFDTF_B0_1  =  575,
+  DTMFDTF_B1_1  =  576,
+  DTMFDTF_B2_1  =  577,
+  DTMFDTF_A1_1  =  578,
+  DTMFDTF_A2_1  =  579,
+  DTMFDTF_B0_2  =  580,
+  DTMFDTF_B1_2  =  581,
+  DTMFDTF_B2_2  =  582,
+  DTMFDTF_A1_2  =  583,
+  DTMFDTF_A2_2  =  584,
+  DTMFDTF_B0_3  =  585,
+  DTMFDTF_B1_3  =  586,
+  DTMFDTF_B2_3  =  587,
+  DTMFDTF_A1_3  =  588,
+  DTMFDTF_A2_3  =  589,
+  DTMFDTF_GAIN  =  590,
+  DTMFLPF_B0_1  =  591,
+  DTMFLPF_B1_1  =  592,
+  DTMFLPF_B2_1  =  593,
+  DTMFLPF_A1_1  =  594,
+  DTMFLPF_A2_1  =  595,
+  DTMFLPF_B0_2  =  596,
+  DTMFLPF_B1_2  =  597,
+  DTMFLPF_B2_2  =  598,
+  DTMFLPF_A1_2  =  599,
+  DTMFLPF_A2_2  =  600,
+  DTMFLPF_GAIN  =  601,
+  DTMFHPF_B0_1  =  602,
+  DTMFHPF_B1_1  =  603,
+  DTMFHPF_B2_1  =  604,
+  DTMFHPF_A1_1  =  605,
+  DTMFHPF_A2_1  =  606,
+  DTMFHPF_B0_2  =  607,
+  DTMFHPF_B1_2  =  608,
+  DTMFHPF_B2_2  =  609,
+  DTMFHPF_A1_2  =  610,
+  DTMFHPF_A2_2  =  611,
+  DTMFHPF_GAIN  =  612,
+  POWER_GAIN  =  613,
+  GOERTZEL_GAIN  =  614,
+  MODEM_GAIN  =  615,
+  HOTBIT1  =  616,
+  HOTBIT0  =  617,
+  ROW0_C1  =  618,
+  ROW1_C1  =  619,
+  ROW2_C1  =  620,
+  ROW3_C1  =  621,
+  COL0_C1  =  622,
+  COL1_C1  =  623,
+  COL2_C1  =  624,
+  COL3_C1  =  625,
+  ROW0_C2  =  626,
+  ROW1_C2  =  627,
+  ROW2_C2  =  628,
+  ROW3_C2  =  629,
+  COL0_C2  =  630,
+  COL1_C2  =  631,
+  COL2_C2  =  632,
+  COL3_C2  =  633,
+  SLOPE_VLIM  =  634,
+  SLOPE_RFEED  =  635,
+  SLOPE_ILIM  =  636,
+  SLOPE_RING  =  637,
+  SLOPE_DELTA1  =  638,
+  SLOPE_DELTA2  =  639,
+  V_VLIM  =  640,
+  V_RFEED  =  641,
+  V_ILIM  =  642,
+  CONST_RFEED  =  643,
+  CONST_ILIM  =  644,
+  I_VLIM  =  645,
+  DC_DAC_GAIN  =  646,
+  VDIFF_TH  =  647,
+  TXDEC_B0  =  648,
+  TXDEC_B1  =  649,
+  TXDEC_B2  =  650,
+  TXDEC_A1  =  651,
+  TXDEC_A2  =  652,
+  ZSYNTH_B0  =  653,
+  ZSYNTH_B1  =  654,
+  ZSYNTH_B2  =  655,
+  ZSYNTH_A1  =  656,
+  ZSYNTH_A2  =  657,
+  RXACHPF_B0_1  =  658,
+  RXACHPF_B1_1  =  659,
+  RXACHPF_A1_1  =  660,
+  RXACHPF_B0_2  =  661,
+  RXACHPF_B1_2  =  662,
+  RXACHPF_B2_2  =  663,
+  RXACHPF_A1_2  =  664,
+  RXACHPF_A2_2  =  665,
+  RXACHPF_GAIN  =  666,
+  MASK7LSB  =  667,
+  RXDEC_B0  =  668,
+  RXDEC_B1  =  669,
+  RXDEC_B2  =  670,
+  RXDEC_A1  =  671,
+  RXDEC_A2  =  672,
+  OSCINT1_B0_1  =  673,
+  OSCINT1_B1_1  =  674,
+  OSCINT1_B2_1  =  675,
+  OSCINT1_A1_1  =  676,
+  OSCINT1_A2_1  =  677,
+  OSCINT1_B0_2  =  678,
+  OSCINT1_B1_2  =  679,
+  OSCINT1_B2_2  =  680,
+  OSCINT1_A1_2  =  681,
+  OSCINT1_A2_2  =  682,
+  OSCINT2_B0_1  =  683,
+  OSCINT2_B1_1  =  684,
+  OSCINT2_B2_1  =  685,
+  OSCINT2_A1_1  =  686,
+  OSCINT2_A2_1  =  687,
+  OSCINT2_B0_2  =  688,
+  OSCINT2_B1_2  =  689,
+  OSCINT2_B2_2  =  690,
+  OSCINT2_A1_2  =  691,
+  OSCINT2_A2_2  =  692,
+  UNUSED693  =  693,
+  UNUSED694  =  694,
+  UNUSED695  =  695,
+  RING_LPF_B0  =  696,
+  RING_LPF_B1  =  697,
+  RING_LPF_B2  =  698,
+  RING_LPF_A1  =  699,
+  RING_LPF_A2  =  700,
+  LCRDBI  =  701,
+  LONGDBI  =  702,
+  VBAT_TIMER  =  703,
+  LF_SPEEDUP_TIMER  =  704,
+  DC_SPEEDUP_TIMER  =  705,
+  AC_SPEEDUP_TIMER  =  706,
+  LCR_SPEEDUP_TIMER  =  707,
+  CM_SPEEDUP_TIMER  =  708,
+  VCM_TH  =  709,
+  AC_SPEEDUP_TH  =  710,
+  SPR_SIG_0  =  711,
+  SPR_SIG_1  =  712,
+  SPR_SIG_2  =  713,
+  SPR_SIG_3  =  714,
+  SPR_SIG_4  =  715,
+  SPR_SIG_5  =  716,
+  SPR_SIG_6  =  717,
+  SPR_SIG_7  =  718,
+  SPR_SIG_8  =  719,
+  SPR_SIG_9  =  720,
+  SPR_SIG_10  =  721,
+  SPR_SIG_11  =  722,
+  SPR_SIG_12  =  723,
+  SPR_SIG_13  =  724,
+  SPR_SIG_14  =  725,
+  SPR_SIG_15  =  726,
+  SPR_SIG_16  =  727,
+  SPR_SIG_17  =  728,
+  SPR_SIG_18  =  729,
+  COUNTER_VTR_VAL  =  730,
+  CONST_028  =  731,
+  CONST_032  =  732,
+  CONST_038  =  733,
+  CONST_046  =  734,
+  COUNTER_IRING_VAL  =  735,
+  GAIN_RING  =  736,
+  RING_HYST  =  737,
+  COMP_Z  =  738,
+  CONST_115  =  739,
+  CONST_110  =  740,
+  CONST_105  =  741,
+  CONST_100  =  742,
+  CONST_095  =  743,
+  CONST_090  =  744,
+  CONST_085  =  745,
+  V_RASUM_IDEAL  =  746,
+  CONST_ONE  =  747,
+  VCM_OH  =  748,
+  VCM_RING  =  749,
+  VCM_HYST  =  750,
+  VOV_GND  =  751,
+  VOV_BAT  =  752,
+  VOV_RING_BAT  =  753,
+  CM_DBI  =  754,
+  RTPER  =  755,
+  P_TH_HVIC  =  756,
+  UNUSED757  =  757,
+  UNUSED758  =  758,
+  COEF_P_HVIC  =  759,
+  COEF_Q1256  =  760,
+  UNUSED761  =  761,
+  UNUSED762  =  762,
+  UNUSED763  =  763,
+  BAT_HYST  =  764,
+  BAT_DBI  =  765,
+  VBATL_EXPECT  =  766,
+  VBATH_EXPECT  =  767,
+  VBATR_EXPECT  =  768,
+  BAT_SETTLE  =  769,
+  VBAT_IRQ_TH  =  770,
+  MADC_VTIPC_OS  =  771,
+  MADC_VRINGC_OS  =  772,
+  MADC_VBAT_OS  =  773,
+  MADC_VLONG_OS  =  774,
+  UNUSED775  =  775,
+  MADC_VDC_OS  =  776,
+  MADC_ILONG_OS  =  777,
+  UNUSED778  =  778,
+  UNUSED779  =  779,
+  MADC_ILOOP_OS  =  780,
+  MADC_SCALE_ILOOP  =  781,
+  UNUSED782  =  782,
+  UNUSED783  =  783,
+  DC_ADC_OS  =  784,
+  CAL_UNITY  =  785,
+  UNUSED786  =  786,
+  UNUSED787  =  787,
+  ACADC_OFFSET  =  788,
+  ACDAC_OFFSET  =  789,
+  CAL_DCDAC_CODE  =  790,
+  CAL_DCDAC_15MA  =  791,
+  UNUSED792  =  792,
+  UNUSED793  =  793,
+  UNUSED794  =  794,
+  UNUSED795  =  795,
+  UNUSED796  =  796,
+  UNUSED797  =  797,
+  UNUSED798  =  798,
+  UNUSED799  =  799,
+  UNUSED800  =  800,
+  CAL_LB_TSQUELCH  =  801,
+  CAL_LB_TCHARGE  =  802,
+  CAL_LB_TSETTLE0  =  803,
+  CAL_GOERTZEL_DLY  =  804,
+  CAL_GOERTZEL_ALPHA  =  805,
+  CAL_DECLPF_K  =  806,
+  CAL_DECLPF_B1  =  807,
+  CAL_DECLPF_B2  =  808,
+  CAL_DECLPF_A1  =  809,
+  CAL_DECLPF_A2  =  810,
+  CAL_ACADC_THRL  =  811,
+  CAL_ACADC_THRH  =  812,
+  CAL_ACADC_TSETTLE  =  813,
+  DTROW0TH  =  814,
+  DTROW1TH  =  815,
+  DTROW2TH  =  816,
+  DTROW3TH  =  817,
+  DTCOL0TH  =  818,
+  DTCOL1TH  =  819,
+  DTCOL2TH  =  820,
+  DTCOL3TH  =  821,
+  DTFTWTH  =  822,
+  DTRTWTH  =  823,
+  DTROWRTH  =  824,
+  DTCOLRTH  =  825,
+  DTROW2HTH  =  826,
+  DTCOL2HTH  =  827,
+  DTMINPTH  =  828,
+  DTHOTTH  =  829,
+  RXPWR  =  830,
+  TXPWR  =  831,
+  RXMODPWR  =  832,
+  TXMODPWR  =  833,
+  FSKFREQ0  =  834,
+  FSKFREQ1  =  835,
+  FSKAMP0  =  836,
+  FSKAMP1  =  837,
+  FSK01  =  838,
+  FSK10  =  839,
+  VOCDELTA  =  840,
+  VOCLTH  =  841,
+  VOCHTH  =  842,
+  RINGOF  =  843,
+  RINGFR  =  844,
+  RINGAMP  =  845,
+  RINGPHAS  =  846,
+  RTDCTH  =  847,
+  RTACTH  =  848,
+  RTDCDB  =  849,
+  RTACDB  =  850,
+  RTCOUNT  =  851,
+  LCROFFHK  =  852,
+  LCRONHK  =  853,
+  LCRMASK  =  854,
+  LCRMASK_POLREV  =  855,
+  LCRMASK_STATE  =  856,
+  LCRMASK_LINECAP  =  857,
+  LONGHITH  =  858,
+  LONGLOTH  =  859,
+  IRING_LIM  =  860,
+  AC_PU_DELTA1  =  861,
+  AC_PU_DELTA2  =  862,
+  DIAG_LPF_8K  =  863,
+  DIAG_LPF_128K  =  864,
+  DIAG_INV_N  =  865,
+  DIAG_GAIN  =  866,
+  DIAG_G_CAL  =  867,
+  DIAG_OS_CAL  =  868,
+  SPR_GAIN_TRIM  =  869,
+  UNUSED870  =  870,
+  AC_DAC_GAIN  =  871,
+  UNUSED872  =  872,
+  UNUSED873  =  873,
+  AC_DAC_GAIN0  =  874,
+  EZSYNTH_B0  =  875,
+  OFFLD_DAC_SCALE  =  876,
+  UNUSED877  =  877,
+  OFFLD_DAC_OS  =  878,
+  UNUSED879  =  879,
+  AC_ADC_GAIN  =  880,
+  ILOOP1LPF  =  881,
+  RING_FLUSH_TIMER  =  882,
+  ALAW_BIAS  =  883,
+  MADC_VTRC_SCALE  =  884,
+  MADC_VBAT_SCALE  =  885,
+  UNUSED886  =  886,
+  MADC_VLONG_SCALE  =  887,
+  MADC_VLONG_SCALE_RING  =  888,
+  UNUSED889  =  889,
+  MADC_VDC_SCALE  =  890,
+  MADC_ILONG_SCALE  =  891,
+  UNUSED892  =  892,
+  UNUSED893  =  893,
+  VDIFF_SENSE_SCALE  =  894,
+  VDIFF_SENSE_SCALE_RING  =  895,
+  VOV_RING_GND  =  896,
+  P_TH_OFFLOAD  =  897,
+  CAL_LB_OSC1_FREQ  =  898,
+  CAL_DCDAC_9TAU  =  899,
+  CAL_MADC_9TAU  =  900,
+  ADAP_RING_MIN_I  =  901,
+  SWEEP_STEP  =  902,
+  SWEEP_STEP_SAVE  =  903,
+  SWEEP_REF  =  904,
+  AMP_STEP  =  905,
+  RXACGAIN_SAVE  =  906,
+  AMP_RAMP_INIT  =  907,
+  DIAG_HPF_GAIN  =  908,
+  DIAG_HPF_8K  =  909,
+  DIAG_ADJ_STEP  =  910,
+  UNUSED911  =  911,
+  UNUSED912  =  912,
+  MADC_SCALE_INV  =  913,
+  UNUSED914  =  914,
+  PWRSAVE_TIMER  =  915,
+  OFFHOOK_THRESH  =  916,
+  SPEEDUP_MASK_TIMER  =  917,
+  XTALK_TIMER  =  918,
+  VBAT_TRACK_MIN  =  919,
+  VBAT_TRACK_MIN_RNG  =  920,
+  UNUSED921  =  921,
+  UNUSED922  =  922,
+  UNUSED923  =  923,
+  UNUSED924  =  924,
+  UNUSED925 =  925,
+  UNUSED926  =  926,
+  DC_HOLD_DAC_OS  =  927,
+  DAA_DTMF_IN_SCALE  =  928,
+  NOTCH_B0  =  929,
+  NOTCH_B1  =  930,
+  NOTCH_B2  =  931,
+  NOTCH_A1  =  932,
+  NOTCH_A2  =  933,
+  METER_LPF_B0  =  934,
+  METER_LPF_B1  =  935,
+  METER_LPF_B2  =  936,
+  METER_LPF_A1  =  937,
+  METER_LPF_A2  =  938,
+  METER_SIG_0  =  939,
+  METER_SIG_1  =  940,
+  METER_SIG_2  =  941,
+  METER_SIG_3  =  942,
+  METER_SIG_4  =  943,
+  METER_SIG_5  =  944,
+  METER_SIG_6  =  945,
+  METER_SIG_7  =  946,
+  METER_SIG_8  =  947,
+  METER_SIG_9  =  948,
+  METER_SIG_10  =  949,
+  METER_SIG_11  =  950,
+  METER_SIG_12  =  951,
+  METER_SIG_13  =  952,
+  METER_SIG_14  =  953,
+  METER_SIG_15  =  954,
+  METER_BP_B0  =  955,
+  METER_BP_B1  =  956,
+  METER_BP_B2  =  957,
+  METER_BP_A1  =  958,
+  METER_BP_A2  =  959,
+  PM_AMP_THRESH  =  960,
+  PM_GAIN  =  961,
+  PWRSAVE_DBI  =  962,
+  DCDC_ANA_SCALE  =  963,
+  VOV_BAT_PWRSAVE_LO  =  964,
+  VOV_BAT_PWRSAVE_HI  =  965,
+  AC_ADC_GAIN0  =  966,
+  SCALE_KAUDIO  =  967,
+  METER_GAIN_TEMP  =  968,
+  METER_RAMP_STEP  =  969,
+  THERM_DBI  =  970,
+  LPR_SCALE =  971,
+  LPR_CM_OS =  972,
+  VOV_DCDC_SLOPE  =  973,
+  VOV_DCDC_OS  =  974,
+  VOV_RING_BAT_MAX  =  975,
+  SLOPE_VLIM1 =  976,
+  SLOPE_RFEED1  =  977,
+  SLOPE_ILIM1  =  978,
+  V_VLIM1  =  979,
+  V_RFEED1  =  980,
+  V_ILIM1  =  981,
+  CONST_RFEED1 =  982,
+  CONST_ILIM1 =  983,
+  I_VLIM1  =  984,
+  SLOPE_VLIM2 =  985,
+  SLOPE_RFEED2  =  986,
+  SLOPE_ILIM2  =  987,
+  V_VLIM2  =  988,
+  V_RFEED2  =  989,
+  V_ILIM2 =  990,
+  CONST_RFEED2  =  991,
+  CONST_ILIM2  =  992,
+  I_VLIM2  =  993,
+  DIAG_V_TAR  =  994,
+  DIAG_V_TAR2  =  995,
+  STOP_TIMER1_VAL =  996,
+  STOP_TIMER2_VAL =  997,
+  DIAG_VCM1_TAR  =  998,
+  DIAG_VCM_STEP  =  999,
+  LKG_DNT_HIRES  =  1000,
+  LKG_DNR_HIRES  =  1001,
+  LINEAR_OS  =  1002,
+  CPUMP_DEB =  1003,
+  DCDC_VERR  =  1004,
+  DCDC_VERR_HYST  =  1005,
+  DCDC_OITHRESH_LO  =  1006,
+  DCDC_OITHRESH_HI =  1007,
+  HV_BIAS_ONHK  =  1008,
+  HV_BIAS_OFFHK  =  1009,
+#ifdef USE_SI3226X_REVB_DEFINES
+  RING_ENTRY_DLY  =  1010,
+  RING_EXIT_DLY  =  1011,
+  VBAT_FIXRL_RING  =  1012,
+  VBAT_FIXRL_ACT  =  1013,
+  VBAT_FIXRL_LP  =  1014,
+  VOV_RING_BAT_DCDC  =  1015,
+  P_OFFLOAD_VBAT_HYST  =  1016,
+  LKG_OFHK_OFFSET  =  1017,
+  LKG_LB_OFFSET  =  1018,
+  UNUSED1019  =  1019,
+  VBATH_DELTA  =  1020,
+  UVTHRESH_MAX  =  1021,
+  UVTHRESH_SCALE  =  1022,
+  UVTHRESH_BIAS  =  1023
+#else
+  UVTHRESH_BIAS = 1010,
+  UVTHRESH_SCALE = 1011,
+  UVTHRESH_MAX = 1012,
+  VBATH_DELTA = 1013,
+  UNUSED1014 = 1014,
+  VOV_RING_BAT_DCDC = 1015,
+  P_OFFLOAD_VBAT_HYST = 1016,
+  LKG_LB_OFFSET = 1017,
+  LKG_OFHK_OFFSET = 1018
+#endif
+};
+
+/*
+** This defines the mnemonics for applicable SI3226X Memory-mapped register locations
+*/
+enum
+{
+  PD_BIAS = 1413,
+  PD_VBAT_SNS = 1418,
+  PD_HVIC = 1430,
+  MADC_LOOP_MAN = 1445,
+  HVIC_CNTL_MAN = 1451,
+  CAL_TRNRD_DACT = 1458,
+  CAL_TRNRD_DACR,
+  CMDAC_FWD = 1476,
+  CMDAC_REV,
+  RDC_SUM = 1499,
+  PD_OFFLD_DAC = 1512,
+  PD_OFFLD_GM = 1513,
+  PD_DCDC = 1538,
+  PD_UVLO = 1540,
+  PD_OVLO,
+  PD_OCLO,
+  DCDC_UVHYST = 1545,
+  DCDC_UVTHRESH,
+  DCDC_OVTHRESH = 1547,
+  DCDC_OITHRESH,
+  UNUSED1549,
+  DCDC_CCM_THRESH,
+  DCDC_STATUS,
+  DCDC_FSW,
+  DCDC_SWDRV_POL,
+  DCDC_UVPOL,
+  DCDC_CPUMP,
+  UNUSED1556,
+  UNUSED1557,
+  DCDC_VREF_CTRL,
+  UNUSED1559,
+  DCDC_RNGTYPE,
+  DCDC_DCFF_ENABLE = 1635,
+  DCDC_OIMASK = 1565,
+  PD_REF_OSC = 1571,
+  PWRSAVE_CTRL_LO = 1575,
+  DCDC_ANA_GAIN = 1585,
+  DCDC_ANA_TOFF,
+  DCDC_ANA_TONMIN,
+  DCDC_ANA_TONMAX,
+  DCDC_ANA_DSHIFT,
+  DCDC_ANA_LPOLY,
+  DCDC_PD_ANA = 1592,
+  PATCH_JMP8 = 1597,
+  PM_ACTIVE = 1606,
+  PM_INACTIVE = 1607,
+  DCDC_CPUMP_LP_MASK = 1616,
+  DCDC_UV_MAN = 1640,
+  DCDC_UV_DEBOUNCE = 1641,
+  DCDC_OV_MAN = 1642,
+  DCDC_OV_DEBOUNCE = 1643,
+  OFFLD_DAC_MAN = 1646
+};
+
+/* Temporary Rev B Support During Rev C Adoption */
+#define LKG_OFHK_OFFSET_REVB 1017
+#define LKG_LB_OFFSET_REVB   1018
+#define VBATH_DELTA_REVB     1020
+#define UVTHRESH_MAX_REVB    1021
+#define UVTHRESH_SCALE_REVB  1022
+#define UVTHRESH_BIAS_REVB   1023
+
+/* Temporarily map obsolete ram locations for debug purposes */
+#define DCDC_FSW_NORM       UNUSED921
+#define DCDC_FSW_NORM_LO    UNUSED922
+#define DCDC_DIN_LIM        UNUSED925
+#define DCDC_FSW_RING       UNUSED923
+#define DCDC_FSW_RING_LO    UNUSED924
+#define DCDC_VOUT_LIM       UNUSED926
+#define DCDC_FSW_VHYST      Y3
+#define DCDC_FSW_VTHLO      Y2
+#define DAA_CNTL            74
+#define DCDC_VREF_MIN       VBAT_TRACK_MIN
+#define DCDC_VREF_MIN_RNG   VBAT_TRACK_MIN_RNG
+
+#endif
+
Index: linux-5.4.171/sound/soc/codecs/si3218x/inc/si3228x.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-5.4.171/sound/soc/codecs/si3218x/inc/si3228x.h	2022-02-22 10:59:20.000000000 +0800
@@ -0,0 +1,258 @@
+/*
+** Copyright (c) 2015-2016 by Silicon Laboratories
+**
+** $Id: si3228x.h 42313 2018-02-10 07:12:50Z oliu $
+**
+** Author(s):
+** laj
+**
+** Distributed by:
+** Silicon Laboratories, Inc
+**
+** This file contains proprietary information.
+** No dissemination allowed without prior written permission from
+** Silicon Laboratories, Inc.
+**
+*/
+
+#ifndef SI3228XH_H
+#define SI3228XH_H
+
+#include "proslic.h"
+
+
+#define SI3228X_CHAN_PER_DEVICE 2
+
+/*
+** SI3228X DataTypes/Function Definitions
+*/
+
+typedef ProSLIC_DCfeed_Cfg Si3228x_DCfeed_Cfg;
+typedef Si3228x_DCfeed_Cfg *Si3228x_DCfeed_Cfg_ptr;
+/*
+** Defines structure for general configuration and the dcdc converter
+*/
+typedef struct
+{
+  uInt8 device_key;    /* Used to prevent loaded coeffs for another device */
+  bomOptionsType bomOpt;
+  batRailType  batType;
+  ramData bat_hyst;
+  ramData vbatr_expect; /* default - this is overwritten by ring preset */
+  ramData vbath_expect;  /* default - this is overwritten by dc feed preset */
+  ramData pwrsave_timer;
+  ramData offhook_thresh;
+  ramData vbat_track_min;
+  ramData vbat_track_min_rng;
+  ramData pwrsave_dbi;
+  ramData dcdc_ana_scale;
+  ramData vov_bat_pwrsave_min;
+  ramData vov_bat_pwrsave_min_rng;
+  ramData therm_dbi;
+  ramData cpump_dbi;
+  ramData dcdc_verr;
+  ramData dcdc_verr_hyst;
+  ramData dcdc_oithresh_lo;
+  ramData dcdc_oithresh_hi;
+  ramData pd_uvlo;
+  ramData pd_ovlo;
+  ramData pd_oclo;
+  ramData pd_swdrv;
+  ramData dcdc_uvhyst;
+  ramData dcdc_uvthresh;
+  ramData dcdc_ovthresh;
+  ramData dcdc_oithresh;
+  ramData dcdc_swdrv_pol;
+  ramData dcdc_uvpol;
+  ramData dcdc_vref_man;
+  ramData dcdc_vref_ctrl;
+  ramData dcdc_rngtype;
+  ramData dcdc_ana_vref;
+  ramData dcdc_ana_gain;
+  ramData dcdc_ana_toff;
+  ramData dcdc_ana_tonmin;
+  ramData dcdc_ana_tonmax;
+  ramData dcdc_ana_dshift;
+  ramData dcdc_ana_lpoly;
+  ramData dcdc_aux_invert;
+  ramData dcdc_cpump_lp;
+  ramData dcdc_cpump_pulldown;
+  ramData dcdc_lift_en;
+  ramData coef_p_hvic;
+  ramData p_th_hvic;
+  uInt8 vdc_range;
+  uInt8 autoRegister;
+  uInt8 irqen1;
+  uInt8 irqen2;
+  uInt8 irqen3;
+  uInt8 irqen4;
+  uInt8 enhance;
+  ramData scale_kaudio;
+  uInt8 zcal_en;
+  ramData lkg_ofhk_offset;
+  ramData lkg_lb_offset;
+  ramData vbath_delta;
+  ramData uvthresh_max;
+  ramData uvthresh_scale;
+  ramData uvthresh_bias;
+} Si3228x_General_Cfg;
+
+
+/*
+** Defines structure for configuring pcm
+*/
+typedef struct
+{
+  uInt8 pcmFormat;
+  uInt8 widebandEn;
+  uInt8 pcm_tri;
+  uInt8 tx_edge;
+  uInt8 alaw_inv;
+} Si3228x_PCM_Cfg;
+
+/*
+** Defines structure for configuring pulse metering
+*/
+typedef struct
+{
+  ramData pm_amp_thresh;
+  uInt8 pm_freq;
+  uInt8 pm_auto;
+  ramData pm_active;
+  ramData pm_inactive;
+} Si3228x_PulseMeter_Cfg;
+
+/*
+** Defines structure for configuring FSK generation
+*/
+typedef ProSLIC_FSK_Cfg Si3228x_FSK_Cfg;
+
+
+/*
+** Defines structure for configuring impedance synthesis
+*/
+typedef struct
+{
+  ramData zsynth_b0;
+  ramData zsynth_b1;
+  ramData zsynth_b2;
+  ramData zsynth_a1;
+  ramData zsynth_a2;
+  uInt8 ra;
+} Si3228x_Zsynth_Cfg;
+
+/*
+** Defines structure for configuring hybrid
+*/
+typedef struct
+{
+  ramData ecfir_c2;
+  ramData ecfir_c3;
+  ramData ecfir_c4;
+  ramData ecfir_c5;
+  ramData ecfir_c6;
+  ramData ecfir_c7;
+  ramData ecfir_c8;
+  ramData ecfir_c9;
+  ramData ecfir_b0;
+  ramData ecfir_b1;
+  ramData ecfir_a1;
+  ramData ecfir_a2;
+} Si3228x_hybrid_Cfg;
+
+
+/*
+** Defines structure for configuring audio eq
+*/
+
+typedef struct
+{
+  ramData txaceq_c0;
+  ramData txaceq_c1;
+  ramData txaceq_c2;
+  ramData txaceq_c3;
+
+  ramData rxaceq_c0;
+  ramData rxaceq_c1;
+  ramData rxaceq_c2;
+  ramData rxaceq_c3;
+} Si3228x_audioEQ_Cfg;
+
+
+
+/*
+** Defines structure for configuring audio gain
+*/
+
+typedef ProSLIC_audioGain_Cfg Si3228x_audioGain_Cfg;
+
+
+typedef struct
+{
+  Si3228x_audioEQ_Cfg audioEQ;
+  Si3228x_hybrid_Cfg hybrid;
+  Si3228x_Zsynth_Cfg zsynth;
+  ramData txgain;
+  ramData rxgain;
+  ramData rxachpf_b0_1;
+  ramData  rxachpf_b1_1;
+  ramData  rxachpf_a1_1;
+  int16 txgain_db; /*overall gain associated with this configuration*/
+  int16 rxgain_db;
+} Si3228x_Impedance_Cfg;
+
+
+
+/*
+** Defines structure for configuring tone generator
+*/
+typedef ProSLIC_Tone_Cfg Si3228x_Tone_Cfg;
+
+/*
+** Defines structure for configuring ring generator
+*/
+typedef struct
+{
+  ramData rtper;
+  ramData freq;
+  ramData amp;
+  ramData phas;
+  ramData offset;
+  ramData slope_ring;
+  ramData iring_lim;
+  ramData rtacth;
+  ramData rtdcth;
+  ramData rtacdb;
+  ramData rtdcdb;
+  ramData vov_ring_bat;
+  ramData vov_ring_gnd;
+  ramData vbatr_expect;
+  uInt8 talo;
+  uInt8 tahi;
+  uInt8 tilo;
+  uInt8 tihi;
+  ramData adap_ring_min_i;
+  ramData counter_iring_val;
+  ramData counter_vtr_val;
+  ramData ar_const28;
+  ramData ar_const32;
+  ramData ar_const38;
+  ramData ar_const46;
+  ramData rrd_delay;
+  ramData rrd_delay2;
+  ramData vbat_track_min_rng;
+  uInt8 ringcon;
+  uInt8 userstat;
+  ramData vcm_ring;
+  ramData vcm_ring_fixed;
+  ramData delta_vcm;
+  ramData dcdc_rngtype;
+  ramData vov_dcdc_slope;
+  ramData vov_dcdc_os;
+  ramData vov_ring_bat_max;
+  ramData smart_ring_period;
+  ramData smart_ring_phase;
+} Si3228x_Ring_Cfg;
+
+#endif
+
Index: linux-5.4.171/sound/soc/codecs/si3218x/inc/si3228x_intf.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-5.4.171/sound/soc/codecs/si3218x/inc/si3228x_intf.h	2022-02-22 10:59:20.000000000 +0800
@@ -0,0 +1,371 @@
+/*
+** Copyright (c) 2015-2017 by Silicon Laboratories
+**
+** $Id: si3228x_intf.h 42313 2018-02-10 07:12:50Z oliu $
+**
+** Si3228x_Intf.h
+** Si3228x ProSLIC interface header file
+**
+**
+** Distributed by:
+** Silicon Laboratories, Inc
+**
+** This file contains proprietary information.
+** No dissemination allowed without prior written permission from
+** Silicon Laboratories, Inc.
+**
+** File Description:
+** This is the header file for the ProSLIC driver.
+**
+**
+*/
+
+#ifndef SI3228X_INTF_H
+#define SI3228X_INTF_H
+#include "si3228x.h"
+
+/*
+** Calibration Constants
+*/
+#define SI3228X_CAL_STD_CALR1               0xC0    /* FF */
+#define SI3228X_CAL_STD_CALR2               0x18    /* F8 */
+
+/* Timeouts in 10s of ms */
+#define SI3228X_TIMEOUT_DCDC_UP             200
+#define SI3228X_TIMEOUT_DCDC_DOWN           200
+
+/* The following macros are for backward compatibility */
+#define Si3228x_DCFeedSetup(PCHAN,PRESET)    Si3228x_DCFeedSetupCfg((PCHAN),Si3228x_DCfeed_Presets,(PRESET))
+#define Si3228x_LoadPatch                    ProSLIC_LoadPatch
+#define Si3228x_ReadHookStatus               ProSLIC_ReadHookStatus
+#define Si3228x_SetPowersaveMode             ProSLIC_SetPowersaveMode
+#define Si3228x_VerifyPatch                  ProSLIC_VerifyPatch
+#define Si3228x_Init(PCHAN,SZ)               Si3228x_Init_with_Options((PCHAN),(SZ),INIT_NO_OPT)
+#define Si3228x_VerifyControlInterface       ProSLIC_VefifyControlInterface
+#define Si3228x_ShutdownChannel              ProSLIC_PowerDownConverter
+#define Si3228x_PowerDownConverter           ProSLIC_PowerDownConverter
+#define Si3228x_Calibrate                    ProSLIC_Calibrate
+#define Si3228x_SetLinefeedStatusBroadcast   ProSLIC_SetLinefeedStatusBroadcast
+#define Si3228x_SetLinefeedStatus            ProSLIC_SetLinefeedStatus
+#define Si3228x_MWIEnable                    ProSLIC_MWIEnable
+#define Si3228x_MWIDisable                   ProSLIC_MWIDisable
+#define Si3228x_SetMWIState                  ProSLIC_SetMWIState
+#define Si3228x_GetMWIState                  ProSLIC_GetMWIState
+#define Si3228x_MWISetup(PCHAN,VPK,LCR)      ProSLIC_MWISetV(PCHAN,VPK)
+
+/* DC Feed */
+#ifndef DISABLE_DCFEED_SETUP
+extern Si3228x_DCfeed_Cfg Si3228x_DCfeed_Presets[];
+#endif
+
+
+/*
+**
+** PROSLIC INITIALIZATION FUNCTIONS
+**
+*/
+
+/*
+** Function: PROSLIC_Init_MultiBOM
+**
+** Description:
+** Initializes the ProSLIC w/ selected general parameters
+**
+** Input Parameters:
+** pProslic: pointer to PROSLIC object
+** size:     number of channels
+** preset:   general configuration preset
+**
+** Return:
+** none
+*/
+int Si3228x_Init_MultiBOM (proslicChanType_ptr *hProslic,int size,int preset);
+
+/*
+** Function: Si3228x_Init_with_Options
+**
+** Description:
+** Initializes the ProSLIC with an option.
+**
+** Input Parameters:
+** pProslic: pointer to PROSLIC object
+** size - number of continuous channels to initialize
+** init_opt - which initialization type to do.
+**
+** Return:
+** none
+*/
+int Si3228x_Init_with_Options (proslicChanType_ptr *pProslic, int size,
+                               initOptionsType init_opt);
+
+/*
+** Function: PROSLIC_VerifyControlInterface
+**
+** Description:
+** Verify SPI port read capabilities
+**
+** Input Parameters:
+** pProslic: pointer to PROSLIC object
+**
+** Return:
+** none
+*/
+int Si3228x_VerifyControlInterface (proslicChanType_ptr hProslic);
+
+/*
+** Function: Si3228x_PowerUpConverter
+**
+** Description:
+** Powers all DC/DC converters sequentially with delay to minimize
+** peak power draw on VDC.
+**
+** Returns:
+** int (error)
+**
+*/
+int Si3228x_PowerUpConverter(proslicChanType_ptr hProslic);
+
+/*
+** Function: PROSLIC_EnableInterrupts
+**
+** Description:
+** Enables interrupts
+**
+** Input Parameters:
+** hProslic: pointer to Proslic object
+**
+** Return:
+**
+*/
+int Si3228x_EnableInterrupts (proslicChanType_ptr hProslic);
+
+/*
+**
+** PROSLIC CONFIGURATION FUNCTIONS
+**
+*/
+
+/*
+** Function: PROSLIC_RingSetup
+**
+** Description:
+** configure ringing
+**
+** Input Parameters:
+** pProslic: pointer to Proslic object
+** pRingSetup: pointer to ringing config structure
+**
+** Return:
+** none
+*/
+int Si3228x_RingSetup (proslicChanType *pProslic, int preset);
+
+/*
+** Function: PROSLIC_ZsynthSetup
+**
+** Description:
+** configure impedance synthesis
+**
+** Input Parameters:
+** pProslic: pointer to Proslic object
+** pZynth: pointer to zsynth config structure
+**
+** Return:
+** none
+*/
+int Si3228x_ZsynthSetup (proslicChanType *pProslic, int preset);
+
+/*
+** Function: PROSLIC_AudioGainSetup
+**
+** Description:
+** configure audio gains
+**
+** Input Parameters:
+** pProslic: pointer to Proslic object
+** pAudio: pointer to audio gains config structure
+**
+** Return:
+** none
+*/
+int Si3228x_TXAudioGainSetup (proslicChanType *pProslic, int preset);
+int Si3228x_RXAudioGainSetup (proslicChanType *pProslic, int preset);
+#define Si3228x_AudioGainSetup ProSLIC_AudioGainSetup
+int Si3228x_TXAudioGainScale (proslicChanType *pProslic, int preset,
+                              uInt32 pga_scale, uInt32 eq_scale);
+int Si3228x_RXAudioGainScale (proslicChanType *pProslic, int preset,
+                              uInt32 pga_scale, uInt32 eq_scale);
+
+/*
+** Function: PROSLIC_DCFeedSetup
+**
+** Description:
+** configure dc feed
+**
+** Input Parameters:
+** pProslic: pointer to Proslic object
+** pDcFeed: pointer to dc feed config structure
+**
+** Return:
+** none
+*/
+int Si3228x_DCFeedSetupCfg (proslicChanType *pProslic,ProSLIC_DCfeed_Cfg *cfg,
+                            int preset);
+
+/*
+** Function: PROSLIC_PCMSetup
+**
+** Description:
+** configure pcm
+**
+** Input Parameters:
+** pProslic: pointer to Proslic object
+** pPcm: pointer to pcm config structure
+**
+** Return:
+** none
+*/
+int Si3228x_PCMSetup (proslicChanType *pProslic, int preset);
+
+/*
+**
+** PROSLIC CONTROL FUNCTIONS
+**
+*/
+
+/*
+** Function: PROSLIC_PulseMeterSetup
+**
+** Description:
+** configure pulse metering
+**
+** Input Parameters:
+** pProslic: pointer to Proslic object
+** pPulseCfg: pointer to pulse metering config structure
+**
+** Return:
+** none
+*/
+int Si3228x_PulseMeterSetup (proslicChanType *pProslic, int preset);
+
+/*
+** Function: PROSLIC_dbgSetDCFeed
+**
+** Description:
+** provisionary function for setting up
+** dcfeed given desired open circuit voltage
+** and loop current.
+*/
+int Si3228x_dbgSetDCFeed (proslicChanType *pProslic, uInt32 v_vlim_val,
+                          uInt32 i_ilim_val, int32 preset);
+
+/*
+** Function: PROSLIC_dbgSetDCFeedVopen
+**
+** Description:
+** provisionary function for setting up
+** dcfeed given desired open circuit voltage
+** and loop current.
+*/
+int Si3228x_dbgSetDCFeedVopen (proslicChanType *pProslic, uInt32 v_vlim_val,
+                               int32 preset);
+
+
+/*
+** Function: PROSLIC_dbgSetDCFeedIloop
+**
+** Description:
+** provisionary function for setting up
+** dcfeed given desired open circuit voltage
+** and loop current.
+*/
+int Si3228x_dbgSetDCFeedIloop (proslicChanType *pProslic, uInt32 i_ilim_val,
+                               int32 preset);
+
+
+/*
+** Function: PROSLIC_dbgRingingSetup
+**
+** Description:
+** Provisionary function for setting up
+** Ring type, frequency, amplitude and dc offset.
+** Main use will be by peek/poke applications.
+*/
+int Si3228x_dbgSetRinging (proslicChanType *pProslic,
+                           ProSLIC_dbgRingCfg *ringCfg, int preset);
+
+/*
+** Function: PROSLIC_dbgSetRXGain
+**
+** Description:
+** Provisionary function for setting up
+** RX path gain.
+*/
+int Si3228x_dbgSetRXGain (proslicChanType *pProslic, int32 gain,
+                          int impedance_preset, int audio_gain_preset);
+
+/*
+** Function: PROSLIC_dbgSetTXGain
+**
+** Description:
+** Provisionary function for setting up
+** TX path gain.
+*/
+int Si3228x_dbgSetTXGain (proslicChanType *pProslic, int32 gain,
+                          int impedance_preset, int audio_gain_preset);
+
+
+/*
+** Function: PROSLIC_LineMonitor
+**
+** Description:
+** Monitor line voltages and currents
+*/
+int Si3228x_LineMonitor(proslicChanType *pProslic, proslicMonitorType *monitor);
+
+
+/*
+** Function: PROSLIC_PSTNCheck
+**
+** Description:
+** Continuous monitor of ilong to detect hot pstn line
+*/
+int Si3228x_PSTNCheck(proslicChanType *pProslic,
+                      proslicPSTNCheckObjType *pstnCheckObj);
+
+/*
+** Function: PROSLIC_DiffPSTNCheck
+**
+** Description:
+** Detection of foreign PSTN
+*/
+int Si3228x_DiffPSTNCheck (proslicChanType *pProslic,
+                           proslicDiffPSTNCheckObjType *pPSTNCheck);
+
+/*
+** Function: PROSLIC_SetPowersaveMode
+**
+** Description:
+** Enable or Disable powersave mode
+*/
+int Si3228x_SetPowersaveMode(proslicChanType *pProslic, int pwrsave);
+
+/*
+** Function: PROSLIC_ReadMADCScaled
+**
+** Description:
+** ReadMADC (or other sensed voltage/currents) and
+** return scaled value in int32 format
+*/
+int32 Si3228x_ReadMADCScaled(proslicChanType *pProslic, uInt16 addr,
+                             int32 scale);
+/* 
+** Function: Si3228x_GetChipInfo
+** Description: Returns the specific chipset in the Si3228x family.
+** Input parameters: channel pointer
+** output: either RC_SPI_FAIL or RC_NONE.  channel pointer deviceId will be updated.
+**/
+int Si3228x_GetChipInfo(proslicChanType_ptr pProslic);
+
+#endif
+
Index: linux-5.4.171/sound/soc/codecs/si3218x/inc/si3228x_registers.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-5.4.171/sound/soc/codecs/si3218x/inc/si3228x_registers.h	2022-02-22 10:59:20.000000000 +0800
@@ -0,0 +1,1236 @@
+/*
+** Copyright (c) 2015-2016 by Silicon Laboratories
+**
+** $Id: si3228x_registers.h 42313 2018-02-10 07:12:50Z oliu $
+**
+** Si3228_Registers.h
+**
+** Author(s):
+** laj
+**
+** Distributed by:
+** Silicon Laboratories, Inc
+**
+** This file contains proprietary information.
+** No dissemination allowed without prior written permission from
+** Silicon Laboratories, Inc.
+**
+** File Description:
+** This is the header file that contains
+** register and RAM names definitions for
+** the Si3228x ProSLIC.
+**
+**
+**
+*/
+#ifndef SI3228REGS_H
+#define SI3228REGS_H
+
+/*
+** This defines the mnemonics for the SI3228x registers
+*/
+enum REGISTERS
+{
+  ID  =  0,
+  RESET  =  1,
+  MSTREN  =  2,
+  MSTRSTAT  =  3,
+  RAMSTAT  =  4,
+  RAM_ADDR_HI  =  5,
+  RAM_DATA_B0  =  6,
+  RAM_DATA_B1  =  7,
+  RAM_DATA_B2  =  8,
+  RAM_DATA_B3  =  9,
+  RAM_ADDR_LO  =  10,
+  PCMMODE  =  11,
+  PCMTXLO  =  12,
+  PCMTXHI  =  13,
+  PCMRXLO  =  14,
+  PCMRXHI  =  15,
+  IRQ  =  16,
+  IRQ0  =  17,
+  IRQ1  =  18,
+  IRQ2  =  19,
+  IRQ3  =  20,
+  IRQ4  =  21,
+  IRQEN1  =  22,
+  IRQEN2  =  23,
+  IRQEN3  =  24,
+  IRQEN4  =  25,
+  CALR0  =  26,
+  CALR1  =  27,
+  CALR2  =  28,
+  CALR3  =  29,
+  LINEFEED  =  30,
+  POLREV  =  31,
+  SPEEDUP_DIS  =  32,
+  SPEEDUP  =  33,
+  LCRRTP  =  34,
+  OFFLOAD  =  35,
+  BATSELMAP  =  36,
+  BATSEL  =  37,
+  RINGCON  =  38,
+  RINGTALO  =  39,
+  RINGTAHI  =  40,
+  RINGTILO  =  41,
+  RINGTIHI  =  42,
+  LOOPBACK  =  43,
+  DIGCON  =  44,
+  RA  =  45,
+  ZCAL_EN  =  46,
+  ENHANCE  =  47,
+  OMODE  =  48,
+  OCON  =  49,
+  O1TALO  =  50,
+  O1TAHI  =  51,
+  O1TILO  =  52,
+  O1TIHI  =  53,
+  O2TALO  =  54,
+  O2TAHI  =  55,
+  O2TILO  =  56,
+  O2TIHI  =  57,
+  FSKDAT  =  58,
+  FSKDEPTH  =  59,
+  TONDTMF  =  60,
+  TONDET  =  61,
+  TONEN  =  62,
+  GCI_CI  =  63,
+  GLOBSTAT1  =  64,
+  GLOBSTAT2  =  65,
+  USERSTAT  =  66,
+  GPIO_CFG1 = 68,
+  DIAG1  =  71,
+  DIAG2  =  72,
+  CM_CLAMP  =  73,
+  DIAG3  =  74,
+  PMCON  =  75,
+  PCLK_FAULT_CNTL  =  76,
+  REG77  =  77,
+  REG78  =  78,
+  REG79  =  79,
+  AUTO  =  80,
+  JMPEN  =  81,
+  JMP0LO  =  82,
+  JMP0HI  =  83,
+  JMP1LO  =  84,
+  JMP1HI  =  85,
+  JMP2LO  =  86,
+  JMP2HI  =  87,
+  JMP3LO  =  88,
+  JMP3HI  =  89,
+  JMP4LO  =  90,
+  JMP4HI  =  91,
+  JMP5LO  =  92,
+  JMP5HI  =  93,
+  JMP6LO  =  94,
+  JMP6HI  =  95,
+  JMP7LO  =  96,
+  JMP7HI  =  97,
+  PDN  =  98,
+  PDN_STAT  =  99,
+  USERMODE_ENABLE = 126
+};
+
+
+/*
+** This defines the mnemonics for the SI3228x RAM locations
+*/
+enum SRAM
+{
+  IRNGNG_SENSE  =  0,
+  MADC_VTIPC  =  1,
+  MADC_VRINGC  =  2,
+  MADC_VBAT  =  3,
+  MADC_VLONG  =  4,
+  UNUSED5  =  5,
+  MADC_VDC  =  6,
+  MADC_ILONG  =  7,
+  MADC_ITIP  =  8,
+  MADC_IRING  =  9,
+  MADC_ILOOP  =  10,
+  VDIFF_SENSE  =  11,
+  VTIP  =  12,
+  VRING  =  13,
+  P_Q1_D  =  14,
+  P_Q2_D  =  15,
+  P_Q3_D  =  16,
+  P_Q4_D  =  17,
+  P_Q5_D  =  18,
+  P_Q6_D  =  19,
+  P_Q1  =  20,
+  DIAG_EX1  =  21,
+  DIAG_EX2  =  22,
+  DIAG_LPF_MADC  =  23,
+  DIAG_DMM_I  =  24,
+  DIAG_DMM_V  =  25,
+  OSC1FREQ  =  26,
+  OSC1AMP  =  27,
+  OSC1PHAS  =  28,
+  OSC2FREQ  =  29,
+  OSC2AMP  =  30,
+  OSC2PHAS  =  31,
+  TESTB0_1  =  32,
+  TESTB1_1  =  33,
+  TESTB2_1  =  34,
+  TESTA1_1  =  35,
+  TESTA2_1  =  36,
+  TESTB0_2  =  37,
+  TESTB1_2  =  38,
+  TESTB2_2  =  39,
+  TESTA1_2  =  40,
+  TESTA2_2  =  41,
+  TESTB0_3  =  42,
+  TESTB1_3  =  43,
+  TESTB2_3  =  44,
+  TESTA1_3  =  45,
+  TESTA2_3  =  46,
+  TESTPKO  =  47,
+  TESTAVO  =  48,
+  TESTWLN  =  49,
+  TESTAVBW  =  50,
+  TESTPKFL  =  51,
+  TESTAVFL  =  52,
+  TESTPKTH  =  53,
+  TESTAVTH  =  54,
+  DAC_IN_SYNC1  =  55,
+  BYPASS_REG  =  56,
+  LCRMASK_CNT  =  57,
+  DAC_IN_SYNC  =  58,
+  TEMP  =  59,
+  TEMP_ISR  =  60,
+  P_Q2  =  61,
+  P_Q3  =  62,
+  P_Q4  =  63,
+  P_Q5  =  64,
+  P_Q6  =  65,
+  ILOOP_FILT  =  66,
+  ILONG_FILT  =  67,
+  VBAT_FILT  =  68,
+  VDIFF_FILT  =  69,
+  VCM_FILT  =  70,
+  VBAT_CNT  =  71,
+  V_VLIM_SCALED  =  72,
+  V_VLIM_TRACK  =  73,
+  V_VLIM_MODFEED  =  74,
+  DIAG_P_OUT  =  75,
+  DIAG_COUNT  =  76,
+  ROW0_MAG  =  77,
+  ROW1_MAG  =  78,
+  ROW2_MAG  =  79,
+  ROW3_MAG  =  80,
+  COL0_MAG  =  81,
+  COL1_MAG  =  82,
+  COL2_MAG  =  83,
+  COL3_MAG  =  84,
+  ROW0_2ND_Y1  =  85,
+  ROW1_2ND_Y1  =  86,
+  ROW2_2ND_Y1  =  87,
+  ROW3_2ND_Y1  =  88,
+  COL0_2ND_Y1  =  89,
+  COL1_2ND_Y1  =  90,
+  COL2_2ND_Y1  =  91,
+  COL3_2ND_Y1  =  92,
+  ROW0_2ND_Y2  =  93,
+  ROW1_2ND_Y2  =  94,
+  ROW2_2ND_Y2  =  95,
+  ROW3_2ND_Y2  =  96,
+  COL0_2ND_Y2  =  97,
+  COL1_2ND_Y2  =  98,
+  COL2_2ND_Y2  =  99,
+  COL3_2ND_Y2  =  100,
+  DTMF_IN  =  101,
+  DTMFDTF_D2_1  =  102,
+  DTMFDTF_D1_1  =  103,
+  DTMFDTF_OUT_1  =  104,
+  DTMFDTF_D2_2  =  105,
+  DTMFDTF_D1_2  =  106,
+  DTMFDTF_OUT_2  =  107,
+  DTMFDTF_D2_3  =  108,
+  DTMFDTF_D1_3  =  109,
+  DTMFDTF_OUT_3  =  110,
+  DTMFDTF_OUT  =  111,
+  DTMFLPF_D2_1  =  112,
+  DTMFLPF_D1_1  =  113,
+  DTMFLPF_OUT_1  =  114,
+  DTMFLPF_D2_2  =  115,
+  DTMFLPF_D1_2  =  116,
+  DTMFLPF_OUT_2  =  117,
+  DTMF_ROW  =  118,
+  DTMFHPF_D2_1  =  119,
+  DTMFHPF_D1_1  =  120,
+  DTMFHPF_OUT_1  =  121,
+  DTMFHPF_D2_2  =  122,
+  DTMFHPF_D1_2  =  123,
+  DTMFHPF_OUT_2  =  124,
+  DTMF_COL  =  125,
+  ROW_POWER  =  126,
+  COL_POWER  =  127,
+  GP_TIMER  =  128,
+  SPR_INTERP_DIF  =  129,
+  SPR_INTERP_DIF_OUT  =  130,
+  SPR_INTERP_INT  =  131,
+  SPR_CNT  =  132,
+  ROW0_Y1  =  133,
+  ROW0_Y2  =  134,
+  ROW1_Y1  =  135,
+  ROW1_Y2  =  136,
+  ROW2_Y1  =  137,
+  ROW2_Y2  =  138,
+  ROW3_Y1  =  139,
+  ROW3_Y2  =  140,
+  COL0_Y1  =  141,
+  COL0_Y2  =  142,
+  COL1_Y1  =  143,
+  COL1_Y2  =  144,
+  COL2_Y1  =  145,
+  COL2_Y2  =  146,
+  COL3_Y1  =  147,
+  COL3_Y2  =  148,
+  ROWMAX_MAG  =  149,
+  COLMAX_MAG  =  150,
+  ROW0_2ND_MAG  =  151,
+  COL0_2ND_MAG  =  152,
+  ROW_THR  =  153,
+  COL_THR  =  154,
+  OSC1_Y  =  155,
+  OSC2_Y  =  156,
+  OSC1_X  =  157,
+  OSC1_COEFF  =  158,
+  OSC2_X  =  159,
+  OSC2_COEFF  =  160,
+  RXACIIR_D2_1  =  161,
+  RXACIIR_OUT_1  =  162,
+  RXACIIR_D2_2  =  163,
+  RXACIIR_D1_2  =  164,
+  RXACIIR_OUT_2  =  165,
+  RXACIIR_D2_3  =  166,
+  RXACIIR_D1_3  =  167,
+  RXACIIR_OUT  =  168,
+  RXACIIR_OUT_3  =  169,
+  TXACCOMB_D1  =  170,
+  TXACCOMB_D2  =  171,
+  TXACCOMB_D3  =  172,
+  TXACSINC_OUT  =  173,
+  TXACHPF_D1_2  =  174,
+  TXACHPF_D2_1  =  175,
+  TXACHPF_D2_2  =  176,
+  TXACHPF_OUT  =  177,
+  TXACHPF_OUT_1  =  178,
+  TXACHPF_OUT_2  =  179,
+  TXACIIR_D2_1  =  180,
+  TXACIIR_OUT_1  =  181,
+  TXACIIR_D2_2  =  182,
+  TXACIIR_D1_2  =  183,
+  TXACIIR_OUT_2  =  184,
+  TXACIIR_D2_3  =  185,
+  TXACIIR_D1_3  =  186,
+  TXACIIR_OUT_3  =  187,
+  TXACIIR_OUT  =  188,
+  ECIIR_D1  =  189,
+  ECIIR_D2  =  190,
+  EC_DELAY1  =  191,
+  EC_DELAY2  =  192,
+  EC_DELAY3  =  193,
+  EC_DELAY4  =  194,
+  EC_DELAY5  =  195,
+  EC_DELAY6  =  196,
+  EC_DELAY7  =  197,
+  EC_DELAY8  =  198,
+  EC_DELAY9  =  199,
+  EC_DELAY10  =  200,
+  EC_DELAY11  =  201,
+  ECHO_EST  =  202,
+  EC_OUT  =  203,
+  TESTFILT_OUT_1  =  204,
+  TESTFILT_D1_1  =  205,
+  TESTFILT_D2_1  =  206,
+  TESTFILT_OUT_2  =  207,
+  TESTFILT_D1_2  =  208,
+  TESTFILT_D2_2  =  209,
+  TESTFILT_OUT_3  =  210,
+  TESTFILT_D1_3  =  211,
+  TESTFILT_D2_3  =  212,
+  TESTFILT_PEAK  =  213,
+  TESTFILT_ABS  =  214,
+  TESTFILT_MEANACC  =  215,
+  TESTFILT_COUNT  =  216,
+  TESTFILT_NO_OFFSET  =  217,
+  RING_X  =  218,
+  RING_Y  =  219,
+  RING_INT  =  220,
+  RING_Y_D1  =  221,
+  RING_DIFF  =  222,
+  RING_DELTA  =  223,
+  WTCHDOG_CNT  =  224,
+  RING_WAVE  =  225,
+  UNUSED226  =  226,
+  ONEKHZ_COUNT  =  227,
+  TX2100_Y1  =  228,
+  TX2100_Y2  =  229,
+  TX2100_MAG  =  230,
+  RX2100_Y1  =  231,
+  RX2100_Y2  =  232,
+  RX2100_MAG  =  233,
+  TX2100_POWER  =  234,
+  RX2100_POWER  =  235,
+  TX2100_IN  =  236,
+  RX2100_IN  =  237,
+  RINGTRIP_COUNT  =  238,
+  RINGTRIP_DC1  =  239,
+  RINGTRIP_DC2  =  240,
+  RINGTRIP_AC1  =  241,
+  RINGTRIP_AC2  =  242,
+  RINGTRIP_AC_COUNT  =  243,
+  RINGTRIP_DC_COUNT  =  244,
+  RINGTRIP_AC_RESULT  =  245,
+  RINGTRIP_DC_RESULT  =  246,
+  RINGTRIP_ABS  =  247,
+  TXACEQ_OUT  =  248,
+  LCR_DBI_CNT  =  249,
+  BAT_DBI_CNT  =  250,
+  LONG_DBI_CNT  =  251,
+  TXACEQ_DELAY3  =  252,
+  TXACEQ_DELAY2  =  253,
+  TXACEQ_DELAY1  =  254,
+  RXACEQ_DELAY3  =  255,
+  RXACEQ_DELAY2  =  256,
+  RXACEQ_DELAY1  =  257,
+  RXACEQ_IN  =  258,
+  TXDCCOMB_D1  =  259,
+  TXDCCOMB_D2  =  260,
+  TXDCSINC_OUT  =  261,
+  RXACDIFF_D1  =  262,
+  DC_NOTCH_1  =  263,
+  DC_NOTCH_2  =  264,
+  DC_NOTCH_OUT  =  265,
+  DC_NOTCH_SCALED  =  266,
+  V_FEED_IN  =  267,
+  I_TAR  =  268,
+  CONST_VLIM  =  269,
+  UNITY  =  270,
+  TXACNOTCH_1  =  271,
+  TXACNOTCH_2  =  272,
+  TXACNOTCH_OUT  =  273,
+  ZSYNTH_1  =  274,
+  ZSYNTH_2  =  275,
+  ZSYNTH_OUT_1  =  276,
+  TXACD2_1_0  =  277,
+  TXACD2_1_1  =  278,
+  TXACD2_1_2  =  279,
+  TXACD2_1_3  =  280,
+  TXACD2_1_4  =  281,
+  TXACD2_1_5  =  282,
+  TXACD2_1_OUT  =  283,
+  TXACD2_2_0  =  284,
+  TXACD2_2_1  =  285,
+  TXACD2_2_2  =  286,
+  TXACD2_2_3  =  287,
+  TXACD2_2_4  =  288,
+  TXACD2_2_5  =  289,
+  TXACD2_2_OUT  =  290,
+  TXACD2_3_0  =  291,
+  TXACD2_3_1  =  292,
+  TXACD2_3_2  =  293,
+  TXACD2_3_3  =  294,
+  TXACD2_3_4  =  295,
+  TXACD2_3_5  =  296,
+  TXACD2_3_OUT  =  297,
+  RXACI2_1_1  =  298,
+  RXACI2_1_2  =  299,
+  RXACI2_1_3  =  300,
+  RXACI2_1_4  =  301,
+  RXACI2_1_OUT  =  302,
+  RXACI2_2_1  =  303,
+  RXACI2_2_2  =  304,
+  RXACI2_2_3  =  305,
+  RXACI2_2_4  =  306,
+  RXACI2_2_OUT  =  307,
+  RXACI2_3_1  =  308,
+  RXACI2_3_2  =  309,
+  RXACI2_3_3  =  310,
+  RXACI2_3_4  =  311,
+  RXACI2_3_OUT  =  312,
+  TXACCOMP1  =  313,
+  TXACCOMP_OUT  =  314,
+  RXACCOMP1  =  315,
+  RXACCOMP_OUT  =  316,
+  RXACHPF_D1_2  =  317,
+  RXACHPF_D2_1  =  318,
+  RXACHPF_D2_2  =  319,
+  RXACHPF_OUT  =  320,
+  RXACHPF_OUT_1  =  321,
+  RXACHPF_OUT_2  =  322,
+  RXACEQ_OUT  =  323,
+  METER_I_1  =  324,
+  METER_I_OUT  =  325,
+  METER_LPF_1  =  326,
+  METER_LPF_2  =  327,
+  METER_LPF_OUT_1  =  328,
+  METER_BP_1  =  329,
+  METER_BP_2  =  330,
+  METER_BP_OUT  =  331,
+  METER_SRC_OUT  =  332,
+  UNUSED333  =  333,
+  UNUSED334  =  334,
+  RING_LPF_1  =  335,
+  RING_LPF_2  =  336,
+  RING_LPF_OUT  =  337,
+  RING_INTERP_DIFF  =  338,
+  RING_INTERP_DIFF_OUT  =  339,
+  RING_INTERP_INT  =  340,
+  RING_INTERP_INT_OUT  =  341,
+  V_ILIM_TRACK  =  342,
+  V_RFEED_TRACK  =  343,
+  LF_SPEEDUP_CNT  =  344,
+  DC_SPEEDUP_CNT  =  345,
+  AC_SPEEDUP_CNT  =  346,
+  LCR_SPEEDUP_CNT  =  347,
+  CM_SPEEDUP_CNT  =  348,
+  DC_SPEEDUP_MASK  =  349,
+  ZSYNTH_IN  =  350,
+  I_TAR_SAVE  =  351,
+  UNUSED352  =  352,
+  UNUSED353  =  353,
+  COUNTER_VTR  =  354,
+  I_RING_AVG  =  355,
+  COUNTER_IRING  =  356,
+  COMP_RATIO  =  357,
+  MADC_VBAT_DIV2  =  358,
+  VDIFF_PK_T  =  359,
+  PEAK_CNT  =  360,
+  CM_DBI_CNT  =  361,
+  VCM_LAST  =  362,
+  VBATL_SENSE  =  363,
+  VBATH_SENSE  =  364,
+  VBATR_SENSE  =  365,
+  BAT_SETTLE_CNT  =  366,
+  VBAT_TGT  =  367,
+  VBAT_REQ  =  368,
+  VCM_HIRES  =  369,
+  VCM_LORES  =  370,
+  ILOOP1  =  371,
+  ILONG2  =  372,
+  ITIP1  =  373,
+  IRING1  =  374,
+  CAL_TEMP1  =  375,
+  CAL_TEMP2  =  376,
+  CAL_TEMP3  =  377,
+  CAL_TEMP4  =  378,
+  CAL_TEMP5  =  379,
+  CAL_TEMP6  =  380,
+  CAL_TEMP7  =  381,
+  CMRR_DIVISOR  =  382,
+  CMRR_REMAINDER  =  383,
+  CMRR_Q_PTR  =  384,
+  I_SOURCE1  =  385,
+  I_SOURCE2  =  386,
+  VTR1  =  387,
+  VTR2 =  388,
+  STOP_TIMER1  =  389,
+  STOP_TIMER2  =  390,
+  UNUSED391  =  391,
+  UNUSED392  =  392,
+  CAL_ONHK_Z  =  393,
+  CAL_LB_SETTLE  =  394,
+  CAL_DECLPF_V0  =  395,
+  CAL_DECLPF_V1  =  396,
+  CAL_DECLPF_V2  =  397,
+  CAL_GOERTZEL_V0  =  398,
+  CAL_GOERTZEL_V1  =  399,
+  CAL_DECLPF_Y  =  400,
+  CAL_GOERTZEL_Y  =  401,
+  P_HVIC  =  402,
+  VBATL_MIRROR  =  403,
+  VBATH_MIRROR  =  404,
+  VBATR_MIRROR  =  405,
+  DIAG_EX1_OUT  =  406,
+  DIAG_EX2_OUT  =  407,
+  DIAG_DMM_V_OUT  =  408,
+  DIAG_DMM_I_OUT  =  409,
+  DIAG_P  =  410,
+  DIAG_LPF_V  =  411,
+  DIAG_LPF_I  =  412,
+  DIAG_TONE_FLAG  =  413,
+  ILOOP1_LAST  =  414,
+  RING_ENTRY_VOC  =  415,
+  UNUSED416  =  416,
+  OSC1_X_SAVE  =  417,
+  EZSYNTH_1  =  418,
+  EZSYNTH_2  =  419,
+  ZSYNTH_OUT  =  420,
+  UNUSED421  =  421,
+  CAL_SUBSTATE  =  422,
+  DIAG_EX1_DC_OUT  =  423,
+  DIAG_EX1_DC  =  424,
+  EZSYNTH_B1  =  425,
+  EZSYNTH_B2  =  426,
+  EZSYNTH_A1  =  427,
+  EZSYNTH_A2  =  428,
+  ILOOP1_FILT  =  429,
+  AC_PU_DELTA1_CNT  =  430,
+  AC_PU_DELTA2_CNT  =  431,
+  SMART_RING_PHASE  =  432,
+  SMART_RING_PERIOD =  433,
+  SMART_RING_COUNTER =  434,
+  AC_DAC_GAIN_SAVE  =  435,
+  RING_FLUSH_CNT  =  436,
+  RESERVED437  =  437,
+  DIAG_VAR_OUT  =  438,
+  I_VBAT  =  439,
+  P_OFFLOAD  =  440,
+  CALTMP_LOOPCNT  =  441,
+  CALTMP_LOOPINC  =  442,
+  UNUSED443  =  443,
+  CALTMP_CODEINC  =  444,
+  CALTMP_TAUINC  =  445,
+  CALTMP_TAU  =  446,
+  CAL_TEMP8  =  447,
+  PATCH_ID  =  448,
+  UNUSED449  =  449,
+  RESERVED450  =  450,
+  UNUSED451  =  451,
+  CAL_LB_OFFSET_FWD  =  452,
+  CAL_LB_OFFSET_RVS  =  453,
+  COUNT_SPEEDUP  =  454,
+  SWEEP_COUNT  =  455,
+  AMP_RAMP  =  456,
+  DIAG_LPF_MADC_D  =  457,
+  DIAG_HPF_MADC  =  458,
+  UNUSED459  =  459,
+  TXDEC_OUT  =  460,
+  TXDEC_D1  =  461,
+  TXDEC_D2  =  462,
+  RXDEC_D1  =  463,
+  RXDEC_D2  =  464,
+  OSCINT1_D2_1  =  465,
+  OSCINT1_D1_1  =  466,
+  OSCINT1_OUT_1  =  467,
+  OSCINT1_D2_2  =  468,
+  OSCINT1_D1_2  =  469,
+  OSCINT1_OUT  =  470,
+  OSCINT2_D2_1  =  471,
+  OSCINT2_D1_1  =  472,
+  OSCINT2_OUT_1  =  473,
+  OSCINT2_D2_2  =  474,
+  OSCINT2_D1_2  =  475,
+  OSCINT2_OUT  =  476,
+  OSC1_Y_SAVE  =  477,
+  OSC2_Y_SAVE  =  478,
+  PWRSAVE_CNT  =  479,
+  VBATR_PK  =  480,
+  SPEEDUP_MASK_CNT  =  481,
+  VCM_RING_FIXED  =  482,
+  DELTA_VCM  =  483,
+  MADC_VTIPC_DIAG_OS  =  484,
+  MADC_VRINGC_DIAG_OS  =  485,
+  MADC_VLONG_DIAG_OS  =  486,
+  INIT_GUESS  =  487,
+  Y1  =  488,
+  Y2  =  489,
+  Y3  =  490,
+  UNUSED491  =  491,
+  PWRSAVE_DBI_CNT  =  492,
+  COMP_RATIO_SAVE  =  493,
+  CAL_TEMP9  =  494,
+  CAL_TEMP10  =  495,
+  DAC_OFFSET_TEMP =  496,
+  CAL_DAC_CODE  =  497,
+  DCDAC_OFFSET  =  498,
+  VDIFF_COARSE  =  499,
+  RXACIIR_OUT_4  =  500,
+  CAL_TEMP11  =  501,
+  METER_RAMP =  502,
+  METER_RAMP_DIR  =  503,
+  METER_ON_T  =  504,
+  METER_PK_DET  =  505,
+  METER_PK_DET_T =  506,
+  THERM_CNT  =  507,
+  VDIFF_SENSE_DELAY  =  508,
+  UNUSED509 =  509,
+  CPUMP_DEB_CNT  =  510,
+  UNUSED511  =  511,
+  MINUS_ONE  =  512,
+  ILOOPLPF  =  513,
+  ILONGLPF  =  514,
+  BATLPF  =  515,
+  VDIFFLPF  =  516,
+  VCMLPF  =  517,
+  TXACIIR_B0_1  =  518,
+  TXACIIR_B1_1  =  519,
+  TXACIIR_A1_1  =  520,
+  TXACIIR_B0_2  =  521,
+  TXACIIR_B1_2  =  522,
+  TXACIIR_B2_2  =  523,
+  TXACIIR_A1_2  =  524,
+  TXACIIR_A2_2  =  525,
+  TXACIIR_B0_3  =  526,
+  TXACIIR_B1_3  =  527,
+  TXACIIR_B2_3  =  528,
+  TXACIIR_A1_3  =  529,
+  TXACIIR_A2_3  =  530,
+  TXACHPF_B0_1  =  531,
+  TXACHPF_B1_1  =  532,
+  TXACHPF_A1_1  =  533,
+  TXACHPF_B0_2  =  534,
+  TXACHPF_B1_2  =  535,
+  TXACHPF_B2_2  =  536,
+  TXACHPF_A1_2  =  537,
+  TXACHPF_A2_2  =  538,
+  TXACHPF_GAIN  =  539,
+  TXACEQ_C0  =  540,
+  TXACEQ_C1  =  541,
+  TXACEQ_C2  =  542,
+  TXACEQ_C3  =  543,
+  TXACGAIN  =  544,
+  RXACGAIN  =  545,
+  RXACEQ_C0  =  546,
+  RXACEQ_C1  =  547,
+  RXACEQ_C2  =  548,
+  RXACEQ_C3  =  549,
+  RXACIIR_B0_1  =  550,
+  RXACIIR_B1_1  =  551,
+  RXACIIR_A1_1  =  552,
+  RXACIIR_B0_2  =  553,
+  RXACIIR_B1_2  =  554,
+  RXACIIR_B2_2  =  555,
+  RXACIIR_A1_2  =  556,
+  RXACIIR_A2_2  =  557,
+  RXACIIR_B0_3  =  558,
+  RXACIIR_B1_3  =  559,
+  RXACIIR_B2_3  =  560,
+  RXACIIR_A1_3  =  561,
+  RXACIIR_A2_3  =  562,
+  ECFIR_C2  =  563,
+  ECFIR_C3  =  564,
+  ECFIR_C4  =  565,
+  ECFIR_C5  =  566,
+  ECFIR_C6  =  567,
+  ECFIR_C7  =  568,
+  ECFIR_C8  =  569,
+  ECFIR_C9  =  570,
+  ECIIR_B0  =  571,
+  ECIIR_B1  =  572,
+  ECIIR_A1  =  573,
+  ECIIR_A2  =  574,
+  DTMFDTF_B0_1  =  575,
+  DTMFDTF_B1_1  =  576,
+  DTMFDTF_B2_1  =  577,
+  DTMFDTF_A1_1  =  578,
+  DTMFDTF_A2_1  =  579,
+  DTMFDTF_B0_2  =  580,
+  DTMFDTF_B1_2  =  581,
+  DTMFDTF_B2_2  =  582,
+  DTMFDTF_A1_2  =  583,
+  DTMFDTF_A2_2  =  584,
+  DTMFDTF_B0_3  =  585,
+  DTMFDTF_B1_3  =  586,
+  DTMFDTF_B2_3  =  587,
+  DTMFDTF_A1_3  =  588,
+  DTMFDTF_A2_3  =  589,
+  DTMFDTF_GAIN  =  590,
+  DTMFLPF_B0_1  =  591,
+  DTMFLPF_B1_1  =  592,
+  DTMFLPF_B2_1  =  593,
+  DTMFLPF_A1_1  =  594,
+  DTMFLPF_A2_1  =  595,
+  DTMFLPF_B0_2  =  596,
+  DTMFLPF_B1_2  =  597,
+  DTMFLPF_B2_2  =  598,
+  DTMFLPF_A1_2  =  599,
+  DTMFLPF_A2_2  =  600,
+  DTMFLPF_GAIN  =  601,
+  DTMFHPF_B0_1  =  602,
+  DTMFHPF_B1_1  =  603,
+  DTMFHPF_B2_1  =  604,
+  DTMFHPF_A1_1  =  605,
+  DTMFHPF_A2_1  =  606,
+  DTMFHPF_B0_2  =  607,
+  DTMFHPF_B1_2  =  608,
+  DTMFHPF_B2_2  =  609,
+  DTMFHPF_A1_2  =  610,
+  DTMFHPF_A2_2  =  611,
+  DTMFHPF_GAIN  =  612,
+  POWER_GAIN  =  613,
+  GOERTZEL_GAIN  =  614,
+  MODEM_GAIN  =  615,
+  HOTBIT1  =  616,
+  HOTBIT0  =  617,
+  ROW0_C1  =  618,
+  ROW1_C1  =  619,
+  ROW2_C1  =  620,
+  ROW3_C1  =  621,
+  COL0_C1  =  622,
+  COL1_C1  =  623,
+  COL2_C1  =  624,
+  COL3_C1  =  625,
+  ROW0_C2  =  626,
+  ROW1_C2  =  627,
+  ROW2_C2  =  628,
+  ROW3_C2  =  629,
+  COL0_C2  =  630,
+  COL1_C2  =  631,
+  COL2_C2  =  632,
+  COL3_C2  =  633,
+  SLOPE_VLIM  =  634,
+  SLOPE_RFEED  =  635,
+  SLOPE_ILIM  =  636,
+  SLOPE_RING  =  637,
+  SLOPE_DELTA1  =  638,
+  SLOPE_DELTA2  =  639,
+  V_VLIM  =  640,
+  V_RFEED  =  641,
+  V_ILIM  =  642,
+  CONST_RFEED  =  643,
+  CONST_ILIM  =  644,
+  I_VLIM  =  645,
+  DC_DAC_GAIN  =  646,
+  VDIFF_TH  =  647,
+  TXDEC_B0  =  648,
+  TXDEC_B1  =  649,
+  TXDEC_B2  =  650,
+  TXDEC_A1  =  651,
+  TXDEC_A2  =  652,
+  ZSYNTH_B0  =  653,
+  ZSYNTH_B1  =  654,
+  ZSYNTH_B2  =  655,
+  ZSYNTH_A1  =  656,
+  ZSYNTH_A2  =  657,
+  RXACHPF_B0_1  =  658,
+  RXACHPF_B1_1  =  659,
+  RXACHPF_A1_1  =  660,
+  RXACHPF_B0_2  =  661,
+  RXACHPF_B1_2  =  662,
+  RXACHPF_B2_2  =  663,
+  RXACHPF_A1_2  =  664,
+  RXACHPF_A2_2  =  665,
+  RXACHPF_GAIN  =  666,
+  MASK7LSB  =  667,
+  RXDEC_B0  =  668,
+  RXDEC_B1  =  669,
+  RXDEC_B2  =  670,
+  RXDEC_A1  =  671,
+  RXDEC_A2  =  672,
+  OSCINT1_B0_1  =  673,
+  OSCINT1_B1_1  =  674,
+  OSCINT1_B2_1  =  675,
+  OSCINT1_A1_1  =  676,
+  OSCINT1_A2_1  =  677,
+  OSCINT1_B0_2  =  678,
+  OSCINT1_B1_2  =  679,
+  OSCINT1_B2_2  =  680,
+  OSCINT1_A1_2  =  681,
+  OSCINT1_A2_2  =  682,
+  OSCINT2_B0_1  =  683,
+  OSCINT2_B1_1  =  684,
+  OSCINT2_B2_1  =  685,
+  OSCINT2_A1_1  =  686,
+  OSCINT2_A2_1  =  687,
+  OSCINT2_B0_2  =  688,
+  OSCINT2_B1_2  =  689,
+  OSCINT2_B2_2  =  690,
+  OSCINT2_A1_2  =  691,
+  OSCINT2_A2_2  =  692,
+  UNUSED693  =  693,
+  UNUSED694  =  694,
+  UNUSED695  =  695,
+  RING_LPF_B0  =  696,
+  RING_LPF_B1  =  697,
+  RING_LPF_B2  =  698,
+  RING_LPF_A1  =  699,
+  RING_LPF_A2  =  700,
+  LCRDBI  =  701,
+  LONGDBI  =  702,
+  VBAT_TIMER  =  703,
+  LF_SPEEDUP_TIMER  =  704,
+  DC_SPEEDUP_TIMER  =  705,
+  AC_SPEEDUP_TIMER  =  706,
+  LCR_SPEEDUP_TIMER  =  707,
+  CM_SPEEDUP_TIMER  =  708,
+  VCM_TH  =  709,
+  AC_SPEEDUP_TH  =  710,
+  SPR_SIG_0  =  711,
+  SPR_SIG_1  =  712,
+  SPR_SIG_2  =  713,
+  SPR_SIG_3  =  714,
+  SPR_SIG_4  =  715,
+  SPR_SIG_5  =  716,
+  SPR_SIG_6  =  717,
+  SPR_SIG_7  =  718,
+  SPR_SIG_8  =  719,
+  SPR_SIG_9  =  720,
+  SPR_SIG_10  =  721,
+  SPR_SIG_11  =  722,
+  SPR_SIG_12  =  723,
+  SPR_SIG_13  =  724,
+  SPR_SIG_14  =  725,
+  SPR_SIG_15  =  726,
+  SPR_SIG_16  =  727,
+  SPR_SIG_17  =  728,
+  SPR_SIG_18  =  729,
+  COUNTER_VTR_VAL  =  730,
+  CONST_028  =  731,
+  CONST_032  =  732,
+  CONST_038  =  733,
+  CONST_046  =  734,
+  COUNTER_IRING_VAL  =  735,
+  GAIN_RING  =  736,
+  RING_HYST  =  737,
+  COMP_Z  =  738,
+  CONST_115  =  739,
+  CONST_110  =  740,
+  CONST_105  =  741,
+  CONST_100  =  742,
+  CONST_095  =  743,
+  CONST_090  =  744,
+  CONST_085  =  745,
+  V_RASUM_IDEAL  =  746,
+  CONST_ONE  =  747,
+  VCM_OH  =  748,
+  VCM_RING  =  749,
+  VCM_HYST  =  750,
+  VOV_GND  =  751,
+  VOV_BAT  =  752,
+  VOV_RING_BAT  =  753,
+  CM_DBI  =  754,
+  RTPER  =  755,
+  P_TH_HVIC  =  756,
+  UNUSED757  =  757,
+  UNUSED758  =  758,
+  COEF_P_HVIC  =  759,
+  COEF_Q1256  =  760,
+  UNUSED761  =  761,
+  UNUSED762  =  762,
+  UNUSED763  =  763,
+  BAT_HYST  =  764,
+  BAT_DBI  =  765,
+  VBATL_EXPECT  =  766,
+  VBATH_EXPECT  =  767,
+  VBATR_EXPECT  =  768,
+  BAT_SETTLE  =  769,
+  VBAT_IRQ_TH  =  770,
+  MADC_VTIPC_OS  =  771,
+  MADC_VRINGC_OS  =  772,
+  MADC_VBAT_OS  =  773,
+  MADC_VLONG_OS  =  774,
+  UNUSED775  =  775,
+  MADC_VDC_OS  =  776,
+  MADC_ILONG_OS  =  777,
+  UNUSED778  =  778,
+  UNUSED779  =  779,
+  MADC_ILOOP_OS  =  780,
+  MADC_SCALE_ILOOP  =  781,
+  UNUSED782  =  782,
+  UNUSED783  =  783,
+  DC_ADC_OS  =  784,
+  CAL_UNITY  =  785,
+  UNUSED786  =  786,
+  UNUSED787  =  787,
+  ACADC_OFFSET  =  788,
+  ACDAC_OFFSET  =  789,
+  CAL_DCDAC_CODE  =  790,
+  CAL_DCDAC_15MA  =  791,
+  UNUSED792  =  792,
+  UNUSED793  =  793,
+  UNUSED794  =  794,
+  UNUSED795  =  795,
+  UNUSED796  =  796,
+  UNUSED797  =  797,
+  UNUSED798  =  798,
+  UNUSED799  =  799,
+  UNUSED800  =  800,
+  CAL_LB_TSQUELCH  =  801,
+  CAL_LB_TCHARGE  =  802,
+  CAL_LB_TSETTLE0  =  803,
+  CAL_GOERTZEL_DLY  =  804,
+  CAL_GOERTZEL_ALPHA  =  805,
+  CAL_DECLPF_K  =  806,
+  CAL_DECLPF_B1  =  807,
+  CAL_DECLPF_B2  =  808,
+  CAL_DECLPF_A1  =  809,
+  CAL_DECLPF_A2  =  810,
+  CAL_ACADC_THRL  =  811,
+  CAL_ACADC_THRH  =  812,
+  CAL_ACADC_TSETTLE  =  813,
+  DTROW0TH  =  814,
+  DTROW1TH  =  815,
+  DTROW2TH  =  816,
+  DTROW3TH  =  817,
+  DTCOL0TH  =  818,
+  DTCOL1TH  =  819,
+  DTCOL2TH  =  820,
+  DTCOL3TH  =  821,
+  DTFTWTH  =  822,
+  DTRTWTH  =  823,
+  DTROWRTH  =  824,
+  DTCOLRTH  =  825,
+  DTROW2HTH  =  826,
+  DTCOL2HTH  =  827,
+  DTMINPTH  =  828,
+  DTHOTTH  =  829,
+  RXPWR  =  830,
+  TXPWR  =  831,
+  RXMODPWR  =  832,
+  TXMODPWR  =  833,
+  FSKFREQ0  =  834,
+  FSKFREQ1  =  835,
+  FSKAMP0  =  836,
+  FSKAMP1  =  837,
+  FSK01  =  838,
+  FSK10  =  839,
+  VOCDELTA  =  840,
+  VOCLTH  =  841,
+  VOCHTH  =  842,
+  RINGOF  =  843,
+  RINGFR  =  844,
+  RINGAMP  =  845,
+  RINGPHAS  =  846,
+  RTDCTH  =  847,
+  RTACTH  =  848,
+  RTDCDB  =  849,
+  RTACDB  =  850,
+  RTCOUNT  =  851,
+  LCROFFHK  =  852,
+  LCRONHK  =  853,
+  LCRMASK  =  854,
+  LCRMASK_POLREV  =  855,
+  LCRMASK_STATE  =  856,
+  LCRMASK_LINECAP  =  857,
+  LONGHITH  =  858,
+  LONGLOTH  =  859,
+  IRING_LIM  =  860,
+  AC_PU_DELTA1  =  861,
+  AC_PU_DELTA2  =  862,
+  DIAG_LPF_8K  =  863,
+  DIAG_LPF_128K  =  864,
+  DIAG_INV_N  =  865,
+  DIAG_GAIN  =  866,
+  DIAG_G_CAL  =  867,
+  DIAG_OS_CAL  =  868,
+  SPR_GAIN_TRIM  =  869,
+  UNUSED870  =  870,
+  AC_DAC_GAIN  =  871,
+  UNUSED872  =  872,
+  UNUSED873  =  873,
+  AC_DAC_GAIN0  =  874,
+  EZSYNTH_B0  =  875,
+  OFFLD_DAC_SCALE  =  876,
+  UNUSED877  =  877,
+  OFFLD_DAC_OS  =  878,
+  UNUSED879  =  879,
+  AC_ADC_GAIN  =  880,
+  ILOOP1LPF  =  881,
+  RING_FLUSH_TIMER  =  882,
+  ALAW_BIAS  =  883,
+  MADC_VTRC_SCALE  =  884,
+  MADC_VBAT_SCALE  =  885,
+  UNUSED886  =  886,
+  MADC_VLONG_SCALE  =  887,
+  MADC_VLONG_SCALE_RING  =  888,
+  UNUSED889  =  889,
+  MADC_VDC_SCALE  =  890,
+  MADC_ILONG_SCALE  =  891,
+  UNUSED892  =  892,
+  UNUSED893  =  893,
+  VDIFF_SENSE_SCALE  =  894,
+  VDIFF_SENSE_SCALE_RING  =  895,
+  VOV_RING_GND  =  896,
+  P_TH_OFFLOAD  =  897,
+  CAL_LB_OSC1_FREQ  =  898,
+  CAL_DCDAC_9TAU  =  899,
+  CAL_MADC_9TAU  =  900,
+  ADAP_RING_MIN_I  =  901,
+  SWEEP_STEP  =  902,
+  SWEEP_STEP_SAVE  =  903,
+  SWEEP_REF  =  904,
+  AMP_STEP  =  905,
+  RXACGAIN_SAVE  =  906,
+  AMP_RAMP_INIT  =  907,
+  DIAG_HPF_GAIN  =  908,
+  DIAG_HPF_8K  =  909,
+  DIAG_ADJ_STEP  =  910,
+  UNUSED911  =  911,
+  UNUSED912  =  912,
+  MADC_SCALE_INV  =  913,
+  UNUSED914  =  914,
+  PWRSAVE_TIMER  =  915,
+  OFFHOOK_THRESH  =  916,
+  SPEEDUP_MASK_TIMER  =  917,
+  XTALK_TIMER  =  918,
+  VBAT_TRACK_MIN  =  919,
+  VBAT_TRACK_MIN_RNG  =  920,
+  UNUSED921  =  921,
+  UNUSED922  =  922,
+  UNUSED923  =  923,
+  UNUSED924  =  924,
+  UNUSED925 =  925,
+  UNUSED926  =  926,
+  DC_HOLD_DAC_OS  =  927,
+  DAA_DTMF_IN_SCALE  =  928,
+  NOTCH_B0  =  929,
+  NOTCH_B1  =  930,
+  NOTCH_B2  =  931,
+  NOTCH_A1  =  932,
+  NOTCH_A2  =  933,
+  METER_LPF_B0  =  934,
+  METER_LPF_B1  =  935,
+  METER_LPF_B2  =  936,
+  METER_LPF_A1  =  937,
+  METER_LPF_A2  =  938,
+  METER_SIG_0  =  939,
+  METER_SIG_1  =  940,
+  METER_SIG_2  =  941,
+  METER_SIG_3  =  942,
+  METER_SIG_4  =  943,
+  METER_SIG_5  =  944,
+  METER_SIG_6  =  945,
+  METER_SIG_7  =  946,
+  METER_SIG_8  =  947,
+  METER_SIG_9  =  948,
+  METER_SIG_10  =  949,
+  METER_SIG_11  =  950,
+  METER_SIG_12  =  951,
+  METER_SIG_13  =  952,
+  METER_SIG_14  =  953,
+  METER_SIG_15  =  954,
+  METER_BP_B0  =  955,
+  METER_BP_B1  =  956,
+  METER_BP_B2  =  957,
+  METER_BP_A1  =  958,
+  METER_BP_A2  =  959,
+  PM_AMP_THRESH  =  960,
+  PM_GAIN  =  961,
+  PWRSAVE_DBI  =  962,
+  DCDC_ANA_SCALE  =  963,
+  VOV_BAT_PWRSAVE_LO  =  964,
+  VOV_BAT_PWRSAVE_HI  =  965,
+  AC_ADC_GAIN0  =  966,
+  SCALE_KAUDIO  =  967,
+  METER_GAIN_TEMP  =  968,
+  METER_RAMP_STEP  =  969,
+  THERM_DBI  =  970,
+  LPR_SCALE =  971,
+  LPR_CM_OS =  972,
+  VOV_DCDC_SLOPE  =  973,
+  VOV_DCDC_OS  =  974,
+  VOV_RING_BAT_MAX  =  975,
+  SLOPE_VLIM1 =  976,
+  SLOPE_RFEED1  =  977,
+  SLOPE_ILIM1  =  978,
+  V_VLIM1  =  979,
+  V_RFEED1  =  980,
+  V_ILIM1  =  981,
+  CONST_RFEED1 =  982,
+  CONST_ILIM1 =  983,
+  I_VLIM1  =  984,
+  SLOPE_VLIM2 =  985,
+  SLOPE_RFEED2  =  986,
+  SLOPE_ILIM2  =  987,
+  V_VLIM2  =  988,
+  V_RFEED2  =  989,
+  V_ILIM2 =  990,
+  CONST_RFEED2  =  991,
+  CONST_ILIM2  =  992,
+  I_VLIM2  =  993,
+  DIAG_V_TAR  =  994,
+  DIAG_V_TAR2  =  995,
+  STOP_TIMER1_VAL =  996,
+  STOP_TIMER2_VAL =  997,
+  DIAG_VCM1_TAR  =  998,
+  DIAG_VCM_STEP  =  999,
+  LKG_DNT_HIRES  =  1000,
+  LKG_DNR_HIRES  =  1001,
+  LINEAR_OS  =  1002,
+  CPUMP_DEB =  1003,
+  DCDC_VERR  =  1004,
+  DCDC_VERR_HYST  =  1005,
+  DCDC_OITHRESH_LO  =  1006,
+  DCDC_OITHRESH_HI =  1007,
+  HV_BIAS_ONHK  =  1008,
+  HV_BIAS_OFFHK  =  1009,
+  UVTHRESH_BIAS = 1010,
+  UVTHRESH_SCALE = 1011,
+  UVTHRESH_MAX = 1012,
+  VBATH_DELTA = 1013,
+  UNUSED1014 = 1014,
+  VOV_RING_BAT_DCDC = 1015,
+  P_OFFLOAD_VBAT_HYST = 1016,
+  LKG_LB_OFFSET = 1017,
+  LKG_OFHK_OFFSET = 1018
+};
+
+/*
+** This defines the mnemonics for applicable SI3228X Memory-mapped register locations
+*/
+enum
+{
+  PD_BIAS = 1413,
+  PD_VBAT_SNS = 1418,
+  PD_HVIC = 1430,
+  MADC_LOOP_MAN = 1445,
+  HVIC_CNTL_MAN = 1451,
+  CAL_TRNRD_DACT = 1458,
+  CAL_TRNRD_DACR,
+  CMDAC_FWD = 1476,
+  CMDAC_REV,
+  RDC_SUM = 1499,
+  PD_OFFLD_DAC = 1512,
+  PD_OFFLD_GM = 1513,
+  PD_DCDC = 1538,
+  PD_UVLO = 1540,
+  PD_OVLO,
+  PD_OCLO,
+  DCDC_UVHYST = 1545,
+  DCDC_UVTHRESH,
+  DCDC_OVTHRESH = 1547,
+  DCDC_OITHRESH,
+  UNUSED1549,
+  DCDC_CCM_THRESH,
+  DCDC_STATUS,
+  DCDC_FSW,
+  DCDC_SWDRV_POL,
+  DCDC_UVPOL,
+  DCDC_CPUMP,
+  UNUSED1556,
+  UNUSED1557,
+  DCDC_VREF_CTRL,
+  UNUSED1559,
+  DCDC_RNGTYPE,
+  DCDC_DCFF_ENABLE = 1635,
+  DCDC_OIMASK = 1565,
+  PD_REF_OSC = 1571,
+  PWRSAVE_CTRL_LO = 1575,
+  DCDC_ANA_GAIN = 1585,
+  DCDC_ANA_TOFF,
+  DCDC_ANA_TONMIN,
+  DCDC_ANA_TONMAX,
+  DCDC_ANA_DSHIFT,
+  DCDC_ANA_LPOLY,
+  DCDC_PD_ANA = 1592,
+  PATCH_JMP8 = 1597,
+  PM_ACTIVE = 1606,
+  PM_INACTIVE = 1607,
+  DCDC_CPUMP_LP_MASK = 1616,
+  DCDC_UV_MAN = 1640,
+  DCDC_UV_DEBOUNCE = 1641,
+  DCDC_OV_MAN = 1642,
+  DCDC_OV_DEBOUNCE = 1643,
+  OFFLD_DAC_MAN = 1646
+};
+
+
+/* Temporarily map obsolete ram locations for debug purposes */
+#define DCDC_FSW_NORM       UNUSED921
+#define DCDC_FSW_NORM_LO    UNUSED922
+#define DCDC_DIN_LIM        UNUSED925
+#define DCDC_FSW_RING       UNUSED923
+#define DCDC_FSW_RING_LO    UNUSED924
+#define DCDC_VOUT_LIM       UNUSED926
+#define DCDC_FSW_VHYST      Y3
+#define DCDC_FSW_VTHLO      Y2
+#define DAA_CNTL            74
+#define DCDC_VREF_MIN       VBAT_TRACK_MIN
+#define DCDC_VREF_MIN_RNG   VBAT_TRACK_MIN_RNG
+
+
+#endif
+
Index: linux-5.4.171/sound/soc/codecs/si3218x/modules.builtin
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-5.4.171/sound/soc/codecs/si3218x/modules.builtin	2022-02-22 11:57:54.000000000 +0800
@@ -0,0 +1,15 @@
+sound/soc/codecs/si3218x/src/proslic.ko
+sound/soc/codecs/si3218x/src/proslic_tstin.ko
+sound/soc/codecs/si3218x/src/si_voice.ko
+sound/soc/codecs/si3218x/src/si_voice_version.ko
+sound/soc/codecs/si3218x/src/si3218x_intf.ko
+sound/soc/codecs/si3218x/src/si3226x_intf.ko
+sound/soc/codecs/si3218x/src/si3228x_intf.ko
+sound/soc/codecs/si3218x/src/vdaa.ko
+sound/soc/codecs/si3218x/src/vdaa_constants.ko
+sound/soc/codecs/si3218x/src/si3218x_LCCB_constants.ko
+sound/soc/codecs/si3218x/src/si3226x_FLBK_constants.ko
+sound/soc/codecs/si3218x/src/si3228x_LCCB_constants.ko
+sound/soc/codecs/si3218x/patch_files/si3226x_patch_C_FB_2017MAY26.ko
+sound/soc/codecs/si3218x/patch_files/si3228x_patch_A_2017MAY26.ko
+sound/soc/codecs/si3218x/snd-soc-si3218x.ko
Index: linux-5.4.171/sound/soc/codecs/si3218x/modules.order
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-5.4.171/sound/soc/codecs/si3218x/modules.order	2022-02-23 11:02:29.171064570 +0800
@@ -0,0 +1,1 @@
+
Index: linux-5.4.171/sound/soc/codecs/si3218x/patch_files/si3226x_patch_C_FB_2017MAY26.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-5.4.171/sound/soc/codecs/si3218x/patch_files/si3226x_patch_C_FB_2017MAY26.c	2022-02-22 10:59:24.000000000 +0800
@@ -0,0 +1,279 @@
+/*
+** Patch:  si3226x_patch_C_FB_2017MAY26.c
+** Copyright 2017, Silicon Labs
+**
+** Generated from si3226x_patch_C_FB_2017MAY26.dsp_prom
+** on 05-26-2017 at 11:2:55
+** Patch ID = 0x05262017L
+**
+** This file contains proprietary information.
+** No dissemination allowed without prior written permission from
+** Silicon Laboratories, Inc.
+*/
+#include "../config_inc/si_voice_datatypes.h"
+#include "../inc/si3226x.h"
+
+static const uInt32 patchData [] = {
+141541L,
+540867L,
+141541L,
+543427L,
+141541L,
+553155L,
+141541L,
+577731L,
+141541L,
+579779L,
+141541L,
+581315L,
+141541L,
+590531L,
+141541L,
+595139L,
+141541L,
+597187L,
+141541L,
+608451L,
+141541L,
+618691L,
+141541L,
+619203L,
+141541L,
+619715L,
+141541L,
+620227L,
+141541L,
+620739L,
+141541L,
+621251L,
+736L,
+491712L,
+452200L,
+141541L,
+491200L,
+5733L,
+524290L,
+142565L,
+550083L,
+3685L,
+519266L,
+5220L,
+144098L,
+550083L,
+3685L,
+524291L,
+141541L,
+551619L,
+5221L,
+3682L,
+524292L,
+5L,
+141541L,
+135362L,
+98021L,
+727745L,
+474213L,
+17637L,
+557251L,
+101093L,
+557251L,
+473701L,
+515653L,
+843365L,
+188002L,
+843355L,
+145125L,
+560835L,
+524290L,
+660069L,
+518053L,
+517224L,
+518244L,
+142565L,
+564419L,
+524288L,
+521733L,
+843365L,
+188002L,
+524315L,
+145125L,
+568003L,
+843365L,
+522850L,
+523387L,
+147685L,
+573123L,
+522363L,
+145125L,
+575171L,
+521826L,
+141541L,
+575683L,
+518757L,
+521826L,
+141541L,
+575683L,
+521824L,
+522245L,
+522338L,
+141541L,
+716481L,
+173669L,
+523845L,
+141541L,
+730304L,
+523877L,
+141541L,
+690368L,
+457221L,
+558181L,
+457122L,
+457333L,
+143077L,
+588995L,
+524290L,
+144608L,
+587459L,
+524292L,
+141541L,
+588483L,
+524290L,
+524304L,
+671749L,
+437349L,
+141541L,
+98498L,
+560741L,
+524290L,
+143584L,
+593603L,
+141541L,
+191682L,
+694789L,
+141541L,
+859842L,
+171109L,
+170565L,
+141541L,
+963776L,
+524291L,
+144613L,
+599235L,
+199685L,
+667365L,
+602307L,
+431717L,
+197189L,
+136805L,
+198725L,
+170597L,
+262242L,
+524291L,
+144613L,
+605379L,
+170501L,
+667365L,
+886464L,
+136805L,
+180293L,
+141541L,
+886464L,
+558181L,
+410018L,
+539765L,
+143077L,
+616643L,
+355746L,
+539765L,
+143072L,
+613571L,
+767493L,
+356258L,
+407477L,
+143073L,
+616643L,
+767493L,
+539749L,
+743525L,
+119426L,
+141541L,
+1003201L,
+524293L,
+524293L,
+524293L,
+524293L,
+524293L,
+524293L,
+0L
+};
+
+static const uInt16 patchEntries [] = {
+950,
+4347,
+3431,
+1425,
+1347,
+4287,
+4469,
+1881,
+1720,
+4006,
+0,
+0,
+0,
+0,
+0,
+0
+};
+
+static const uInt16 patchSupportAddr [] = {
+800,
+694,
+695,
+795,
+914,
+892,
+893,
+925,
+926,
+1014,
+1020,
+1021,
+1022,
+333,
+334,
+352,
+0
+};
+
+static const uInt32 patchSupportData [] = {
+0x200000L,
+0x80000L,
+0x200000L,
+0x180000L,
+0x784B2AFL,
+0x400000L,
+0x0L,
+0xA00000L,
+0x1F00000L,
+0x2D8000L,
+0x0L,
+0x1A9FBDAL,
+0x1C28F4EL,
+0x0L,
+0x0L,
+0x0L,
+0x0L
+};
+
+#ifdef SIVOICE_MULTI_BOM_SUPPORT
+const proslicPatch si3226xPatchRevCFlbk = {
+#else
+const proslicPatch RevCPatch = {
+#endif
+    patchData,
+    patchEntries,
+    0x05262017L,
+    patchSupportAddr,
+    patchSupportData
+};
Index: linux-5.4.171/sound/soc/codecs/si3218x/patch_files/si3228x_patch_A_2017MAY26.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-5.4.171/sound/soc/codecs/si3218x/patch_files/si3228x_patch_A_2017MAY26.c	2022-02-22 10:59:24.000000000 +0800
@@ -0,0 +1,475 @@
+/*
+** Patch:  si3228x_patch_A_2017MAY26.c
+** Copyright 2017, Silicon Labs
+**
+** Generated from si3228x_patch_A_2017MAY26.dsp_prom
+** on 05-26-2017 at 10:57:39
+** Patch ID = 0x05262017L
+**
+** This file contains proprietary information.
+** No dissemination allowed without prior written permission from
+** Silicon Laboratories, Inc.
+*/
+#include "../config_inc/si_voice_datatypes.h"
+#include "../inc/si3228x.h"
+
+static const uInt32 patchData [] = {
+141541L,
+540867L,
+141541L,
+543427L,
+141541L,
+553667L,
+141541L,
+562883L,
+141541L,
+567491L,
+141541L,
+569539L,
+141541L,
+580803L,
+141541L,
+586435L,
+141541L,
+594115L,
+141541L,
+603843L,
+141541L,
+605891L,
+141541L,
+607427L,
+141541L,
+609475L,
+141541L,
+611011L,
+141541L,
+718531L,
+141541L,
+721603L,
+736L,
+491712L,
+452200L,
+141541L,
+491200L,
+558181L,
+410018L,
+539765L,
+143077L,
+551619L,
+355746L,
+539765L,
+143072L,
+548547L,
+767493L,
+356258L,
+407477L,
+143073L,
+551619L,
+767493L,
+539749L,
+743525L,
+119426L,
+141541L,
+1003201L,
+457221L,
+558181L,
+457122L,
+457333L,
+143077L,
+561347L,
+524290L,
+144608L,
+559811L,
+524292L,
+141541L,
+560835L,
+524290L,
+524304L,
+671749L,
+437349L,
+141541L,
+98498L,
+560741L,
+524290L,
+143584L,
+565955L,
+141541L,
+191682L,
+694789L,
+141541L,
+859842L,
+171109L,
+170565L,
+141541L,
+963776L,
+524291L,
+144613L,
+571587L,
+199685L,
+667365L,
+574659L,
+431717L,
+197189L,
+136805L,
+198725L,
+170597L,
+262242L,
+524291L,
+144613L,
+577731L,
+170501L,
+667365L,
+886464L,
+136805L,
+180293L,
+141541L,
+886464L,
+9733L,
+136805L,
+116130L,
+524304L,
+660069L,
+440424L,
+9827L,
+660066L,
+524315L,
+141541L,
+673984L,
+524389L,
+117890L,
+278677L,
+143077L,
+589507L,
+113280L,
+694785L,
+272518L,
+524309L,
+829441L,
+828933L,
+694789L,
+216165L,
+141541L,
+217282L,
+5733L,
+524290L,
+142565L,
+600771L,
+3685L,
+519266L,
+5220L,
+144098L,
+600771L,
+3685L,
+524291L,
+141541L,
+602307L,
+5221L,
+3682L,
+524292L,
+5L,
+141541L,
+135362L,
+173669L,
+523845L,
+141541L,
+730304L,
+523877L,
+141541L,
+690368L,
+657509L,
+7749L,
+141541L,
+2752L,
+7781L,
+141541L,
+6848L,
+524389L,
+60645L,
+715971L,
+46821L,
+715971L,
+558181L,
+410018L,
+524405L,
+143589L,
+1041601L,
+244354L,
+259221L,
+524294L,
+524294L,
+660087L,
+143077L,
+621763L,
+263810L,
+524311L,
+143584L,
+1041601L,
+536293L,
+628931L,
+683525L,
+575717L,
+629955L,
+263813L,
+524289L,
+223749L,
+211557L,
+524290L,
+142053L,
+633027L,
+141541L,
+661699L,
+11488L,
+656067L,
+223840L,
+263813L,
+524289L,
+524292L,
+143589L,
+655043L,
+132837L,
+641219L,
+268933L,
+694789L,
+674309L,
+222309L,
+674309L,
+694785L,
+221283L,
+524292L,
+143077L,
+648899L,
+263813L,
+524289L,
+141541L,
+653507L,
+268933L,
+694789L,
+674309L,
+222309L,
+674309L,
+694785L,
+221283L,
+221795L,
+524292L,
+143077L,
+648899L,
+263813L,
+524289L,
+141541L,
+653507L,
+195205L,
+524289L,
+694789L,
+674309L,
+116229L,
+674309L,
+694784L,
+222213L,
+842757L,
+223749L,
+141541L,
+689859L,
+630496L,
+661699L,
+222213L,
+842757L,
+694789L,
+674309L,
+222213L,
+674309L,
+694789L,
+11493L,
+19650L,
+106213L,
+689859L,
+112741L,
+263810L,
+142561L,
+664259L,
+230400L,
+230501L,
+112738L,
+143074L,
+668355L,
+144608L,
+668355L,
+230405L,
+222213L,
+132837L,
+677571L,
+268928L,
+222305L,
+524291L,
+222213L,
+842757L,
+144613L,
+698563L,
+221792L,
+524290L,
+222213L,
+24293L,
+698563L,
+103653L,
+698563L,
+141541L,
+689859L,
+842848L,
+221282L,
+221795L,
+268932L,
+143077L,
+685251L,
+222305L,
+221795L,
+222213L,
+144613L,
+698563L,
+524290L,
+222213L,
+141541L,
+698563L,
+221280L,
+524290L,
+222213L,
+24293L,
+698563L,
+103653L,
+698563L,
+141541L,
+689859L,
+195205L,
+432737L,
+116229L,
+111680L,
+112197L,
+112645L,
+113157L,
+113669L,
+211461L,
+171525L,
+172037L,
+172549L,
+173061L,
+173573L,
+174085L,
+174597L,
+523781L,
+117893L,
+116321L,
+195203L,
+116229L,
+666853L,
+710339L,
+111713L,
+116224L,
+112227L,
+432291L,
+660064L,
+112234L,
+30213L,
+111716L,
+111616L,
+30307L,
+113251L,
+112128L,
+112228L,
+249989L,
+524298L,
+113672L,
+113157L,
+112741L,
+113762L,
+524291L,
+112645L,
+524294L,
+524294L,
+115205L,
+12005L,
+40130L,
+141541L,
+19650L,
+263813L,
+524289L,
+223749L,
+141536L,
+1041601L,
+524293L,
+118405L,
+788805L,
+119424L,
+141541L,
+299202L,
+524293L,
+0L
+};
+
+static const uInt16 patchEntries [] = {
+950,
+4006,
+4287,
+4469,
+1881,
+1720,
+1315,
+4519,
+4347,
+1425,
+1347,
+4,
+12,
+4081,
+4679,
+0
+};
+
+static const uInt16 patchSupportAddr [] = {
+800,
+694,
+695,
+795,
+914,
+892,
+893,
+333,
+334,
+352,
+226,
+432,
+433,
+434,
+437,
+450,
+0
+};
+
+static const uInt32 patchSupportData [] = {
+0x200000L,
+0x80000L,
+0x200000L,
+0x180000L,
+0x07FCFDDAL,
+0x400000L,
+0x0L,
+0x0L,
+0x0L,
+0x0L,
+0x35D540L,
+0x0L,
+0x0L,
+0x0L,
+0x0L,
+0x0L,
+0x0L
+};
+
+#ifdef SIVOICE_MULTI_BOM_SUPPORT
+const proslicPatch si3228xPatchRevALCQC = {
+#else
+const proslicPatch RevAPatch = {
+#endif
+    patchData,
+    patchEntries,
+    0x05262017L,
+    patchSupportAddr,
+    patchSupportData
+};
Index: linux-5.4.171/sound/soc/codecs/si3218x/si3218x.c
===================================================================
--- linux-5.4.171.orig/sound/soc/codecs/si3218x/si3218x.c	2022-02-07 17:55:33.855596500 +0800
+++ linux-5.4.171/sound/soc/codecs/si3218x/si3218x.c	2022-02-23 06:03:49.194997500 +0800
@@ -25,9 +25,15 @@
 
 #include "spi.h"
 
+#define PCM_16K // D2 MOD.
+
 #ifdef SI3218X
 #include "inc/si3218x.h"
 #include "inc/si3218x_intf.h"
+#elif defined SI3226X // D2 MOD.
+#include "inc/si3226x.h"
+#include "inc/si3226x_intf.h"
+#include "inc/si3226x_registers.h"
 #endif
 
 #define NUMBER_OF_DEVICES 1
@@ -36,9 +42,20 @@
 #define NUMBER_OF_CHAN (NUMBER_OF_DEVICES*CHAN_PER_DEVICE)
 #define NUMBER_OF_PROSLIC (NUMBER_OF_CHAN)
 #define PROSLIC_DEVICE_TYPE SI3218X_TYPE
+#elif defined(SI3226X) // D2 MOD.
+#define CHAN_PER_DEVICE 2
+#define NUMBER_OF_CHAN (NUMBER_OF_DEVICES*CHAN_PER_DEVICE)
+#define NUMBER_OF_PROSLIC (NUMBER_OF_CHAN)
+#define PROSLIC_DEVICE_TYPE SI3226X_TYPE
+#elif defined(SI3228X) // D2 MOD.
+#define CHAN_PER_DEVICE 2
+#define NUMBER_OF_CHAN (NUMBER_OF_DEVICES*CHAN_PER_DEVICE)
+#define NUMBER_OF_PROSLIC (NUMBER_OF_CHAN)
+#define PROSLIC_DEVICE_TYPE SI3228X_TYPE
 #endif
 
 static int slic_init = 0;
+static int slic_chan = 0; // D2 MOD.
 
 ctrl_S spiGciObj; /* User¡¦s control interface object */
 systemTimer_S timerObj; /* User¡¦s timer object */
@@ -151,11 +168,23 @@ static int ProSLIC_HWInit(void)
 	for(i=0;i<NUMBER_OF_CHAN;i++)
 	{
 		ProSLIC_PCMTimeSlotSetup(ports[i].ProObj,0,0);
+#if 0 // D2 MOD.
 		ProSLIC_DCFeedSetup(ports[i].ProObj,DCFEED_48V_20MA);
 		ProSLIC_RingSetup(ports[i].ProObj,RING_F20_45VRMS_0VDC_LPR);
 		ProSLIC_PCMSetup(ports[i].ProObj,PCM_16LIN_WB); /* PCM_DEFAULT_CONFIG */
 		ProSLIC_ZsynthSetup(ports[i].ProObj,ZSYN_600_0_0_30_0);
 		ProSLIC_ToneGenSetup(ports[i].ProObj,TONEGEN_FCC_DIAL);
+#else
+		ProSLIC_DCFeedSetup(ports[i].ProObj, 0);
+		ProSLIC_RingSetup(ports[i].ProObj, 0);
+#ifdef PCM_16K
+		ProSLIC_PCMSetup(ports[i].ProObj, 3); // 16 bit linear wide band.
+#else
+		ProSLIC_PCMSetup(ports[i].ProObj, 2); // 16 bit linear narrow band.
+#endif
+		ProSLIC_ZsynthSetup(ports[i].ProObj, 0);
+		ProSLIC_ToneGenSetup(ports[i].ProObj, 0);
+#endif // D2 MOD.
 	}
 
 	for(i=0;i<NUMBER_OF_CHAN;i++)
@@ -174,7 +203,19 @@ static int ProSLIC_HWInit(void)
 	*/
 	ProSLIC_WriteReg(ports[0].ProObj, 12, 1);
 	ProSLIC_WriteReg(ports[0].ProObj, 14, 1);
+#ifdef PCM_16K // D2 MOD.
+	// disable free run mode(bit 1), and enable 16K pcm data (bit 0).
 	ProSLIC_WriteReg(ports[0].ProObj, 47, 1);
+#endif // D2 MOD.
+
+#if 1 // D2 MOD.
+	ProSLIC_WriteReg(ports[1].ProObj, 12, 17);
+	ProSLIC_WriteReg(ports[1].ProObj, 14, 17);
+#ifdef PCM_16K
+	// disable free run mode(bit 1), and enable 16K pcm data (bit 0).
+	ProSLIC_WriteReg(ports[1].ProObj, 47, 1);
+#endif
+#endif // D2 MOD.
 
 	return 1;
 }
@@ -213,6 +254,12 @@ static const struct soc_enum si3218x_sli
 			    slic_control_str),
 };
 
+#if 1 // D2 MOD.
+static const char * const slic_test_str[] = {
+    "abc", "def", "123", "456", "789"
+};
+#endif // D2 MOD.
+
 static int si3218x_init_get(struct snd_kcontrol *kcontrol,
 			     struct snd_ctl_elem_value *ucontrol)
 {
@@ -235,11 +282,22 @@ static int si3218x_init_set(struct snd_k
 static int si3218x_ring_get(struct snd_kcontrol *kcontrol,
 			     struct snd_ctl_elem_value *ucontrol)
 {
+#if 1 // D2 MOD.
+	return (0);
+#endif // D2 MOD.
+
 	if (!slic_init)
 		return 0;
 
+#if 0 // D2 MOD.
 	ucontrol->value.integer.value[0] =
 		(ProSLIC_ReadReg(ports[0].ProObj,30) == 4) ? 1 : 0;
+#else
+	ucontrol->value.integer.value[0] =
+		(ProSLIC_ReadReg(ports[slic_chan].ProObj,30) == 4) ? 1 : 0;
+	printk("%s %d D2 debug.\n", __func__, __LINE__);
+#endif // D2 MOD.
+
 	return 0;
 }
 
@@ -249,19 +307,221 @@ static int si3218x_ring_set(struct snd_k
 	if (!slic_init)
 		return 0;
 
+#if 0 // D2 MOD.
 	if (ucontrol->value.integer.value[0])
 		ProSLIC_WriteReg(ports[0].ProObj, 30, 4);
 	else
 		ProSLIC_WriteReg(ports[0].ProObj, 30, 1);
+#else
+	if (ucontrol->value.integer.value[0])
+		ProSLIC_WriteReg(ports[slic_chan].ProObj, 30, 4);
+	else
+		ProSLIC_WriteReg(ports[slic_chan].ProObj, 30, 1);
+#endif // D2 MOD.
 
 	return 0;
 }
 
+
+#if 1 // D2 MOD.
+static int si3218x_setLineState(struct snd_kcontrol *kcontrol,
+            struct snd_ctl_elem_value *ucontrol)
+{
+    ProSLIC_WriteReg(ports[slic_chan].ProObj, 30, ucontrol->value.integer.value[0]);
+    return 0;
+}
+
+static int si3218x_setPcmMode(struct snd_kcontrol *kcontrol,
+            struct snd_ctl_elem_value *ucontrol)
+{
+    ProSLIC_WriteReg(ports[slic_chan].ProObj, 11, ucontrol->value.integer.value[0]);
+    return 0;
+}
+
+static int si3218x_getPcmMode(struct snd_kcontrol *kcontrol,
+            struct snd_ctl_elem_value *ucontrol)
+{
+    return (0);
+	if (!slic_init) {
+		return 0;
+    }
+	ucontrol->value.integer.value[0] = ProSLIC_ReadReg(ports[slic_chan].ProObj, 11);
+
+    printk("%s %d D2 debug \n", __func__, __LINE__);
+    return 0;
+}
+
+static int si3218x_getLineState(struct snd_kcontrol *kcontrol,
+            struct snd_ctl_elem_value *ucontrol)
+{
+    return (0);
+	if (!slic_init) {
+		return 0;
+    }
+
+    printk("%s %d D2 debug \n", __func__, __LINE__);
+    return 0;
+}
+
+static int si3218x_setHookState(struct snd_kcontrol *kcontrol,
+            struct snd_ctl_elem_value *ucontrol)
+{
+    return 0;
+}
+
+static int si3218x_getHookState(struct snd_kcontrol *kcontrol,
+            struct snd_ctl_elem_value *ucontrol)
+{
+	if (!slic_init) {
+		return 0;
+    }
+	ucontrol->value.integer.value[0] = ProSLIC_ReadReg(ports[slic_chan].ProObj, 34);
+//    printk("%s %d chan:%d, hookState: %04x \n", __func__, __LINE__, slic_chan, (unsigned int)ucontrol->value.integer.value[0]);
+    return 0;
+}
+
+static int si3218x_setChan(struct snd_kcontrol *kcontrol,
+            struct snd_ctl_elem_value *ucontrol)
+{
+    struct soc_mixer_control *mc;
+    unsigned int              reg;
+    unsigned char             val;
+
+    mc = (struct soc_mixer_control *)kcontrol->private_value;
+    reg = mc->reg;
+    val  = (ucontrol->value.integer.value[0]) & 0x00FF;
+    slic_chan = val;
+
+    return (0);
+}
+
+static int si3218x_getChan(struct snd_kcontrol *kcontrol,
+            struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = slic_chan;
+    return (0);
+}
+
+static int si3218x_getIrq(struct snd_kcontrol *kcontrol,
+            struct snd_ctl_elem_value *ucontrol)
+{
+    struct soc_mixer_control *mc;
+    unsigned int              reg;
+	if (!slic_init) {
+		return 0;
+    }
+    mc = (struct soc_mixer_control *)kcontrol->private_value;
+    reg = mc->reg;
+
+	ucontrol->value.integer.value[0] = ProSLIC_ReadReg(ports[1].ProObj, 19);
+	ucontrol->value.integer.value[0] = ((ucontrol->value.integer.value[0] & 0xFF) << 8)
+        | ProSLIC_ReadReg(ports[0].ProObj, 19);
+//    printk("%s %d reg: %d irq:%04x\n", __func__, __LINE__, reg, (unsigned int)ucontrol->value.integer.value[0]);
+    return (0);
+}
+
+static int si3218x_setIrq(struct snd_kcontrol *kcontrol,
+            struct snd_ctl_elem_value *ucontrol)
+{
+    unsigned char             chan;
+    unsigned char             val;
+
+    chan = ((ucontrol->value.integer.value[0]) & 0xFF00) >> 8;
+    val  = (ucontrol->value.integer.value[0]) & 0x00FF;
+
+    if (chan > 1) {
+        printk("%s %d Error channel number: %d \n", __func__, __LINE__, chan);
+        return (0);
+    }
+
+    printk("%s %d set chan: %d irq2: %02x \n", __func__, __LINE__, chan, val);
+    ProSLIC_WriteReg(ports[chan].ProObj, 23, val);
+ 
+    return (0);
+}
+
+static int si3218x_setReg(struct snd_kcontrol *kcontrol,
+            struct snd_ctl_elem_value *ucontrol)
+{
+    struct soc_mixer_control *mc;
+    struct snd_ctl_elem_id   *id_ptr;
+    unsigned int              reg;
+    unsigned char             chan;
+    unsigned char             val;
+
+    mc = (struct soc_mixer_control *)kcontrol->private_value;
+    id_ptr = (struct snd_ctl_elem_id *)&ucontrol->id;
+    reg = mc->reg;
+    chan = ((ucontrol->value.integer.value[0]) & 0xFF00) >> 8;
+    val  = (ucontrol->value.integer.value[0]) & 0x00FF;
+
+    if (chan > 1) {
+        printk("%s %d Error channel number: %d\n", __func__, __LINE__, chan);
+        return (0);
+    }
+
+    printk("%s %d chan: %d reg:%d val: 0x%02x \n", __func__, __LINE__, chan, reg, val);
+    ProSLIC_WriteReg(ports[chan].ProObj, reg, val);
+    return 0;
+}
+
+static int si3218x_getReg(struct snd_kcontrol *kcontrol,
+            struct snd_ctl_elem_value *ucontrol)
+{
+    struct soc_mixer_control *mc;
+    struct snd_ctl_elem_id   *id_ptr;
+    unsigned int              reg;
+
+	if (!slic_init) {
+		return 0;
+    }
+
+    mc = (struct soc_mixer_control *)kcontrol->private_value;
+    id_ptr = (struct snd_ctl_elem_id *)&ucontrol->id;
+    reg = mc->reg;
+	ucontrol->value.integer.value[0] = (ProSLIC_ReadReg(ports[slic_chan].ProObj, reg));
+
+#if 0
+    printk("%s %d chan:%d reg:%d val:0x%04x, numid: %d index: %d\n", __func__, __LINE__,
+            slic_chan, reg, (unsigned int)ucontrol->value.integer.value[0],
+            id_ptr->numid, id_ptr->index);
+#endif
+    return 0;
+}
+#endif // D2 MOD.
+
+
 static const struct snd_kcontrol_new si3218x_component_snd_controls[] = {
 	SOC_ENUM_EXT("proslic_init", si3218x_slic_enum[0],
 				     si3218x_init_get, si3218x_init_set),
 	SOC_ENUM_EXT("proslic_ring", si3218x_slic_enum[0],
 				     si3218x_ring_get, si3218x_ring_set),
+
+#if 1 // D2 MOD.
+    SOC_SINGLE_EXT("proslic_pcmMode", 11 /* reg */, 0, 255, 0,
+            si3218x_getPcmMode, si3218x_setPcmMode),
+
+    SOC_SINGLE_EXT("proslic_setLineState", 30 /*linefeed*/, 0, 255, 0,
+            si3218x_getLineState, si3218x_setLineState),
+
+    SOC_SINGLE_EXT("proslic_hookState", 34 /*LCRRTP*/, 0, 255, 0,
+            si3218x_getHookState, si3218x_setHookState),
+
+    SOC_SINGLE_EXT("pcmMode", 11, 0, 512, 0,
+            si3218x_getReg, si3218x_setReg),
+    SOC_SINGLE_EXT("slotTx", 12, 0, 512, 0,
+            si3218x_getReg, si3218x_setReg),
+    SOC_SINGLE_EXT("slotRx", 14, 0, 512, 0,
+            si3218x_getReg, si3218x_setReg),
+    SOC_SINGLE_EXT("lineState", 30, 0, 512, 0,
+            si3218x_getReg, si3218x_setReg),
+    SOC_SINGLE_EXT("hookState", 34, 0, 512, 0,
+            si3218x_getReg, si3218x_setReg),
+    SOC_SINGLE_EXT("setChan", 0, 0, 128, 0,
+            si3218x_getChan, si3218x_setChan),
+    SOC_SINGLE_EXT("irq2", 19, 0, 512, 0,
+            si3218x_getIrq, si3218x_setIrq),
+#endif // D2 MOD.
 };
 
 static const struct snd_soc_component_driver si3218x_component_driver = {
Index: linux-5.4.171/sound/soc/codecs/si3218x/src/Makefile
===================================================================
--- linux-5.4.171.orig/sound/soc/codecs/si3218x/src/Makefile	2022-02-07 17:55:33.855596500 +0800
+++ linux-5.4.171/sound/soc/codecs/si3218x/src/Makefile	2022-02-23 09:24:05.421997500 +0800
@@ -11,7 +11,11 @@
 
 # platform driver
 subdir-ccflags-y += -I../inc
-subdir-ccflags-y += -DSI3218X
+#
+#D2 MOD.
+#subdir-ccflags-y += -DSI3218X
+subdir-ccflags-y += -DSI3228X
+#
 subdir-ccflags-y += -DPROSLIC_LINUX_KERNEL
 snd-soc-procslic-common-objs := proslic.o proslic_tstin.o si_voice.o si_voice_version.o si3218x_intf.o vdaa.o si3217x_intf.o si3217x_revb_intf.o si3217x_revc_intf.o si3219x_intf.o si3226x_intf.o si3228x_intf.o
 
Index: linux-5.4.171/sound/soc/codecs/si3218x/src/proslic.c
===================================================================
--- linux-5.4.171.orig/sound/soc/codecs/si3218x/src/proslic.c	2022-02-07 17:55:33.855596500 +0800
+++ linux-5.4.171/sound/soc/codecs/si3218x/src/proslic.c	2022-02-23 09:24:07.555997500 +0800
@@ -63,8 +63,13 @@ extern ProSLIC_Tone_Cfg Si3219x_Tone_Pre
 #endif /* 19X */
 
 #ifdef SI3226X
+#if 0 //D2 MOD.
 #include "si3226x.h"
 #include "si3226x_intf.h"
+#else
+#include "../inc/si3226x.h"
+#include "../inc/si3226x_intf.h"
+#endif //D2 MOD.
 extern Si3226x_General_Cfg Si3226x_General_Configuration;
 #ifndef DISABLE_FSK_SETUP
 extern ProSLIC_FSK_Cfg Si3226x_FSK_Presets[];
@@ -75,8 +80,13 @@ extern ProSLIC_Tone_Cfg Si3226x_Tone_Pre
 #endif /* 26X */
 
 #ifdef SI3228X
+#if 0 //D2 MOD.
 #include "si3228x.h"
 #include "si3228x_intf.h"
+#else
+#include "../inc/si3228x.h"
+#include "../inc/si3228x_intf.h"
+#endif //D2 MOD.
 extern Si3228x_General_Cfg Si3228x_General_Configuration;
 #ifndef DISABLE_FSK_SETUP
 extern ProSLIC_FSK_Cfg Si3228x_FSK_Presets[];
Index: linux-5.4.171/sound/soc/codecs/si3218x/src/proslic_tstin.c
===================================================================
--- linux-5.4.171.orig/sound/soc/codecs/si3218x/src/proslic_tstin.c	2022-02-07 17:55:33.855596500 +0800
+++ linux-5.4.171/sound/soc/codecs/si3218x/src/proslic_tstin.c	2022-02-23 09:24:09.254997500 +0800
@@ -36,12 +36,22 @@
 #include "si3219x_intf.h"
 #endif
 #ifdef SI3226X
+#if 0 //D2 MOD.
 #include "si3226x.h"
 #include "si3226x_intf.h"
+#else
+#include "../inc/si3226x.h"
+#include "../inc/si3226x_intf.h"
+#endif //D2 MOD.
 #endif
 #ifdef SI3228X
+#if 0 //D2 MOD.
 #include "si3228x.h"
 #include "si3228x_intf.h"
+#else
+#include "../inc/si3228x.h"
+#include "../inc/si3228x_intf.h"
+#endif //D2 MOD.
 #endif
 
 /*
Index: linux-5.4.171/sound/soc/codecs/si3218x/src/si3226x_FLBK_constants.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-5.4.171/sound/soc/codecs/si3218x/src/si3226x_FLBK_constants.c	2022-02-22 10:59:29.000000000 +0800
@@ -0,0 +1,766 @@
+/*
+** Copyright (c) 2017 Silicon Laboratories, Inc.
+** 2017-09-14 19:29:25
+**
+** Si3226x ProSLIC API Configuration Tool Version 4.2.0
+** Last Updated in API Release: 9.1.0
+** source XML file: si3226x_FLBK_constants.xml
+**
+** Auto generated file from configuration tool.
+*/
+
+
+#include "../inc/proslic.h"
+#include "../inc/si3226x.h"
+
+Si3226x_General_Cfg Si3226x_General_Configuration  = {
+0x65,     /* DEVICE_KEY */
+BO_DCDC_FLYBACK,    /* BOM_OPT */
+BO_DCDC_TRACKING,    /* BAT_RAIL_TYPE */
+0x000AD000L,    /* bat_hyst */
+0x08A3D6C8L,    /* VBATR_EXPECT (135.00) */
+0x03D70A20L,    /* VBATH_EXPECT (60.00) */
+0x0FFF0000L,    /* PWRSAVE_TIMER */
+0x01999A00L,    /* OFFHOOK_THRESH */
+0x00F00000L,    /* VBAT_TRACK_MIN */
+0x00F00000L,    /* VBAT_TRACK_MIN_RNG */
+0x00014000L,    /* PWRSAVE_DBI */
+0x0ADD5500L,    /* DCDC_ANA_SCALE */
+0x00312700L,    /* VOV_BAT_PWRSAVE_MIN */
+0x00395800L,    /* VOV_BAT_PWRSAVE_MIN_RNG */
+0x00800000L,    /* THERM_DBI */
+0x00004000L,    /* CPUMP_DBI */
+0x00F18900L,    /* DCDC_VERR */
+0x00809D80L,    /* DCDC_VERR_HYST */
+0x00800000L,    /* DCDC_OITHRESH_LO */
+0x01F00000L,    /* DCDC_OITHRESH_HI */
+0x00400000L,    /* PD_UVLO */
+0x00400000L,    /* PD_OVLO */
+0x00200000L,    /* PD_OCLO */
+0x00400000L,    /* PD_SWDRV */
+0x00500000L,    /* DCDC_UVHYST */
+0x00000000L,    /* DCDC_UVTHRESH */
+0x01700000L,    /* DCDC_OVTHRESH */
+0x00800000L,    /* DCDC_OITHRESH */
+0x00000000L,    /* DCDC_SWDRV_POL */
+0x00000000L,    /* DCDC_UVPOL */
+0x00000000L,    /* DCDC_VREF_MAN */
+0x00000000L,    /* DCDC_VREF_CTRL */
+0x00200000L,    /* DCDC_RNGTYPE */
+0x05B00000L,    /* DCDC_ANA_VREF */
+0x00300000L,    /* DCDC_ANA_GAIN */
+0x00300000L,    /* DCDC_ANA_TOFF */
+0x00100000L,    /* DCDC_ANA_TONMIN */
+0x00FFC000L,    /* DCDC_ANA_TONMAX */
+0x00F00000L,    /* DCDC_ANA_DSHIFT */
+0x0FDA4000L,    /* DCDC_ANA_LPOLY */
+0x00000000L,    /* DCDC_AUX_INVERT */
+0x00400000L,    /* DCDC_CPUMP_LP */
+0x00000000L,    /* DCDC_CPUMP_PULLDOWN */
+0x00000000L,    /* DCDC_LIFT_EN */
+0x07FEB800L,    /* COEF_P_HVIC */
+0x005B05B2L,    /* P_TH_HVIC */
+VDC_4P5_27P0,    /* VDC_RANGE_OPT */
+0x3F,     /* AUTO */
+0x50,     /* IRQEN1 */
+0x13,     /* IRQEN2 */
+0x03,     /* IRQEN3 */
+0x00,     /* IRQEN4 */
+0x10,     /* ENHANCE */
+0x03A2E8BAL,    /* SCALE_KAUDIO */
+0x04,    /* ZCAL_EN */
+0x03000000L,    /* LKG_OFHK_OFFSET */
+0x05000000L,    /* LKG_LB_OFFSET */
+0x01000000L,    /* VBATH_DELTA */
+0x03700000L,    /* UVTHRESH_MAX */
+0x04B80200L,    /* UVTHRESH_SCALE */
+0x00823000L     /* UVTHRESH_BIAS */
+};
+
+Si3226x_GPIO_Cfg Si3226x_GPIO_Configuration = {
+0x00,     /* GPIO_OE */
+0x06,     /* GPIO_ANA */
+0x00,     /* GPIO_DIR */
+0x00,     /* GPIO_MAN */
+0x00,     /* GPIO_POL */
+0x00,     /* GPIO_OD */
+0x00     /* BATSELMAP */
+};
+Si3226x_CI_Cfg Si3226x_CI_Presets [] = {
+{0}
+};
+Si3226x_audioGain_Cfg Si3226x_audioGain_Presets [] = {
+{0x1377080L,0, 0x0L, 0x0L, 0x0L, 0x0L},
+{0x80C3180L,0, 0x0L, 0x0L, 0x0L, 0x0L}
+};
+
+Si3226x_Ring_Cfg Si3226x_Ring_Presets[] ={
+{
+/*
+    Loop = 500.0 ft @ 0.044 ohms/ft, REN = 3, Rcpe = 600 ohms
+    Rprot = 20 ohms, Type = LPR, Waveform = SINE
+*/ 
+0x00050000L,    /* RTPER */
+0x07EFE000L,    /* RINGFR (20.000 Hz) */
+0x002EBF47L,    /* RINGAMP (80.000 vrms)  */
+0x00000000L,    /* RINGPHAS */
+0x00000000L,    /* RINGOF (0.000 vdc) */
+0x15E5200EL,    /* SLOPE_RING (100.000 ohms) */
+0x009FC50FL,    /* IRING_LIM (103.000 mA) */
+0x0077DA92L,    /* RTACTH (66.187 mA) */
+0x0FFFFFFFL,    /* RTDCTH (450.000 mA) */
+0x00006000L,    /* RTACDB (75.000 ms) */
+0x00006000L,    /* RTDCDB (75.000 ms) */
+0x0051EB82L,    /* VOV_RING_BAT (5.000 v) */
+0x00000000L,    /* VOV_RING_GND (0.000 v) */
+0x081185C6L,    /* VBATR_EXPECT (126.070 v) */
+0x80,            /* RINGTALO (2.000 s) */
+0x3E,            /* RINGTAHI */
+0x00,            /* RINGTILO (4.000 s) */
+0x7D,            /* RINGTIHI */
+0x00000000L,    /* ADAP_RING_MIN_I */
+0x00003000L,    /* COUNTER_IRING_VAL */
+0x00051EB8L,    /* COUNTER_VTR_VAL */
+0x00000000L,    /* CONST_028 */
+0x00000000L,    /* CONST_032 */
+0x00000000L,    /* CONST_038 */
+0x00000000L,    /* CONST_046 */
+0x00000000L,    /* RRD_DELAY */
+0x00000000L,    /* RRD_DELAY2 */
+0x01893740L,    /* VBAT_TRACK_MIN_RNG */
+0x98,            /* RINGCON */
+0x00,            /* USERSTAT */
+0x0408C2E3L,    /* VCM_RING (61.785 v) */
+0x0408C2E3L,    /* VCM_RING_FIXED */
+0x003126E8L,    /* DELTA_VCM */
+0x00200000L,    /* DCDC_RNGTYPE */
+0x00FFFFFFL,    /* VOV_DCDC_SLOPE */
+0x00A18937L,    /* VOV_DCDC_OS */
+0x00E49BA5L,    /* VOV_RING_BAT_MAX */
+},  /* RING_MAX_VBAT_PROVISIONING */
+{
+/*
+    Loop = 500.0 ft @ 0.044 ohms/ft, REN = 5, Rcpe = 600 ohms
+    Rprot = 20 ohms, Type = LPR, Waveform = SINE
+*/ 
+0x00050000L,    /* RTPER */
+0x07EFE000L,    /* RINGFR (20.000 Hz) */
+0x001B7243L,    /* RINGAMP (45.000 vrms)  */
+0x00000000L,    /* RINGPHAS */
+0x00000000L,    /* RINGOF (0.000 vdc) */
+0x15E5200EL,    /* SLOPE_RING (100.000 ohms) */
+0x009FC50FL,    /* IRING_LIM (103.000 mA) */
+0x00690508L,    /* RTACTH (57.995 mA) */
+0x0FFFFFFFL,    /* RTDCTH (450.000 mA) */
+0x00006000L,    /* RTACDB (75.000 ms) */
+0x00006000L,    /* RTDCDB (75.000 ms) */
+0x0051EB82L,    /* VOV_RING_BAT (5.000 v) */
+0x00000000L,    /* VOV_RING_GND (0.000 v) */
+0x04DE89D7L,    /* VBATR_EXPECT (76.083 v) */
+0x80,            /* RINGTALO (2.000 s) */
+0x3E,            /* RINGTAHI */
+0x00,            /* RINGTILO (4.000 s) */
+0x7D,            /* RINGTIHI */
+0x00000000L,    /* ADAP_RING_MIN_I */
+0x00003000L,    /* COUNTER_IRING_VAL */
+0x00051EB8L,    /* COUNTER_VTR_VAL */
+0x00000000L,    /* CONST_028 */
+0x00000000L,    /* CONST_032 */
+0x00000000L,    /* CONST_038 */
+0x00000000L,    /* CONST_046 */
+0x00000000L,    /* RRD_DELAY */
+0x00000000L,    /* RRD_DELAY2 */
+0x01893740L,    /* VBAT_TRACK_MIN_RNG */
+0x98,            /* RINGCON */
+0x00,            /* USERSTAT */
+0x026F44EBL,    /* VCM_RING (36.791 v) */
+0x026F44EBL,    /* VCM_RING_FIXED */
+0x003126E8L,    /* DELTA_VCM */
+0x00200000L,    /* DCDC_RNGTYPE */
+0x00FFFFFFL,    /* VOV_DCDC_SLOPE */
+0x00A18937L,    /* VOV_DCDC_OS */
+0x00E49BA5L,    /* VOV_RING_BAT_MAX */
+},  /* RING_F20_45VRMS_0VDC_LPR */
+{
+/*
+    Loop = 500.0 ft @ 0.044 ohms/ft, REN = 5, Rcpe = 600 ohms
+    Rprot = 20 ohms, Type = BALANCED, Waveform = SINE
+*/ 
+0x00050000L,    /* RTPER */
+0x07EFE000L,    /* RINGFR (20.000 Hz) */
+0x001B7243L,    /* RINGAMP (45.000 vrms)  */
+0x00000000L,    /* RINGPHAS */
+0x00000000L,    /* RINGOF (0.000 vdc) */
+0x15E5200EL,    /* SLOPE_RING (100.000 ohms) */
+0x009FC50FL,    /* IRING_LIM (103.000 mA) */
+0x00690508L,    /* RTACTH (57.995 mA) */
+0x0FFFFFFFL,    /* RTDCTH (450.000 mA) */
+0x00006000L,    /* RTACDB (75.000 ms) */
+0x00006000L,    /* RTDCDB (75.000 ms) */
+0x0051EB82L,    /* VOV_RING_BAT (5.000 v) */
+0x00000000L,    /* VOV_RING_GND (0.000 v) */
+0x04DE89D7L,    /* VBATR_EXPECT (76.083 v) */
+0x80,            /* RINGTALO (2.000 s) */
+0x3E,            /* RINGTAHI */
+0x00,            /* RINGTILO (4.000 s) */
+0x7D,            /* RINGTIHI */
+0x00000000L,    /* ADAP_RING_MIN_I */
+0x00003000L,    /* COUNTER_IRING_VAL */
+0x00051EB8L,    /* COUNTER_VTR_VAL */
+0x00000000L,    /* CONST_028 */
+0x00000000L,    /* CONST_032 */
+0x00000000L,    /* CONST_038 */
+0x00000000L,    /* CONST_046 */
+0x00000000L,    /* RRD_DELAY */
+0x00000000L,    /* RRD_DELAY2 */
+0x01893740L,    /* VBAT_TRACK_MIN_RNG */
+0x00,            /* RINGCON */
+0x00,            /* USERSTAT */
+0x026F44EBL,    /* VCM_RING (36.791 v) */
+0x026F44EBL,    /* VCM_RING_FIXED */
+0x003126E8L,    /* DELTA_VCM */
+0x00200000L,    /* DCDC_RNGTYPE */
+0x00FFFFFFL,    /* VOV_DCDC_SLOPE */
+0x00A18937L,    /* VOV_DCDC_OS */
+0x00E49BA5L,    /* VOV_RING_BAT_MAX */
+}   /* RING_F20_45VRMS_0VDC_BAL */
+};
+
+Si3226x_DCfeed_Cfg Si3226x_DCfeed_Presets[] = {
+{
+0x1C8A024CL,    /* SLOPE_VLIM */
+0x1F909679L,    /* SLOPE_RFEED */
+0x0040A0E0L,    /* SLOPE_ILIM */
+0x1D5B21A9L,    /* SLOPE_DELTA1 */
+0x1DD87A3EL,    /* SLOPE_DELTA2 */
+0x05A38633L,    /* V_VLIM (48.000 v) */
+0x050D2839L,    /* V_RFEED (43.000 v) */
+0x03FE7F0FL,    /* V_ILIM  (34.000 v) */
+0x00B4F3C3L,    /* CONST_RFEED (15.000 mA) */
+0x005D0FA6L,    /* CONST_ILIM (20.000 mA) */
+0x002D8D96L,    /* I_VLIM (0.000 mA) */
+0x005B0AFBL,    /* LCRONHK (10.000 mA) */
+0x006D4060L,    /* LCROFFHK (12.000 mA) */
+0x00008000L,    /* LCRDBI (5.000 ms) */
+0x0048D595L,    /* LONGHITH (8.000 mA) */
+0x003FBAE2L,    /* LONGLOTH (7.000 mA) */
+0x00008000L,    /* LONGDBI (5.000 ms) */
+0x000F0000L,    /* LCRMASK (150.000 ms) */
+0x00080000L,    /* LCRMASK_POLREV (80.000 ms) */
+0x00140000L,    /* LCRMASK_STATE (200.000 ms) */
+0x00140000L,    /* LCRMASK_LINECAP (200.000 ms) */
+0x01BA5E35L,    /* VCM_OH (27.000 v) */
+0x0051EB85L,    /* VOV_BAT (5.000 v) */
+0x00418937L,    /* VOV_GND (4.000 v) */
+},  /* DCFEED_48V_20MA */
+{
+0x1C8A024CL,    /* SLOPE_VLIM */
+0x1EE08C11L,    /* SLOPE_RFEED */
+0x0040A0E0L,    /* SLOPE_ILIM */
+0x1C940D71L,    /* SLOPE_DELTA1 */
+0x1DD87A3EL,    /* SLOPE_DELTA2 */
+0x05A38633L,    /* V_VLIM (48.000 v) */
+0x050D2839L,    /* V_RFEED (43.000 v) */
+0x03FE7F0FL,    /* V_ILIM  (34.000 v) */
+0x01241BC9L,    /* CONST_RFEED (15.000 mA) */
+0x0074538FL,    /* CONST_ILIM (25.000 mA) */
+0x002D8D96L,    /* I_VLIM (0.000 mA) */
+0x005B0AFBL,    /* LCRONHK (10.000 mA) */
+0x006D4060L,    /* LCROFFHK (12.000 mA) */
+0x00008000L,    /* LCRDBI (5.000 ms) */
+0x0048D595L,    /* LONGHITH (8.000 mA) */
+0x003FBAE2L,    /* LONGLOTH (7.000 mA) */
+0x00008000L,    /* LONGDBI (5.000 ms) */
+0x000F0000L,    /* LCRMASK (150.000 ms) */
+0x00080000L,    /* LCRMASK_POLREV (80.000 ms) */
+0x00140000L,    /* LCRMASK_STATE (200.000 ms) */
+0x00140000L,    /* LCRMASK_LINECAP (200.000 ms) */
+0x01BA5E35L,    /* VCM_OH (27.000 v) */
+0x0051EB85L,    /* VOV_BAT (5.000 v) */
+0x00418937L,    /* VOV_GND (4.000 v) */
+},  /* DCFEED_48V_25MA */
+{
+0x1E655196L,    /* SLOPE_VLIM */
+0x001904EFL,    /* SLOPE_RFEED */
+0x0040A0E0L,    /* SLOPE_ILIM */
+0x1B4CAD9EL,    /* SLOPE_DELTA1 */
+0x1BB0F47CL,    /* SLOPE_DELTA2 */
+0x05A38633L,    /* V_VLIM (48.000 v) */
+0x043AA4A6L,    /* V_RFEED (36.000 v) */
+0x025977EAL,    /* V_ILIM  (20.000 v) */
+0x0068B19AL,    /* CONST_RFEED (18.000 mA) */
+0x005D0FA6L,    /* CONST_ILIM (20.000 mA) */
+0x002D8D96L,    /* I_VLIM (0.000 mA) */
+0x005B0AFBL,    /* LCRONHK (10.000 mA) */
+0x006D4060L,    /* LCROFFHK (12.000 mA) */
+0x00008000L,    /* LCRDBI (5.000 ms) */
+0x0048D595L,    /* LONGHITH (8.000 mA) */
+0x003FBAE2L,    /* LONGLOTH (7.000 mA) */
+0x00008000L,    /* LONGDBI (5.000 ms) */
+0x000F0000L,    /* LCRMASK (150.000 ms) */
+0x00080000L,    /* LCRMASK_POLREV (80.000 ms) */
+0x00140000L,    /* LCRMASK_STATE (200.000 ms) */
+0x00140000L,    /* LCRMASK_LINECAP (200.000 ms) */
+0x01BA5E35L,    /* VCM_OH (27.000 v) */
+0x0051EB85L,    /* VOV_BAT (5.000 v) */
+0x00418937L,    /* VOV_GND (4.000 v) */
+},  /* DCFEED_PSTN_DET_1 */
+{
+0x1A10433FL,    /* SLOPE_VLIM */
+0x1C206275L,    /* SLOPE_RFEED */
+0x0040A0E0L,    /* SLOPE_ILIM */
+0x1C1F426FL,    /* SLOPE_DELTA1 */
+0x1EB51625L,    /* SLOPE_DELTA2 */
+0x041C91DBL,    /* V_VLIM (35.000 v) */
+0x03E06C43L,    /* V_RFEED (33.000 v) */
+0x038633E0L,    /* V_ILIM  (30.000 v) */
+0x022E5DE5L,    /* CONST_RFEED (10.000 mA) */
+0x005D0FA6L,    /* CONST_ILIM (20.000 mA) */
+0x0021373DL,    /* I_VLIM (0.000 mA) */
+0x005B0AFBL,    /* LCRONHK (10.000 mA) */
+0x006D4060L,    /* LCROFFHK (12.000 mA) */
+0x00008000L,    /* LCRDBI (5.000 ms) */
+0x0048D595L,    /* LONGHITH (8.000 mA) */
+0x003FBAE2L,    /* LONGLOTH (7.000 mA) */
+0x00008000L,    /* LONGDBI (5.000 ms) */
+0x000F0000L,    /* LCRMASK (150.000 ms) */
+0x00080000L,    /* LCRMASK_POLREV (80.000 ms) */
+0x00140000L,    /* LCRMASK_STATE (200.000 ms) */
+0x00140000L,    /* LCRMASK_LINECAP (200.000 ms) */
+0x01BA5E35L,    /* VCM_OH (27.000 v) */
+0x0051EB85L,    /* VOV_BAT (5.000 v) */
+0x00418937L,    /* VOV_GND (4.000 v) */
+}   /* DCFEED_PSTN_DET_2 */
+};
+
+Si3226x_Impedance_Cfg Si3226x_Impedance_Presets[] ={
+/* Source: Database file: cwdb.db */
+/* Database information: */
+/* parameters: zref=600_0_0 rprot=20 rfuse=0 emi_cap=10*/
+{
+{0x07F97D80L, 0x0006CC00L, 0x1FFC1480L, 0x1FFC7B80L,    /* TXACEQ */
+ 0x07F36B80L, 0x000A8E00L, 0x1FF90F00L, 0x1FFAE500L},   /* RXACEQ */
+{0x001AF400L, 0x1FC86A80L, 0x01E9AE00L, 0x00652F00L,    /* ECFIR/ECIIR */
+ 0x01F4AF00L, 0x1F57E000L, 0x00485E00L, 0x1FF3A680L,
+ 0x1FF83700L, 0x00011D00L, 0x01706980L, 0x066A8480L},
+{0x00920F00L, 0x1EE31980L, 0x008ADF00L, 0x0F92E500L,    /* ZSYNTH */
+ 0x186CE880L, 0x53}, 
+ 0x085C6880L,   /* TXACGAIN */
+ 0x013E3100L,   /* RXACGAIN */
+ 0x07AF6F80L, 0x18509100L, 0x075EDF00L,    /* RXACHPF */
+#ifdef ENABLE_HIRES_GAIN
+ 0, 0  /* TXGAIN*10, RXGAIN*10 (hi_res) */
+#else
+ 0, 0  /* TXGAIN, RXGAIN */
+#endif
+ },  /* ZSYN_600_0_0_30_0 */
+/* Source: Database file: cwdb.db */
+/* Database information: */
+/* parameters: zref=270_750_150 rprot=20 rfuse=0 emi_cap=10*/
+{
+{0x06FC3800L, 0x1FDE9280L, 0x000BC980L, 0x1FFEC900L,    /* TXACEQ */
+ 0x0A7A3180L, 0x1BB98500L, 0x0078FC00L, 0x1FDDF500L},   /* RXACEQ */
+{0x000A9280L, 0x0008DA80L, 0x00EEDC80L, 0x01C2E400L,    /* ECFIR/ECIIR */
+ 0x01447F00L, 0x016F6000L, 0x001D5400L, 0x007BF480L,
+ 0x001F5680L, 0x1FDEE780L, 0x0CCDB980L, 0x1B23B100L},
+{0x00857800L, 0x1E6C8180L, 0x010DD200L, 0x0D0AEC00L,    /* ZSYNTH */
+ 0x1AF3BB80L, 0x92}, 
+ 0x08000000L,   /* TXACGAIN */
+ 0x01062800L,   /* RXACGAIN */
+ 0x07BADA00L, 0x18452680L, 0x0775B400L,    /* RXACHPF */
+#ifdef ENABLE_HIRES_GAIN
+ 0, 0  /* TXGAIN*10, RXGAIN*10 (hi_res) */
+#else
+ 0, 0  /* TXGAIN, RXGAIN */
+#endif
+ },  /* ZSYN_270_750_150_30_0 */
+/* Source: Database file: cwdb.db */
+/* Database information: */
+/* parameters: zref=370_620_310 rprot=20 rfuse=0 emi_cap=10*/
+{
+{0x07C28C80L, 0x1FE04E80L, 0x1FFF9400L, 0x1FFE2D80L,    /* TXACEQ */
+ 0x09E96680L, 0x1C31D800L, 0x1F927A80L, 0x1FDD9100L},   /* RXACEQ */
+{0x0026B300L, 0x1F8CA780L, 0x0217B000L, 0x1FD05600L,    /* ECFIR/ECIIR */
+ 0x02DE4380L, 0x1FB44980L, 0x00E05B80L, 0x00441F80L,
+ 0x003D1080L, 0x1FC20D80L, 0x0DAB3E80L, 0x1A4EFE80L},
+{0x00416100L, 0x1F5A4680L, 0x00644E00L, 0x0F172B00L,    /* ZSYNTH */
+ 0x18E87980L, 0x87}, 
+ 0x08000000L,   /* TXACGAIN */
+ 0x0123FD80L,   /* RXACGAIN */
+ 0x07B39180L, 0x184C6F00L, 0x07672280L,    /* RXACHPF */
+#ifdef ENABLE_HIRES_GAIN
+ 0, 0  /* TXGAIN*10, RXGAIN*10 (hi_res) */
+#else
+ 0, 0  /* TXGAIN, RXGAIN */
+#endif
+ },  /* ZSYN_370_620_310_30_0 */
+/* Source: Database file: cwdb.db */
+/* Database information: */
+/* parameters: zref=220_820_120 rprot=20 rfuse=0 emi_cap=10*/
+{
+{0x06C91B00L, 0x1FE6B380L, 0x00090B80L, 0x1FFE1B80L,    /* TXACEQ */
+ 0x0A672A00L, 0x1BEA4880L, 0x00943000L, 0x1FD81D00L},   /* RXACEQ */
+{0x001C2A80L, 0x1FBF9880L, 0x01816280L, 0x01023680L,    /* ECFIR/ECIIR */
+ 0x02273400L, 0x0103EA00L, 0x00523800L, 0x006BD480L,
+ 0x00188980L, 0x1FE58180L, 0x0C9F8080L, 0x1B4FDD00L},
+{0x1F289780L, 0x00B99100L, 0x001D8400L, 0x0C20FC00L,    /* ZSYNTH */
+ 0x1BDD7980L, 0xB0}, 
+ 0x08000000L,   /* TXACGAIN */
+ 0x00FF7E00L,   /* RXACGAIN */
+ 0x07BB4B80L, 0x1844B500L, 0x07769700L,    /* RXACHPF */
+#ifdef ENABLE_HIRES_GAIN
+ 0, 0  /* TXGAIN*10, RXGAIN*10 (hi_res) */
+#else
+ 0, 0  /* TXGAIN, RXGAIN */
+#endif
+ },  /* ZSYN_220_820_120_30_0 */
+/* Source: Database file: cwdb.db */
+/* Database information: */
+/* parameters: zref=600_0_0 rprot=20 rfuse=0 emi_cap=10*/
+{
+{0x07F97D80L, 0x0006CC00L, 0x1FFC1480L, 0x1FFC7B80L,    /* TXACEQ */
+ 0x07F36B80L, 0x000A8E00L, 0x1FF90F00L, 0x1FFAE500L},   /* RXACEQ */
+{0x001AF400L, 0x1FC86A80L, 0x01E9AE00L, 0x00652F00L,    /* ECFIR/ECIIR */
+ 0x01F4AF00L, 0x1F57E000L, 0x00485E00L, 0x1FF3A680L,
+ 0x1FF83700L, 0x00011D00L, 0x01706980L, 0x066A8480L},
+{0x00920F00L, 0x1EE31980L, 0x008ADF00L, 0x0F92E500L,    /* ZSYNTH */
+ 0x186CE880L, 0x53}, 
+ 0x085C6880L,   /* TXACGAIN */
+ 0x013E3100L,   /* RXACGAIN */
+ 0x07AF6F80L, 0x18509100L, 0x075EDF00L,    /* RXACHPF */
+#ifdef ENABLE_HIRES_GAIN
+ 0, 0  /* TXGAIN*10, RXGAIN*10 (hi_res) */
+#else
+ 0, 0  /* TXGAIN, RXGAIN */
+#endif
+ },  /* ZSYN_600_0_1000_30_0 */
+/* Source: Database file: cwdb.db */
+/* Database information: */
+/* parameters: zref=200_680_100 rprot=20 rfuse=0 emi_cap=10*/
+{
+{0x0721FD00L, 0x1FD2AA80L, 0x00027E80L, 0x1FFD4300L,    /* TXACEQ */
+ 0x09B7CF80L, 0x1D33A080L, 0x006DD680L, 0x1FE08A00L},   /* RXACEQ */
+{0x1FF93B80L, 0x00365F80L, 0x00DDBA00L, 0x0129A800L,    /* ECFIR/ECIIR */
+ 0x0311AA80L, 0x1E718200L, 0x02D3AB80L, 0x1E303E80L,
+ 0x01181C00L, 0x1EE22300L, 0x051CA700L, 0x02C7AE00L},
+{0x01484900L, 0x1C91C280L, 0x0225C700L, 0x0A131400L,    /* ZSYNTH */
+ 0x1DEA8F80L, 0x8B}, 
+ 0x08000000L,   /* TXACGAIN */
+ 0x010ABA80L,   /* RXACGAIN */
+ 0x07BA3000L, 0x1845D080L, 0x07745F80L,    /* RXACHPF */
+#ifdef ENABLE_HIRES_GAIN
+ 0, 0  /* TXGAIN*10, RXGAIN*10 (hi_res) */
+#else
+ 0, 0  /* TXGAIN, RXGAIN */
+#endif
+ },  /* ZSYN_200_680_100_30_0 */
+/* Source: Database file: cwdb.db */
+/* Database information: */
+/* parameters: zref=220_820_115 rprot=20 rfuse=0 emi_cap=10*/
+{
+{0x06BFCA00L, 0x1FE56180L, 0x00094A00L, 0x1FFE0400L,    /* TXACEQ */
+ 0x0A544B80L, 0x1C108680L, 0x0093D180L, 0x1FD7FC80L},   /* RXACEQ */
+{0x00227280L, 0x1FB49D80L, 0x01826F80L, 0x01397480L,    /* ECFIR/ECIIR */
+ 0x01D0C900L, 0x01665C00L, 0x000EA200L, 0x007D2480L,
+ 0x0014DC00L, 0x1FE90800L, 0x0C998B00L, 0x1B584400L},
+{0x00331500L, 0x1E4B8B80L, 0x0180EF00L, 0x0A138100L,    /* ZSYNTH */
+ 0x1DEA2380L, 0xA3}, 
+ 0x08000000L,   /* TXACGAIN */
+ 0x00FDFD80L,   /* RXACGAIN */
+ 0x07BB1C80L, 0x1844E400L, 0x07763880L,    /* RXACHPF */
+#ifdef ENABLE_HIRES_GAIN
+ 0, 0  /* TXGAIN*10, RXGAIN*10 (hi_res) */
+#else
+ 0, 0  /* TXGAIN, RXGAIN */
+#endif
+ },  /* ZSYN_220_820_115_30_0 */
+/* Source: Database file: cwdb.db */
+/* Database information: */
+/* parameters: zref=600_0_0 rprot=20 rfuse=0 emi_cap=0*/
+{
+{0x0817F080L, 0x1FE39600L, 0x0005A280L, 0x1FFC7600L,    /* TXACEQ */
+ 0x07FA6E80L, 0x1FFD4F80L, 0x1FF80500L, 0x1FFDE780L},   /* RXACEQ */
+{0x00538E00L, 0x1F47A800L, 0x02957D00L, 0x00128700L,    /* ECFIR/ECIIR */
+ 0x0194DD80L, 0x000E7100L, 0x1FC5B180L, 0x00061600L,
+ 0x0021B480L, 0x1FE88600L, 0x1FCAD600L, 0x1FD00E80L},
+{0x006A0F00L, 0x1F499F80L, 0x004C8900L, 0x0A152400L,    /* ZSYNTH */
+ 0x1DE9B580L, 0x68}, 
+ 0x08419500L,   /* TXACGAIN */
+ 0x01365F00L,   /* RXACGAIN */
+ 0x07BB5700L, 0x1844A980L, 0x0776AE80L,    /* RXACHPF */
+#ifdef ENABLE_HIRES_GAIN
+ 0, 0  /* TXGAIN*10, RXGAIN*10 (hi_res) */
+#else
+ 0, 0  /* TXGAIN, RXGAIN */
+#endif
+ }   /* WB_ZSYN_600_0_0_20_0 */
+};
+
+Si3226x_FSK_Cfg Si3226x_FSK_Presets[] ={
+{
+{
+0x02232000L,     /* FSK01 */
+0x077C2000L      /* FSK10 */
+},
+{
+0x0015C000L,     /* FSKAMP0 (0.080 vrms )*/
+0x000BA000L      /* FSKAMP1 (0.080 vrms) */
+},
+{
+0x06B60000L,     /* FSKFREQ0 (2200.0 Hz space) */
+0x079C0000L      /* FSKFREQ1 (1200.0 Hz mark) */
+},
+0x00,             /* FSK8 */
+0x00,             /* FSKDEPTH (1 deep fifo) */
+},  /* DEFAULT_FSK */
+{
+{
+0x026E4000L,     /* FSK01 */
+0x0694C000L      /* FSK10 */
+},
+{
+0x0014C000L,     /* FSKAMP0 (0.080 vrms )*/
+0x000CA000L      /* FSKAMP1 (0.080 vrms) */
+},
+{
+0x06D20000L,     /* FSKFREQ0 (2100.0 Hz space) */
+0x078B0000L      /* FSKFREQ1 (1300.0 Hz mark) */
+},
+0x00,             /* FSK8 */
+0x00,             /* FSKDEPTH (1 deep fifo) */
+}   /* ETSI_FSK */
+};
+
+Si3226x_PulseMeter_Cfg Si3226x_PulseMeter_Presets[] ={
+{
+0x007A2B6AL,  /* PM_AMP_THRESH (1.000) */
+0,            /* Freq (12kHz) */ 
+0,            /* PM_AUTO (off)*/
+0x07D00000L,  /* PM_active (2000 ms) */
+0x07D00000L   /* PM_inactive (2000 ms) */
+ }   /* DEFAULT_PULSE_METERING */
+};
+
+Si3226x_Tone_Cfg Si3226x_Tone_Presets[] = {
+{
+    {
+    0x07B30000L,     /* OSC1FREQ (350.000 Hz) */
+    0x000C6000L,     /* OSC1AMP (-18.000 dBm) */
+    0x00000000L,     /* OSC1PHAS (0.000 rad) */
+    0x00,             /* O1TALO (0 ms) */
+    0x00,             /* O1TAHI */
+    0x00,             /* O1TILO (0 ms) */
+    0x00             /* O1TIHI */
+    },
+    {
+    0x07870000L,     /* OSC2FREQ (440.000 Hz) */
+    0x000FA000L,     /* OSC2AMP (-18.000 dBm) */
+    0x00000000L,     /* OSC2PHAS (0.000 rad) */
+    0x00,             /* O2TALO (0 ms) */
+    0x00,             /* O2TAHI */
+    0x00,             /* O2TILO (0 ms) */
+    0x00              /* O2TIHI */
+    },
+    0x66              /* OMODE */
+},  /* TONEGEN_FCC_DIAL */
+{
+    {
+    0x07700000L,     /* OSC1FREQ (480.000 Hz) */
+    0x00112000L,     /* OSC1AMP (-18.000 dBm) */
+    0x00000000L,     /* OSC1PHAS (0.000 rad) */
+    0xA0,             /* O1TALO (500 ms) */
+    0x0F,             /* O1TAHI */
+    0xA0,             /* O1TILO (500 ms) */
+    0x0F             /* O1TIHI */
+    },
+    {
+    0x07120000L,     /* OSC2FREQ (620.000 Hz) */
+    0x00164000L,     /* OSC2AMP (-18.000 dBm) */
+    0x00000000L,     /* OSC2PHAS (0.000 rad) */
+    0xA0,             /* O2TALO (500 ms) */
+    0x0F,             /* O2TAHI */
+    0xA0,             /* O2TILO (500 ms) */
+    0x0F              /* O2TIHI */
+    },
+    0x66              /* OMODE */
+},  /* TONEGEN_FCC_BUSY */
+{
+    {
+    0x07700000L,     /* OSC1FREQ (480.000 Hz) */
+    0x00112000L,     /* OSC1AMP (-18.000 dBm) */
+    0x00000000L,     /* OSC1PHAS (0.000 rad) */
+    0x80,             /* O1TALO (2000 ms) */
+    0x3E,             /* O1TAHI */
+    0x00,             /* O1TILO (4000 ms) */
+    0x7D             /* O1TIHI */
+    },
+    {
+    0x07870000L,     /* OSC2FREQ (440.000 Hz) */
+    0x000FA000L,     /* OSC2AMP (-18.000 dBm) */
+    0x00000000L,     /* OSC2PHAS (0.000 rad) */
+    0x80,             /* O2TALO (2000 ms) */
+    0x3E,             /* O2TAHI */
+    0x00,             /* O2TILO (4000 ms) */
+    0x7D              /* O2TIHI */
+    },
+    0x66              /* OMODE */
+},  /* TONEGEN_FCC_RINGBACK */
+{
+    {
+    0x07700000L,     /* OSC1FREQ (480.000 Hz) */
+    0x00112000L,     /* OSC1AMP (-18.000 dBm) */
+    0x00000000L,     /* OSC1PHAS (0.000 rad) */
+    0x60,             /* O1TALO (300 ms) */
+    0x09,             /* O1TAHI */
+    0x60,             /* O1TILO (300 ms) */
+    0x09             /* O1TIHI */
+    },
+    {
+    0x07120000L,     /* OSC2FREQ (620.000 Hz) */
+    0x00164000L,     /* OSC2AMP (-18.000 dBm) */
+    0x00000000L,     /* OSC2PHAS (0.000 rad) */
+    0x60,             /* O2TALO (300 ms) */
+    0x09,             /* O2TAHI */
+    0x40,             /* O2TILO (200 ms) */
+    0x06              /* O2TIHI */
+    },
+    0x66              /* OMODE */
+},  /* TONEGEN_FCC_REORDER */
+{
+    {
+    0x07700000L,     /* OSC1FREQ (480.000 Hz) */
+    0x00112000L,     /* OSC1AMP (-18.000 dBm) */
+    0x00000000L,     /* OSC1PHAS (0.000 rad) */
+    0x40,             /* O1TALO (200 ms) */
+    0x06,             /* O1TAHI */
+    0x40,             /* O1TILO (200 ms) */
+    0x06             /* O1TIHI */
+    },
+    {
+    0x07120000L,     /* OSC2FREQ (620.000 Hz) */
+    0x00164000L,     /* OSC2AMP (-18.000 dBm) */
+    0x00000000L,     /* OSC2PHAS (0.000 rad) */
+    0x40,             /* O2TALO (200 ms) */
+    0x06,             /* O2TAHI */
+    0x40,             /* O2TILO (200 ms) */
+    0x06              /* O2TIHI */
+    },
+    0x66              /* OMODE */
+},  /* TONEGEN_FCC_CONGESTION */
+{
+    {
+    0x1F2F0000L,     /* OSC1FREQ (2130.000 Hz) */
+    0x0063A000L,     /* OSC1AMP (-18.000 dBm) */
+    0x00000000L,     /* OSC1PHAS (0.000 rad) */
+    0x80,             /* O1TALO (80 ms) */
+    0x02,             /* O1TAHI */
+    0x80,             /* O1TILO (80 ms) */
+    0x02             /* O1TIHI */
+    },
+    {
+    0x1B8E0000L,     /* OSC2FREQ (2750.000 Hz) */
+    0x00A84000L,     /* OSC2AMP (-18.000 dBm) */
+    0x00000000L,     /* OSC2PHAS (0.000 rad) */
+    0x80,             /* O2TALO (80 ms) */
+    0x02,             /* O2TAHI */
+    0x40,             /* O2TILO (1000 ms) */
+    0x1F              /* O2TIHI */
+    },
+    0x66              /* OMODE */
+},  /* TONEGEN_FCC_CAS */
+{
+    {
+    0x07870000L,     /* OSC1FREQ (440.000 Hz) */
+    0x000FA000L,     /* OSC1AMP (-18.000 dBm) */
+    0x00000000L,     /* OSC1PHAS (0.000 rad) */
+    0x60,             /* O1TALO (300 ms) */
+    0x09,             /* O1TAHI */
+    0x00,             /* O1TILO (8000 ms) */
+    0xFA             /* O1TIHI */
+    },
+    {
+    0x1B8E0000L,     /* OSC2FREQ (2750.000 Hz) */
+    0x00A84000L,     /* OSC2AMP (-18.000 dBm) */
+    0x00000000L,     /* OSC2PHAS (0.000 rad) */
+    0x80,             /* O2TALO (2000 ms) */
+    0x3E,             /* O2TAHI */
+    0x00,             /* O2TILO (4000 ms) */
+    0x7D              /* O2TIHI */
+    },
+    0x06              /* OMODE */
+},  /* TONEGEN_FCC_SAS */
+{
+    {
+    0x1F2F0000L,     /* OSC1FREQ (2130.000 Hz) */
+    0x01BD0000L,     /* OSC1AMP (-5.000 dBm) */
+    0x00000000L,     /* OSC1PHAS (0.000 rad) */
+    0x20,             /* O1TALO (100 ms) */
+    0x03,             /* O1TAHI */
+    0x20,             /* O1TILO (100 ms) */
+    0x03             /* O1TIHI */
+    },
+    {
+    0x1B8E0000L,     /* OSC2FREQ (2750.000 Hz) */
+    0x02EFC000L,     /* OSC2AMP (-5.000 dBm) */
+    0x00000000L,     /* OSC2PHAS (0.000 rad) */
+    0x20,             /* O2TALO (100 ms) */
+    0x03,             /* O2TAHI */
+    0x20,             /* O2TILO (100 ms) */
+    0x03              /* O2TIHI */
+    },
+    0x66              /* OMODE */
+},  /* TONEGEN_ETSI_DTAS */
+{
+    {
+    0x05A40000L,     /* OSC1FREQ (1004.000 Hz) */
+    0x005DE000L,     /* OSC1AMP (-10.000 dBm) */
+    0x00000000L,     /* OSC1PHAS (0.000 rad) */
+    0x00,             /* O1TALO (8000 ms) */
+    0xFA,             /* O1TAHI */
+    0x00,             /* O1TILO (8000 ms) */
+    0xFA             /* O1TIHI */
+    },
+    {
+    0x07870000L,     /* OSC2FREQ (440.000 Hz) */
+    0x000FA000L,     /* OSC2AMP (-18.000 dBm) */
+    0x00000000L,     /* OSC2PHAS (0.000 rad) */
+    0x80,             /* O2TALO (2000 ms) */
+    0x3E,             /* O2TAHI */
+    0x00,             /* O2TILO (4000 ms) */
+    0x7D              /* O2TIHI */
+    },
+    0x47              /* OMODE */
+}   /* TONEGEN_1004 */
+};
+
+Si3226x_PCM_Cfg Si3226x_PCM_Presets[] ={
+    {
+    0x01,      /* PCM_FMT - u-Law */
+    0x00,      /* WIDEBAND - DISABLED (3.4kHz BW) */
+    0x00,      /* PCM_TRI - PCLK RISING EDGE */
+    0x00,      /* TX_EDGE - PCLK RISING EDGE */
+    0x00      /* A-LAW -  INVERT NONE */
+    },  /* PCM_8ULAW */
+    {
+    0x00,      /* PCM_FMT - A-Law */
+    0x00,      /* WIDEBAND - DISABLED (3.4kHz BW) */
+    0x00,      /* PCM_TRI - PCLK RISING EDGE */
+    0x00,      /* TX_EDGE - PCLK RISING EDGE */
+    0x00      /* A-LAW -  INVERT NONE */
+    },  /* PCM_8ALAW */
+    {
+    0x03,      /* PCM_FMT - 16-bit Linear */
+    0x00,      /* WIDEBAND - DISABLED (3.4kHz BW) */
+    0x00,      /* PCM_TRI - PCLK RISING EDGE */
+    0x00,      /* TX_EDGE - PCLK RISING EDGE */
+    0x00      /* A-LAW -  INVERT NONE */
+    },  /* PCM_16LIN */
+    {
+    0x03,      /* PCM_FMT - 16-bit Linear */
+    0x01,      /* WIDEBAND - ENABLED (7kHz BW) */
+    0x00,      /* PCM_TRI - PCLK RISING EDGE */
+    0x00,      /* TX_EDGE - PCLK RISING EDGE */
+    0x00      /* A-LAW -  INVERT NONE */
+    }   /* PCM_16LIN_WB */
+};
+
Index: linux-5.4.171/sound/soc/codecs/si3218x/src/si3226x_intf.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-5.4.171/sound/soc/codecs/si3218x/src/si3226x_intf.c	2022-02-22 10:59:29.000000000 +0800
@@ -0,0 +1,3442 @@
+/*
+** Copyright (c) 2007-2017 by Silicon Laboratories
+**
+** $Id: si3226x_intf.c 48623 2020-01-09 06:37:04Z ahuang $
+**
+** SI3226X ProSLIC interface implementation file
+**
+** Author(s):
+** laj
+**
+** Distributed by:
+** Silicon Laboratories, Inc
+**
+** This file contains proprietary information.
+** No dissemination allowed without prior written permission from
+** Silicon Laboratories, Inc.
+**
+** File Description:
+** This is the interface file for the Si3226x family of chips.
+**
+*/
+
+#include "../config_inc/si_voice_datatypes.h"
+#include "../inc/si_voice_ctrl.h"
+#include "../inc/si_voice_timer_intf.h"
+#include "../config_inc/proslic_api_config.h"
+#include "../inc/proslic.h"
+#include "../inc/si3226x.h"
+#include "../inc/si3226x_intf.h"
+#include "../inc/si3226x_registers.h"
+
+#define DEVICE_KEY_MIN              0x64
+#define DEVICE_KEY_MAX              0x6D
+
+#define WriteReg        pProslic->deviceId->ctrlInterface->WriteRegister_fptr
+#define ReadReg         pProslic->deviceId->ctrlInterface->ReadRegister_fptr
+#define pProHW          pProslic->deviceId->ctrlInterface->hCtrl
+#define Reset           pProslic->deviceId->ctrlInterface->Reset_fptr
+#define Delay           pProslic->deviceId->ctrlInterface->Delay_fptr
+#define pProTimer       pProslic->deviceId->ctrlInterface->hTimer
+#define WriteRAM        pProslic->deviceId->ctrlInterface->WriteRAM_fptr
+#define ReadRAM         pProslic->deviceId->ctrlInterface->ReadRAM_fptr
+#define TimeElapsed     pProslic->deviceId->ctrlInterface->timeElapsed_fptr
+#define getTime         pProslic->deviceId->ctrlInterface->getTime_fptr
+
+#define WriteRegX       deviceId->ctrlInterface->WriteRegister_fptr
+#define ReadRegX        deviceId->ctrlInterface->ReadRegister_fptr
+#define pProHWX         deviceId->ctrlInterface->hCtrl
+#define DelayX          deviceId->ctrlInterface->Delay_fptr
+#define pProTimerX      deviceId->ctrlInterface->hTimer
+#define WriteRAMX       deviceId->ctrlInterface->WriteRAM_fptr
+#define ReadRAMX        deviceId->ctrlInterface->ReadRAM_fptr
+#define getTimeX        deviceId->ctrlInterface->getTime_fptr
+#define TimeElapsedX    deviceId->ctrlInterface->timeElapsed_fptr
+
+#ifdef ENABLE_DEBUG
+static const char LOGPRINT_PREFIX[] = "Si3226x: ";
+#endif
+
+/*
+** Define patch parameters that can be modified by API
+*/
+#define SI3226X_PRAM_VBATH_NEON         799
+
+/*
+** Parameter Limits
+*/
+#define QSS_IRING_LIM_MAX     0x8B9786L   /* 60mA */
+#define SI3226X_IRING_LIM_MAX 0xA00000L   /* 103mA */
+
+/*
+** Externs
+*/
+
+/* General Configuration */
+extern Si3226x_General_Cfg Si3226x_General_Configuration;
+#ifdef SIVOICE_MULTI_BOM_SUPPORT
+extern const proslicPatch SI3226X_PATCH_C_FLBK;
+extern const proslicPatch SI3226X_PATCH_C_QCUK;
+extern const proslicPatch SI3226X_PATCH_C_LCQCUK;
+extern const proslicPatch SI3226X_PATCH_C_CUK;
+extern const proslicPatch SI3226X_PATCH_C_TSS;
+extern const proslicPatch SI3226X_PATCH_C_TSS_ISO;
+extern const proslicPatch SI3226X_PATCH_C_PBB;
+extern const proslicPatch SI3226X_PATCH_C_QSS;
+extern const proslicPatch SI3226X_PATCH_C_BB;
+extern Si3226x_General_Cfg Si3226x_General_Configuration_MultiBOM[];
+extern int si3226x_genconf_multi_max_preset;
+#else
+extern const proslicPatch SI3226X_PATCH_C_DEFAULT;
+#endif
+
+/* Ringing */
+#ifndef DISABLE_RING_SETUP
+extern Si3226x_Ring_Cfg Si3226x_Ring_Presets[];
+#endif
+
+/* Zsynth */
+#ifndef DISABLE_ZSYNTH_SETUP
+extern Si3226x_Impedance_Cfg Si3226x_Impedance_Presets [];
+#endif
+
+/* CI/GCI */
+#ifndef DISABLE_CI_SETUP
+extern Si3226x_CI_Cfg Si3226x_CI_Presets [];
+#endif
+
+/* Audio Gain Scratch */
+extern Si3226x_audioGain_Cfg Si3226x_audioGain_Presets[];
+
+/* DC Feed */
+#ifndef DISABLE_DCFEED_SETUP
+extern Si3226x_DCfeed_Cfg Si3226x_DCfeed_Presets[];
+#endif
+
+/* GPIO */
+#ifndef DISABLE_GPIO_SETUP
+extern Si3226x_GPIO_Cfg Si3226x_GPIO_Configuration ;
+#endif
+
+/* Pulse Metering */
+#ifndef DISABLE_PULSE_SETUP
+extern Si3226x_PulseMeter_Cfg Si3226x_PulseMeter_Presets [];
+#endif
+
+/* PCM */
+#ifndef DISABLE_PCM_SETUP
+extern Si3226x_PCM_Cfg Si3226x_PCM_Presets [];
+#endif
+
+extern BOOLEAN ProSLIC_LoadPatch_extended(proslicChanType *pProslic,
+                                   const proslicPatch *pPatch, 
+                                   BOOLEAN is_broadcast, BOOLEAN is_second_chan);
+
+/*
+** Local functions are defined first
+*/
+
+/*
+** Function: getChipType
+**
+** Description:
+** Decode ID register to identify chip type
+**
+** Input Parameters:
+** ID register value
+**
+** Return:
+** partNumberType
+*/
+static partNumberType getChipType(uInt8 lsbs, uInt8 msb)
+{
+  uInt8 part_num;
+  lsbs &= 0x38; /* PART_NUM[2:0] = ID[5:3] */
+  lsbs >>= 3;
+  msb &= 0x80;  /* PART_NUM[3] = ENHANCE[7] */
+  msb >>= 4;
+  part_num = msb | lsbs;
+
+  /* Need to identify specific, supported part numbers */
+  if(part_num == 0x00)
+  {
+    return(SI32260);
+  }
+  if(part_num == 0x04)
+  {
+    return(SI32360);
+  }
+  if(part_num == 0x08)
+  {
+    return(SI32266);
+  }
+  if(part_num == 0x0A)
+  {
+    return(SI32268);
+  }
+
+  return (UNSUPPORTED_PART_NUM);
+}
+
+int Si3226x_GetChipInfo(proslicChanType_ptr pProslic)
+{
+  uInt8 id, enhance;
+
+  id = ReadReg(pProHW, pProslic->channel, ID);
+  enhance= ReadReg(pProHW, pProslic->channel, ENHANCE);
+  pProslic->deviceId->chipRev = id & 0x7;
+  pProslic->deviceId->chipType = getChipType(id, enhance);
+
+  if(pProslic->deviceId->chipType  == UNSUPPORTED_PART_NUM)
+  {
+#ifdef ENABLE_DEBUG
+    LOGPRINT("%sregister 0 read = 0x%02X\n", LOGPRINT_PREFIX, id);
+#endif
+    return RC_SPI_FAIL;
+  }
+  else
+  {
+    return RC_NONE;
+  }
+}
+
+/*
+** Function: Si3226x_PowerUpConverter
+**
+** Description:
+** Powers all DC/DC converters sequentially with delay to minimize
+** peak power draw on VDC.
+**
+** Returns:
+** int (error)
+**
+*/
+int Si3226x_PowerUpConverter(proslicChanType_ptr pProslic)
+{
+  errorCodeType error = RC_NONE;
+  int32 vbath,vbat;
+  uInt8 reg;
+  ramData data;
+  int timer = 0;
+
+  /*
+  ** Check to see if already powered, return if so
+  */
+  data = ReadRAM(pProHW,pProslic->channel,PD_DCDC);
+  if(!(data & 0x100000))
+  {
+    return RC_NONE;   /* Return if already powered up */
+  }
+
+  /*
+  ** Power up sequence
+  */
+  if(Si3226x_General_Configuration.batType == BO_DCDC_TRACKING)
+  {
+    /*
+    ** TRACKING CONVERTER SEQUENCE
+    **
+    ** - clear previous ov/uv lockout
+    ** - powerup charge pump
+    ** - delay
+    ** - powerup digital dc/dc w/ OV clamping and shutdown
+    ** - delay
+    ** - verify no short circuits by looking for vbath/2
+    ** - clear dcdc status
+    ** - switch to analog converter with OV clamping only (no shutdown)
+    ** - select analog dcdc and disable pwrsave
+    ** - delay
+    */
+
+    WriteRAM(pProHW,pProslic->channel,DCDC_OITHRESH,
+             Si3226x_General_Configuration.dcdc_oithresh_lo);
+    WriteReg(pProHW,pProslic->channel,LINEFEED,
+             LF_OPEN);  /* Ensure open before powering converter */
+    reg = ReadReg(pProHW,pProslic->channel,
+                  ENHANCE);      /* Read ENHANCE entry settings */
+    WriteReg(pProHW,pProslic->channel,ENHANCE,
+             reg&0x07);  /* Disable powersave during bringup */
+    WriteRAM(pProHW,pProslic->channel,PD_DCDC,
+             0x700000L);   /* In case OV or UV previously occurred */
+    /* Interim support for higher voltage PBB that uses gate drive circuit */
+    if(((pProslic->dcdc_polarity_invert)
+        &&(Si3226x_General_Configuration.bomOpt == BO_DCDC_PMOS_BUCK_BOOST))
+        || (Si3226x_General_Configuration.bomOpt ==  BO_DCDC_BUCK_BOOST) )
+    {
+      WriteRAM(pProHW,pProslic->channel,DCDC_CPUMP,0x0L);/* Turn off charge pump */
+    }
+    else
+    {
+      WriteRAM(pProHW,pProslic->channel,DCDC_CPUMP,
+               0x100000L);/* Turn on charge pump */
+    }
+    Delay(pProTimer,10);
+    WriteRAM(pProHW,pProslic->channel,PD_DCDC,0x600000L);
+    Delay(pProTimer,50);
+    vbath = ReadRAM(pProHW,pProslic->channel,VBATH_EXPECT);
+    vbat = ReadRAM(pProHW,pProslic->channel,MADC_VBAT);
+    if(vbat & 0x10000000L)
+    {
+      vbat |= 0xF0000000L;
+    }
+    DEBUG_PRINT (pProslic, "%sVBAT @ 50ms = %d.%d v\n",
+                 LOGPRINT_PREFIX, (int)((vbat/SCALE_V_MADC)/1000),
+                 (int)(((vbat/SCALE_V_MADC) - (vbat/SCALE_V_MADC)/1000*1000)));
+    if(vbat < (vbath / 2))
+    {
+      pProslic->channelEnable = 0;
+      error = RC_VBAT_UP_TIMEOUT;
+      WriteRAM(pProHW,pProslic->channel,PD_DCDC, 0x300000L); /* shutdown converter */
+      DEBUG_PRINT (pProslic, "%sDCDC Short Circuit Failure %d - disabling channel\n",
+                   LOGPRINT_PREFIX, pProslic->channel);
+      return error;
+    }
+    else   /* Enable analog converter */
+    {
+      WriteRAM(pProHW,pProslic->channel,DCDC_STATUS,0L);
+      WriteRAM(pProHW,pProslic->channel,PD_DCDC,0x400000L);
+      WriteReg(pProHW,pProslic->channel,ENHANCE,reg);   /* restore ENHANCE setting */
+      Delay(pProTimer,50);
+    }
+
+    /*
+    ** - monitor vbat vs expected level (VBATH_EXPECT)
+    */
+    vbath = ReadRAM(pProHW,pProslic->channel,VBATH_EXPECT);
+    do
+    {
+      vbat = ReadRAM(pProHW,pProslic->channel,MADC_VBAT);
+      if(vbat & 0x10000000L)
+      {
+        vbat |= 0xF0000000L;
+      }
+      Delay(pProTimer,10);
+    }
+    while((vbat < (vbath - COMP_5V))&&(timer++ < 200));   /* 2 sec timeout */
+
+    DEBUG_PRINT (pProslic, "%sVBAT Up = %d.%d v\n",
+                 LOGPRINT_PREFIX,
+                 (int)((vbat/SCALE_V_MADC)/1000),
+                 (int)(((vbat/SCALE_V_MADC) - (vbat/SCALE_V_MADC)/1000*1000)));
+    if(timer > 200)
+    {
+      /* Error handling - shutdown converter, disable channel, set error tag */
+      pProslic->channelEnable = 0;
+      error = RC_VBAT_UP_TIMEOUT;
+      WriteRAM(pProHW,pProslic->channel,PD_DCDC, 0x300000L); /* shutdown converter */
+      DEBUG_PRINT (pProslic,
+                   "%sDCDC Power up timeout channel %d - disabling channel\n",
+                   LOGPRINT_PREFIX, pProslic->channel);
+    }
+    return error;
+  }
+  else if((Si3226x_General_Configuration.batType == BO_DCDC_TSS)||
+          (Si3226x_General_Configuration.batType == BO_DCDC_TSS_ISO)||
+          Si3226x_General_Configuration.batType == BO_DCDC_QSS)
+  {
+    /*
+    ** FIXED RAIL CONVERTER SEQUENCE
+    **
+    ** - return if even channel
+    ** - clear previous ov/uv lockout
+    ** - powerup charge pump
+    ** - delay
+    ** - powerup converter
+    ** - delay
+    ** - verify no short circuits by looking for vbath/2
+    ** - clear dcdc status
+    ** - delay
+    */
+
+    if( (pProslic->channel &1) == 0)  /* is even */
+    {
+      DEBUG_PRINT(pProslic, "%sDCDC Powerup Channel %d Ignored\n", LOGPRINT_PREFIX,
+                  pProslic->channel);
+      return RC_IGNORE;
+    }
+
+    WriteReg(pProHW,pProslic->channel,LINEFEED,
+             LF_OPEN);  /* Ensure open before powering converter */
+    reg = ReadReg(pProHW,pProslic->channel,
+                  ENHANCE);      /* Read ENHANCE entry settings */
+    WriteReg(pProHW,pProslic->channel,ENHANCE,
+             reg&0x07);  /* Disable powersave during bringup */
+    WriteRAM(pProHW,pProslic->channel,PD_DCDC,
+             0x700000L);   /* In case OV or UV previously occurred */
+    WriteRAM(pProHW,pProslic->channel,DCDC_CPUMP,
+             0x100000L);/* Turn on charge pump */
+    Delay(pProTimer,10);
+    WriteRAM(pProHW,pProslic->channel,PD_DCDC,0x600000L);   /* Start Converter */
+    Delay(pProTimer,500);
+
+    /* If isolated design, turn off charge pump and powerdown OCLO */
+    if(Si3226x_General_Configuration.batType == BO_DCDC_TSS_ISO)
+    {
+      WriteRAM(pProHW,pProslic->channel,DCDC_CPUMP,0x0L);
+      Delay(pProTimer,10);
+      WriteRAM(pProHW,pProslic->channel,PD_OCLO,0x300000L);
+      Delay(pProTimer,30);
+    }
+    vbath = ReadRAM(pProHW,pProslic->channel,VBATH_EXPECT);
+    vbat = ReadRAM(pProHW,pProslic->channel,MADC_VBAT);
+    if(vbat & 0x10000000L)
+    {
+      vbat |= 0xF0000000L;
+    }
+    if(vbath & 0x10000000L)
+    {
+      vbath |= 0xF0000000L;
+    }
+
+    if(vbat < (vbath / 2))
+    {
+      pProslic->channelEnable = 0;
+      error = RC_VBAT_UP_TIMEOUT;
+      WriteRAM(pProHW,pProslic->channel,PD_DCDC, 0x300000L); /* shutdown converter */
+      Delay(pProTimer,30);
+      WriteRAM(pProHW,pProslic->channel,DCDC_CPUMP,0x0L); /* shut off charge pump */
+
+      DEBUG_PRINT (pProslic, "%sDCDC Short Circuit Failure %d - disabling channel\n",
+                   LOGPRINT_PREFIX,
+                   pProslic->channel);
+      return error;
+    }
+    else
+    {
+      WriteRAM(pProHW,pProslic->channel,DCDC_STATUS,0L);
+      Delay(pProTimer,50);
+    }
+
+    /*
+    ** - monitor vbat vs expected level (VBATH_EXPECT)
+    */
+    vbath = ReadRAM(pProHW,pProslic->channel,VBATH_EXPECT);
+    do
+    {
+      vbat = ReadRAM(pProHW,pProslic->channel,MADC_VBAT);
+      if(vbat & 0x10000000L)
+      {
+        vbat |= 0xF0000000L;
+      }
+      Delay(pProTimer,10);
+    }
+    while((vbat < (vbath - COMP_5V))&&(timer++ < 200));   /* 2 sec timeout */
+
+    DEBUG_PRINT (pProslic, "%sFixed VBAT Up = %d.%d v\n",
+                 LOGPRINT_PREFIX, (int)((vbat/SCALE_V_MADC)/1000),
+                 (int)(((vbat/SCALE_V_MADC) - (vbat/SCALE_V_MADC)/1000*1000)));
+
+    if(timer > 200)
+    {
+      /* Error handling - shutdown converter, disable channel, set error tag */
+      pProslic->channelEnable = 0;
+      error = RC_VBAT_UP_TIMEOUT;
+      WriteRAM(pProHW,pProslic->channel,PD_DCDC, 0x300000L); /* shutdown converter */
+      DEBUG_PRINT (pProslic,
+                   "%sDCDC Fixed Rail Power up timeout channel %d - disabling channel\n",
+                   LOGPRINT_PREFIX, pProslic->channel);
+    }
+
+    /* Restore ENHANCE reg */
+    WriteReg(pProHW,pProslic->channel,ENHANCE,reg);
+    return error;
+  }
+  else /* external battery - just verify presence */
+  {
+    /*
+    ** - monitor vbat vs expected level (VBATH_EXPECT)
+    */
+    vbath = ReadRAM(pProHW,pProslic->channel,VBATH_EXPECT);
+    do
+    {
+      vbat = ReadRAM(pProHW,pProslic->channel,MADC_VBAT);
+      if(vbat & 0x10000000L)
+      {
+        vbat |= 0xF0000000L;
+      }
+      Delay(pProTimer,10);
+    }
+    while((vbat < (vbath - COMP_5V))&&(timer++ < 200));   /* 2 sec timeout */
+
+    DEBUG_PRINT (pProslic, "%sExt VBAT Up = %d.%d v\n",
+                 LOGPRINT_PREFIX,
+                 (int)((vbat/SCALE_V_MADC)/1000),
+                 (int)(((vbat/SCALE_V_MADC) - (vbat/SCALE_V_MADC)/1000*1000)));
+    if(timer > 200)
+    {
+      /* Error handling - shutdown converter, disable channel, set error tag */
+      pProslic->channelEnable = 0;
+      error = RC_VBAT_UP_TIMEOUT;
+      DEBUG_PRINT (pProslic,
+                   "%sExternal VBAT timeout channel %d - disabling channel\n",
+                   LOGPRINT_PREFIX, pProslic->channel);
+    }
+  }
+
+  return error;
+}
+
+/*
+**
+** PROSLIC INITIALIZATION FUNCTIONS
+**
+*/
+
+/*
+** Function: Si3226x_Init_MultiBOM
+**
+** Description:
+** - probe SPI to establish daisy chain length
+** - load patch
+** - initialize general parameters
+** - calibrate madc
+** - bring up DC/DC converters
+** - calibrate remaining items except madc & lb
+**
+** Input Parameters:
+** pProslic: pointer to PROSLIC object array
+** fault: error code
+**
+** Return:
+** error code
+*/
+
+#ifdef SIVOICE_MULTI_BOM_SUPPORT
+
+int Si3226x_Init_MultiBOM(proslicChanType_ptr *pProslic,int size, int preset)
+{
+
+  if(preset < si3226x_genconf_multi_max_preset)
+  {
+    /* Copy selected General COnfiguration parameters to std structure */
+    Si3226x_General_Configuration = Si3226x_General_Configuration_MultiBOM[preset];
+  }
+  else
+  {
+    return RC_INVALID_PRESET;
+  }
+  return Si3226x_Init(pProslic,size);
+}
+#endif
+
+/* Deterimine which patch to load */
+static int Si3226x_SelectPatch(proslicChanType_ptr pProslic,
+  const proslicPatch **patch)
+{
+  if (pProslic->deviceId->chipRev == SI3226X_REVC )
+  {
+#ifdef SIVOICE_MULTI_BOM_SUPPORT
+    if(Si3226x_General_Configuration.batType == BO_DCDC_TRACKING)
+    {
+      if( (Si3226x_General_Configuration.bomOpt == BO_DCDC_FLYBACK)
+          || (Si3226x_General_Configuration.bomOpt == BO_DCDC_LCFB) 
+          || (Si3226x_General_Configuration.bomOpt == BO_DCDC_LCUB) )
+      {
+        *patch = &(SI3226X_PATCH_C_FLBK);
+      }
+      else if(Si3226x_General_Configuration.bomOpt == BO_DCDC_LCQC_7P6W)
+      {
+        *patch = &(SI3226X_PATCH_C_QCUK);
+      }
+      else if( (Si3226x_General_Configuration.bomOpt == BO_DCDC_LCQC_3W)
+               || (Si3226x_General_Configuration.bomOpt == BO_DCDC_LCQC_6W) )
+      {
+        *patch = &(SI3226X_PATCH_C_LCQCUK);
+      }
+      else if(Si3226x_General_Configuration.bomOpt == BO_DCDC_CUK)
+      {
+        *patch = &(SI3226X_PATCH_C_CUK);
+      }
+      else if((Si3226x_General_Configuration.bomOpt == BO_DCDC_P_BUCK_BOOST_5V)
+              ||(Si3226x_General_Configuration.bomOpt == BO_DCDC_P_BUCK_BOOST_12V)
+              ||(Si3226x_General_Configuration.bomOpt == BO_DCDC_P_BUCK_BOOST_12V_HV)
+              ||(Si3226x_General_Configuration.bomOpt == BO_DCDC_PMOS_BUCK_BOOST))
+      {
+        *patch = &(SI3226X_PATCH_C_PBB);
+      }
+      else if(Si3226x_General_Configuration.bomOpt == BO_DCDC_BUCK_BOOST)
+      {
+        *patch = &(SI3226X_PATCH_C_BB);
+      }
+    }
+    else if((Si3226x_General_Configuration.batType == BO_DCDC_TSS)
+            &&(Si3226x_General_Configuration.bomOpt == BO_DCDC_FLYBACK))
+    {
+#ifdef SIVOICE_NEON_MWI_SUPPORT /* PATCH DOES NOT SUPPORT MWI */
+      pProslic->channelEnable = 0;
+      pProslic->error = RC_INVALID_PATCH;
+      return RC_INVALID_PATCH;
+#else
+      *patch = &(SI3226X_PATCH_C_TSS);
+#endif
+    }
+    else if((Si3226x_General_Configuration.batType == BO_DCDC_TSS_ISO)
+            &&(Si3226x_General_Configuration.bomOpt == BO_DCDC_FLYBACK))
+    {
+#ifdef SIVOICE_NEON_MWI_SUPPORT /* PATCH DOES NOT SUPPORT MWI */
+      pProslic->channelEnable = 0;
+      pProslic->error = RC_INVALID_PATCH;
+      return RC_INVALID_PATCH;
+#else
+     *patch = &(SI3226X_PATCH_C_TSS_ISO);
+#endif
+    }
+    else if((Si3226x_General_Configuration.batType == BO_DCDC_QSS)
+            &&(Si3226x_General_Configuration.bomOpt == BO_DCDC_QCUK))
+    {
+#ifdef SIVOICE_NEON_MWI_SUPPORT /* PATCH DOES NOT SUPPORT MWI */
+      pProslic->channelEnable = 0;
+      pProslic->error = RC_INVALID_PATCH;
+      return RC_INVALID_PATCH;
+#else
+      *patch = &(SI3226X_PATCH_C_QSS);
+#endif
+    }
+    else
+    {
+#ifdef ENABLE_DEBUG
+      if(pProslic->debugMode)
+      {
+        LOGPRINT("%sChannel %d : Invalid Patch\n",LOGPRINT_PREFIX,
+                 pProslic->channel);
+      }
+#endif
+      pProslic->channelEnable = 0;
+      pProslic->error = RC_INVALID_PATCH;
+      return RC_INVALID_PATCH;
+    }
+#else
+    *patch = &(SI3226X_PATCH_C_DEFAULT);
+#endif
+  }
+  else
+  {
+#ifdef ENABLE_DEBUG
+    if (pProslic->debugMode)
+    {
+      LOGPRINT("%sChannel %d : Unsupported Device Revision (%d)\n",
+               LOGPRINT_PREFIX,
+               pProslic->channel,pProslic->deviceId->chipRev );
+    }
+#endif
+    pProslic->channelEnable = 0;
+    pProslic->error = RC_UNSUPPORTED_DEVICE_REV;
+    return RC_UNSUPPORTED_DEVICE_REV;
+  }
+
+  return RC_NONE;
+}
+
+/*
+** Function: Si3226x_Init_with_Options
+**
+** Description:
+** - probe SPI to establish daisy chain length
+** - load patch
+** - initialize general parameters
+** - calibrate madc
+** - bring up DC/DC converters
+** - calibrate remaining items except madc & lb
+**
+** Input Parameters:
+** pProslic: pointer to PROSLIC object array
+** fault: error code
+**
+** Return:
+** error code
+*/
+
+int Si3226x_Init_with_Options (proslicChanType_ptr *pProslic, int size,
+                               initOptionsType init_opt)
+{
+  /*
+  ** This function will initialize the chipRev and chipType members in pProslic
+  ** as well as load the initialization structures.
+  */
+  uInt8 data;
+  uInt8 calSetup[] = {0x00, 0x00, 0x01, 0x80};  /* CALR0-CALR3 */
+  int k, status;
+  int device_count = 0;
+  const proslicPatch *patch = NULL;
+  ramData swdrv_pol;
+  ramData pdn_tmp;
+
+  LOGPRINT("%s(%d) size = %d init_opt = %d\n", __FUNCTION__, __LINE__, size,
+           init_opt);
+  data = Si3226x_General_Configuration.device_key;
+  /*
+  **
+  ** First qualify general parameters by identifying valid device key.  This
+  ** will prevent inadvertent use of other device's preset files, which could
+  ** lead to improper initialization and high current states.
+  */
+
+  if((data < DEVICE_KEY_MIN)||(data > DEVICE_KEY_MAX))
+  {
+    pProslic[0]->error = RC_INVALID_GEN_PARAM;
+    return pProslic[0]->error;
+  }
+
+  /* reset error code */
+  for(k = 0; k < size; k++)
+  {
+    pProslic[k]->error = RC_NONE;
+  }
+
+  if((init_opt == INIT_REINIT) || (init_opt == INIT_SOFTRESET))
+  {
+    /* Capture the linefeed state and perform a soft reset */
+    ProSLIC_ReInit_helper(pProslic, size, init_opt, SI3226X_CHAN_PER_DEVICE);
+  }
+ 
+  if( init_opt != INIT_REINIT )
+  {
+    if( (SiVoice_IdentifyChannels(pProslic, size, &device_count, NULL) != RC_NONE)
+        ||(device_count == 0) )
+    {
+      DEBUG_PRINT(*pProslic, "%s: failed to detect any ProSLICs\n", LOGPRINT_PREFIX);
+      return RC_SPI_FAIL;
+    }
+
+    /*
+    ** Probe each channel and enable all channels that respond
+    */
+    if(init_opt != INIT_REINIT)
+    {
+    for (k=0; k<size; k++)
+    {
+      if ((pProslic[k]->channelEnable)
+          &&(pProslic[k]->channelType == PROSLIC))
+      {
+        if ( (ProSLIC_VerifyMasterStat(pProslic[k]) != RC_NONE)
+             || (ProSLIC_VerifyControlInterface(pProslic[k]) != RC_NONE) )
+        {
+          pProslic[k]->channelEnable = 0;
+          pProslic[k]->error = RC_SPI_FAIL;
+          DEBUG_PRINT(*pProslic, "%s: SPI communications or PCLK/FS failure\n", LOGPRINT_PREFIX);
+          return pProslic[k]->error;    /* Halt init if SPI fail */
+        }
+      }
+    }
+    }
+  } /* init_opt */
+
+  if((init_opt != INIT_REINIT)&&(init_opt != INIT_NO_PATCH_LOAD) )
+  {
+    /**
+     * Load patch (do not enable until patch loaded on all channels)
+     */
+    for (k=0; k<size; k++)
+    {
+      if ((pProslic[k]->channelEnable)&&(pProslic[k]->channelType == PROSLIC))
+      {
+        status = Si3226x_SelectPatch(pProslic[k], &patch);
+
+        if(status != RC_NONE)
+        {
+          return status;
+        }
+
+        data = 1; /* Use this as a flag to see if we need to load the patch */
+        /* If the patch doesn't match, we need to do a full init, change settings */
+        if(init_opt == INIT_SOFTRESET) 
+        {
+          ramData patchData;
+          patchData = pProslic[k]->ReadRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                                            PROSLIC_RAM_PATCHID);
+
+          if( patchData ==  patch->patchSerial)
+          {
+            data = 0;
+          }
+          else
+          {
+            init_opt = INIT_NO_OPT;
+          }
+        } /* SOFTRESET */
+
+        if(data == 1)
+        {
+          ProSLIC_LoadPatch_extended(pProslic[k],patch, FALSE, (k&1));
+#ifndef DISABLE_VERIFY_PATCH
+          if(((k&1) == 0)) /* Verify only 1st channel per device */
+          {
+            data = (uInt8)ProSLIC_VerifyPatch(pProslic[k],patch);
+            if (data)
+            {
+              DEBUG_PRINT(pProslic[k], "%sChannel %d : Patch verification failed (%d)\n", 
+                   LOGPRINT_PREFIX, k, data);
+              pProslic[k]->channelEnable=0;
+              pProslic[k]->error = data;
+              return data;   /* Stop Init if patch load failure occurs */
+            }
+          }
+#endif
+          if( (k&1) == 1)
+          {
+            pProslic[k]->WriteRegX(pProslic[k]->pProHWX, pProslic[k]->channel, JMPEN,
+                                   1); /* Enable patch */
+          }
+        }
+      } /* PROSLIC */
+    } /* for loop */
+  } /* init_opt */
+  else
+  {
+    /* Since we did a soft reset, we need to reload the support RAM */
+    if(init_opt == INIT_REINIT)
+    {
+      for(k = 0; k < size; k++)
+      {
+        status = Si3226x_SelectPatch(pProslic[k], &patch);
+      
+        if(status != RC_NONE)
+        {
+          return status;
+        }
+
+        ProSLIC_LoadSupportRAM(pProslic[k], pProslic[k]->channel, 
+          patch->psRamAddr, patch->psRamData);
+      }
+    }
+  }
+
+  /*
+  ** Load general parameters - includes all BOM dependencies
+  **
+  */
+  if( init_opt != INIT_SOFTRESET )
+  {
+    for (k=0; k<size; k++)
+    {
+      if ((pProslic[k]->channelEnable)&&(pProslic[k]->channelType == PROSLIC))
+      {
+        ProSLIC_SetUserMode(pProslic[k],TRUE, FALSE);
+        /* Force pwrsave off and disable AUTO-tracking - set to user configured state after cal */
+        pProslic[k]->WriteRegX(pProslic[k]->pProHWX, pProslic[k]->channel,ENHANCE,0);
+        pProslic[k]->WriteRegX(pProslic[k]->pProHWX, pProslic[k]->channel,AUTO,0x2F);
+
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,BAT_HYST,
+                               Si3226x_General_Configuration.bat_hyst);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,VBATR_EXPECT,
+                               Si3226x_General_Configuration.vbatr_expect);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,VBATH_EXPECT,
+                               Si3226x_General_Configuration.vbath_expect);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,PWRSAVE_TIMER,
+                               Si3226x_General_Configuration.pwrsave_timer);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                               OFFHOOK_THRESH,Si3226x_General_Configuration.offhook_thresh);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                               VBAT_TRACK_MIN,Si3226x_General_Configuration.vbat_track_min);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                               VBAT_TRACK_MIN_RNG,Si3226x_General_Configuration.vbat_track_min_rng);
+
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,THERM_DBI,
+                               Si3226x_General_Configuration.therm_dbi);
+
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,DCDC_VERR,
+                               Si3226x_General_Configuration.dcdc_verr);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                               DCDC_VERR_HYST,Si3226x_General_Configuration.dcdc_verr_hyst);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                               DCDC_OITHRESH_LO,Si3226x_General_Configuration.dcdc_oithresh_lo);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                               DCDC_OITHRESH_HI,Si3226x_General_Configuration.dcdc_oithresh_hi);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,PD_UVLO,
+                               Si3226x_General_Configuration.pd_uvlo);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,PD_OVLO,
+                               Si3226x_General_Configuration.pd_ovlo);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,PD_OCLO,
+                               Si3226x_General_Configuration.pd_oclo);
+
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,DCDC_UVHYST,
+                               Si3226x_General_Configuration.dcdc_uvhyst);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,DCDC_UVTHRESH,
+                               Si3226x_General_Configuration.dcdc_uvthresh);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,DCDC_OVTHRESH,
+                               Si3226x_General_Configuration.dcdc_ovthresh);
+
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,DCDC_UVPOL,
+                               Si3226x_General_Configuration.dcdc_uvpol);
+
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                               DCDC_VREF_CTRL,Si3226x_General_Configuration.dcdc_vref_ctrl);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,DCDC_RNGTYPE,
+                               Si3226x_General_Configuration.dcdc_rngtype);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,DCDC_ANA_GAIN,
+                               Si3226x_General_Configuration.dcdc_ana_gain);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,DCDC_ANA_TOFF,
+                               Si3226x_General_Configuration.dcdc_ana_toff);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                               DCDC_ANA_TONMIN,Si3226x_General_Configuration.dcdc_ana_tonmin);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                               DCDC_ANA_TONMAX,Si3226x_General_Configuration.dcdc_ana_tonmax);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                               DCDC_ANA_DSHIFT,Si3226x_General_Configuration.dcdc_ana_dshift);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                               DCDC_ANA_LPOLY,Si3226x_General_Configuration.dcdc_ana_lpoly);
+
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,COEF_P_HVIC,
+                               Si3226x_General_Configuration.coef_p_hvic);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,P_TH_HVIC,
+                               Si3226x_General_Configuration.p_th_hvic);
+
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,SCALE_KAUDIO,
+                               Si3226x_General_Configuration.scale_kaudio);
+
+        /* GC RAM locations that moved from RevB to RevC */
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                               LKG_OFHK_OFFSET,Si3226x_General_Configuration.lkg_ofhk_offset);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,LKG_LB_OFFSET,
+                               Si3226x_General_Configuration.lkg_lb_offset);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,VBATH_DELTA,
+                               Si3226x_General_Configuration.vbath_delta);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,UVTHRESH_MAX,
+                               Si3226x_General_Configuration.uvthresh_max);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                               UVTHRESH_SCALE,Si3226x_General_Configuration.uvthresh_scale);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,UVTHRESH_BIAS,
+                               Si3226x_General_Configuration.uvthresh_bias);
+
+        /* Hardcoded mods to default settings */
+        data = pProslic[k]->ReadRegX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                                     GPIO_CFG1);
+        data &= 0xF9;  /* Clear DIR for GPIO 1&2 */
+        data |= 0x60;  /* Set ANA mode for GPIO 1&2 */
+        pProslic[k]->WriteRegX(pProslic[k]->pProHWX, pProslic[k]->channel,GPIO_CFG1,
+                               data); /* coarse sensors analog mode */
+        pProslic[k]->WriteRegX(pProslic[k]->pProHWX, pProslic[k]->channel,PDN,
+                               0x80); /* madc powered in open state */
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,TXACHPF_A1_1,
+                               0x71EB851L); /* Fix HPF corner */
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,ROW0_C2,
+                               0x723F235L);   /* improved DTMF det */
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,ROW1_C2,
+                               0x57A9804L);   /* improved DTMF det */
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,XTALK_TIMER,
+                               0x36000L); /* xtalk fix */
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                               DCDC_CPUMP_LP_MASK,0x1100000L); /* Charge pump mask */
+        /* Smart VOV Default Settings - set here in case no ring preset is loaded */
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                               VOV_DCDC_SLOPE,0xFFFFFFL); /* dcdc overhead scale */
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,VOV_DCDC_OS,
+                               0xA18937L); /* smart vov overhead offset*/
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                               VOV_RING_BAT_MAX,0xE49BA5L); /* smart vov max vov */
+
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,VDIFFLPF,
+                               0x10038DL); /* vloop lpf 10hz */
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,ILOOPLPF,
+                               0x4EDDB9L); /* iloop lpf*/
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,ILONGLPF,
+                               0x806D6L); /* ilong lpf */
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,VCMLPF,
+                               0x10059FL); /* 20pps pulse dialing */
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                               CM_SPEEDUP_TIMER,0xF0000L); /* 20pps pulse dialing */
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,VCM_TH,
+                               0x106240L); /* 20pps pulse dialing */
+
+        /* Prevent Ref Osc from powering down in PLL Freerun mode (pd_ref_osc) */
+        pdn_tmp = pProslic[k]->ReadRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                                        PWRSAVE_CTRL_LO);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                               PWRSAVE_CTRL_LO,pdn_tmp&0x0BFFFFFFL);/* clear b26 */
+
+        /* Hardcoded mods for Tracking supplies */
+        if(Si3226x_General_Configuration.batType == BO_DCDC_TRACKING)
+        {
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                                 DCDC_UV_DEBOUNCE, 0x200000L);
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                                 DCDC_OV_DEBOUNCE, 0x0L);
+          if( Si3226x_General_Configuration.bomOpt == BO_DCDC_LCFB) 
+          {
+            pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,DCDC_OIMASK,
+                                 0xE00000L);
+          }
+          else
+          {
+            pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,DCDC_OIMASK,
+                                 0xC00000L);
+          }
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,VCM_HYST,
+                                 0x206280L); /* 2v */
+          if(Si3226x_General_Configuration.bomOpt == BO_DCDC_BUCK_BOOST)
+          {
+            pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                                   DCDC_DCFF_ENABLE,0x10000000L);/* enable dcff drive */
+            pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,LPR_SCALE,
+                                   0x2A00000L);/* scale for LPR amplitude */
+            pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,LPR_CM_OS,
+                                   0x61EB80L); /* LPR cm offset */
+            pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,VBAT_IRQ_TH,
+                                   0x51EB80L); /* thresh to 5v */
+          }
+          else
+          {
+            pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                                   DCDC_DCFF_ENABLE,0x0L);/* disable dcff drive */
+            pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,LPR_SCALE,
+                                   0x1F00000L);/* scale for LPR amplitude */
+            pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,LPR_CM_OS,
+                                   0x51EB80L); /* LPR cm offset */
+          }
+        }
+        else if(Si3226x_General_Configuration.batType == BO_DCDC_QSS)
+        {
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,VCM_HYST,
+                                 0x306280L); /* 3v */
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,LPR_SCALE,
+                                 0x2A00000L);/* scale for LPR amplitude */
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,LPR_CM_OS,
+                                 0x61EB80L); /* LPR cm offset */
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,DCDC_OIMASK,
+                                 0xA00000L);
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                                 DCDC_UV_DEBOUNCE, 0x0L);
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                                 DCDC_OV_DEBOUNCE, 0xD00000L);
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                                 MADC_VDC_SCALE, 0xAE924B9L);
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,VBATL_EXPECT,
+                                 0xF00000L); /* force vbatl 13v to keep cm recalc */
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,PD_OFFLD_DAC,
+                                 0x200000L);
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,PD_OFFLD_GM,
+                                 0x200000L);
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,DCDC_PD_ANA,
+                                 0x300000);
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,P_TH_OFFLOAD,
+                                 0x480CBFL); /* Large - not used in QSS */
+          pProslic[k]->WriteRegX(pProslic[k]->pProHWX, pProslic[k]->channel,OFFLOAD,
+                                 0x3); /* Enable offload and vbat_l */
+
+        }
+        else /* TSS, TSS_ISO, or EXTERNAL */
+        {
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                                 DCDC_UV_DEBOUNCE, 0x0L);
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                                 DCDC_OV_DEBOUNCE, 0xD00000L);
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,DCDC_OIMASK,
+                                 0xA00000L);
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,VCM_HYST,
+                                 0x306280L); /* 3v */
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,LPR_SCALE,
+                                 0x2A00000L);/* scale for LPR amplitude */
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,LPR_CM_OS,
+                                 0x61EB80L); /* LPR cm offset */
+
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,VBATL_EXPECT,
+                                 0xF00000L); /* force vbatl 13v to keep cm recalc */
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                                 MADC_VDC_SCALE, 0xAE924B9L);
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,DCDC_PD_ANA,
+                                 0x300000);
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,P_TH_OFFLOAD,
+                                 0x280CBFL); /* 1.1W @ 60C */
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,PD_OFFLD_DAC,
+                                 0x200000L);
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,PD_OFFLD_GM,
+                                 0x200000L);
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                                 DCDC_CPUMP_LP_MASK,0x100000L); /* Charge pump mask */
+
+          /* Setup power offloading for tracking switched supplies */
+          if((Si3226x_General_Configuration.batType == BO_DCDC_TSS)
+              ||(Si3226x_General_Configuration.batType == BO_DCDC_TSS_ISO))
+          {
+            pProslic[k]->WriteRegX(pProslic[k]->pProHWX, pProslic[k]->channel,OFFLOAD,
+                                   0x3); /* Enable offload and vbat_l */
+          }
+          else
+          {
+            pProslic[k]->WriteRegX(pProslic[k]->pProHWX, pProslic[k]->channel,OFFLOAD,
+                                   0x13); /* Enable offload and vbat_l, disable fixed rail battery management. */
+          }
+        }
+
+        /* DCDC Drive Polarity */
+        if(pProslic[k]->dcdc_polarity_invert)
+        {
+          if(Si3226x_General_Configuration.dcdc_swdrv_pol == 0)
+          {
+            swdrv_pol = 0x100000L;
+          }
+          else
+          {
+            swdrv_pol = 0x0L;
+          }
+          /*
+          ** Interim support for higher voltage PBB using same
+          ** general parameters as standard PBB
+          */
+          if(Si3226x_General_Configuration.bomOpt == BO_DCDC_PMOS_BUCK_BOOST)
+          {
+            pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                                   VBAT_TRACK_MIN_RNG,0x3300000L);
+            pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                                   DCDC_OITHRESH_HI,0xF00000L);
+            pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,DCDC_ANA_GAIN,
+                                   0x400000L);
+            pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,LPR_SCALE,
+                                   0x2900000L);
+
+          }
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                                 DCDC_SWDRV_POL,swdrv_pol);
+        }
+        else
+        {
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                                 DCDC_SWDRV_POL,Si3226x_General_Configuration.dcdc_swdrv_pol);
+        }
+      }
+      pProslic[k]->WriteRAMX(pProslic[k]->pProHWX,pProslic[k]->channel,IRING_LIM,
+                             SI3226X_IRING_LIM_MAX);
+    }
+  } /* !INIT_SOFTRESET */
+
+  if((init_opt != INIT_NO_CAL) && (init_opt != INIT_SOFTRESET))
+  {
+    /*
+    ** Calibrate (madc offset)
+    */
+    ProSLIC_Calibrate(pProslic,size,calSetup,TIMEOUT_MADC_CAL);
+  }
+
+  /*
+  ** Bring up DC/DC converters sequentially to minimize
+  ** peak power demand on VDC
+  */
+  for (k=0; k<size; k++)
+  {
+    if ((pProslic[k]->channelEnable)&&(pProslic[k]->channelType == PROSLIC))
+    {
+      pProslic[k]->error = Si3226x_PowerUpConverter(pProslic[k]);
+    }
+  }
+
+  if((init_opt != INIT_NO_CAL)&&(init_opt != INIT_REINIT)
+      &&(init_opt != INIT_SOFTRESET))
+  {
+    /*
+    ** Calibrate remaining cals (except madc, lb)
+    */
+    calSetup[1] = SI3226X_CAL_STD_CALR1;
+    calSetup[2] = SI3226X_CAL_STD_CALR2;
+    ProSLIC_Calibrate(pProslic,size,calSetup,TIMEOUT_GEN_CAL);
+  }
+
+  /*
+  ** Apply user configured ENHANCE and AUTO
+  */
+  if(init_opt != INIT_SOFTRESET)
+  {
+    for (k=0; k<size; k++)
+    {
+      if ((pProslic[k]->channelEnable)&&(pProslic[k]->channelType == PROSLIC))
+      {
+        pProslic[k]->WriteRegX(pProslic[k]->pProHWX, pProslic[k]->channel,ENHANCE,
+                               Si3226x_General_Configuration.enhance);
+        pProslic[k]->WriteRegX(pProslic[k]->pProHWX, pProslic[k]->channel,AUTO,
+                               Si3226x_General_Configuration.autoRegister);
+        pProslic[k]->WriteRegX(pProslic[k]->pProHWX, pProslic[k]->channel,ZCAL_EN,
+                               Si3226x_General_Configuration.zcal_en);
+      }
+    }
+  }
+
+  if((init_opt == INIT_REINIT) || (init_opt == INIT_SOFTRESET))
+  {
+    for(k = 0; k < size; k++)
+    {
+      pProslic[k]->WriteRegX(pProslic[k]->pProHWX,pProslic[k]->channel,LINEFEED,
+                             pProslic[k]->scratch);
+    }
+  }
+
+#ifdef ENABLE_DEBUG
+  if(pProslic[0]->debugMode)
+  {
+    LOGPRINT("%s: ProSLIC initialization completed.\n", LOGPRINT_PREFIX);
+  }
+#endif
+
+  return RC_NONE;
+}
+
+/*
+** Function: Si3226x_EnableInterrupts
+**
+** Description:
+** Enables interrupts
+**
+** Input Parameters:
+** pProslic:   pointer to PROSLIC channel obj
+**
+** Returns:
+** 0
+*/
+int Si3226x_EnableInterrupts (proslicChanType_ptr pProslic)
+{
+  uInt8 i;
+#ifdef GCI_MODE
+  uInt8 data;
+#endif
+  /* Clear interrupts prior to enabling them */
+  for(i = IRQ1; i< IRQ4; i++)
+  {
+#ifdef GCI_MODE
+    data = ReadReg(pProHW,pProslic->channel, i);
+    WriteReg(pProHW,pProslic->channel,i,data); /*clear interrupts (gci only)*/
+#else
+    (void)ReadReg(pProHW,pProslic->channel, i);
+#endif
+  }
+  WriteReg (pProHW,pProslic->channel,IRQEN1,Si3226x_General_Configuration.irqen1);
+  WriteReg (pProHW,pProslic->channel,IRQEN2,Si3226x_General_Configuration.irqen2);
+  WriteReg (pProHW,pProslic->channel,IRQEN3,Si3226x_General_Configuration.irqen3);
+  WriteReg (pProHW,pProslic->channel,IRQEN4,Si3226x_General_Configuration.irqen4);
+  return 0;
+}
+
+/*
+**
+** PROSLIC CONFIGURATION FUNCTIONS
+**
+*/
+
+/*
+** Function: Si3226x_RingSetup
+**
+** Description:
+** configure ringing
+**
+** Input Parameters:
+** pProslic:   pointer to PROSLIC channel obj
+** preset:     ring preset
+**
+** Returns:
+** 0
+*/
+#ifndef DISABLE_RING_SETUP
+int Si3226x_RingSetup (proslicChanType *pProslic, int preset)
+{
+
+  WriteRAM(pProHW,pProslic->channel,RTPER,Si3226x_Ring_Presets[preset].rtper);
+  WriteRAM(pProHW,pProslic->channel,RINGFR,Si3226x_Ring_Presets[preset].freq);
+  WriteRAM(pProHW,pProslic->channel,RINGAMP,Si3226x_Ring_Presets[preset].amp);
+  WriteRAM(pProHW,pProslic->channel,RINGPHAS,Si3226x_Ring_Presets[preset].phas);
+  WriteRAM(pProHW,pProslic->channel,RINGOF,Si3226x_Ring_Presets[preset].offset);
+  WriteRAM(pProHW,pProslic->channel,SLOPE_RING,
+           Si3226x_Ring_Presets[preset].slope_ring);
+
+  if(Si3226x_Ring_Presets[preset].iring_lim > SI3226X_IRING_LIM_MAX)
+  {
+    Si3226x_Ring_Presets[preset].iring_lim = SI3226X_IRING_LIM_MAX;
+  }
+
+  WriteRAM(pProHW,pProslic->channel,IRING_LIM,
+           Si3226x_Ring_Presets[preset].iring_lim);
+  WriteRAM(pProHW,pProslic->channel,RTACTH,Si3226x_Ring_Presets[preset].rtacth);
+  WriteRAM(pProHW,pProslic->channel,RTDCTH,Si3226x_Ring_Presets[preset].rtdcth);
+  WriteRAM(pProHW,pProslic->channel,RTACDB,Si3226x_Ring_Presets[preset].rtacdb);
+  WriteRAM(pProHW,pProslic->channel,RTDCDB,Si3226x_Ring_Presets[preset].rtdcdb);
+  WriteRAM(pProHW,pProslic->channel,VOV_RING_BAT,
+           Si3226x_Ring_Presets[preset].vov_ring_bat);
+  WriteRAM(pProHW,pProslic->channel,VOV_RING_GND,
+           Si3226x_Ring_Presets[preset].vov_ring_gnd);
+
+  /* Always limit VBATR_EXPECT to the general configuration maximum */
+#ifndef NOCLAMP_VBATR
+  if(Si3226x_Ring_Presets[preset].vbatr_expect >
+      Si3226x_General_Configuration.vbatr_expect)
+  {
+    WriteRAM(pProHW,pProslic->channel,VBATR_EXPECT,
+             Si3226x_General_Configuration.vbatr_expect);
+#ifdef ENABLE_DEBUG
+    if(pProslic->debugMode)
+    {
+      LOGPRINT("%sVBATR_EXPECT : Clamped to Gen Conf Limit\n", LOGPRINT_PREFIX);
+    }
+#endif
+  }
+  else
+  {
+    WriteRAM(pProHW,pProslic->channel,VBATR_EXPECT,
+             Si3226x_Ring_Presets[preset].vbatr_expect);
+  }
+#else
+  WriteRAM(pProHW,pProslic->channel,VBATR_EXPECT,
+           Si3226x_Ring_Presets[preset].vbatr_expect);
+#endif
+
+  WriteReg(pProHW,pProslic->channel,RINGTALO,Si3226x_Ring_Presets[preset].talo);
+  WriteReg(pProHW,pProslic->channel,RINGTAHI,Si3226x_Ring_Presets[preset].tahi);
+  WriteReg(pProHW,pProslic->channel,RINGTILO,Si3226x_Ring_Presets[preset].tilo);
+  WriteReg(pProHW,pProslic->channel,RINGTIHI,Si3226x_Ring_Presets[preset].tihi);
+
+  WriteRAM(pProHW,pProslic->channel,DCDC_VREF_MIN_RNG,
+           Si3226x_Ring_Presets[preset].vbat_track_min_rng);
+  WriteReg(pProHW,pProslic->channel,RINGCON,Si3226x_Ring_Presets[preset].ringcon);
+  WriteReg(pProHW,pProslic->channel,USERSTAT,
+           Si3226x_Ring_Presets[preset].userstat);
+  WriteRAM(pProHW,pProslic->channel,VCM_RING,
+           Si3226x_Ring_Presets[preset].vcm_ring);
+  WriteRAM(pProHW,pProslic->channel,VCM_RING_FIXED,
+           Si3226x_Ring_Presets[preset].vcm_ring_fixed);
+  WriteRAM(pProHW,pProslic->channel,DELTA_VCM,
+           Si3226x_Ring_Presets[preset].delta_vcm);
+
+  /* Smart VOV Parameters - set during ProSLIC_Init(). */
+  /* Compile option left to use ring preset values     */
+#ifdef ENABLE_RING_PRESET_SMART_VOV
+  WriteRAM(pProHW,pProslic->channel,VOV_DCDC_SLOPE,
+           Si3226x_Ring_Presets[preset].vov_dcdc_slope);
+  WriteRAM(pProHW,pProslic->channel,VOV_DCDC_OS,
+           Si3226x_Ring_Presets[preset].vov_dcdc_os);
+  WriteRAM(pProHW,pProslic->channel,VOV_RING_BAT_MAX,
+           Si3226x_Ring_Presets[preset].vov_ring_bat_max);
+#endif
+
+  /* Clamp IRING_LIM to 60mA max if QSS */
+  if(Si3226x_General_Configuration.batType == BO_DCDC_QSS)
+  {
+    WriteRAM(pProHW,pProslic->channel,IRING_LIM,QSS_IRING_LIM_MAX);
+  }
+
+  /* Automatically adjust DCDC_RNGTYPE */
+  if(Si3226x_General_Configuration.bomOpt == BO_DCDC_BUCK_BOOST)
+  {
+    WriteRAM(pProHW,pProslic->channel,DCDC_RNGTYPE,0x0L);  /* Fixed */
+  }
+  else
+  {
+    WriteRAM(pProHW,pProslic->channel,DCDC_RNGTYPE,
+             Si3226x_Ring_Presets[preset].dcdc_rngtype);
+  }
+
+  return 0;
+}
+#endif
+
+/*
+** Function: PROSLIC_ZsynthSetup
+**
+** Description:
+** configure impedence synthesis
+*/
+#ifndef DISABLE_ZSYNTH_SETUP
+int Si3226x_ZsynthSetup (proslicChanType *pProslic, int preset)
+{
+  uInt8 lf;
+  uInt8 cal_en = 0;
+  uInt16 timer = 500;
+
+  lf = ReadReg(pProHW,pProslic->channel,LINEFEED);
+  WriteReg(pProHW,pProslic->channel,LINEFEED,0);
+  /*
+  ** Load provided coefficients - these are presumed to be 0dB/0dB
+  */
+  WriteRAM(pProHW,pProslic->channel,TXACEQ_C0,
+           Si3226x_Impedance_Presets[preset].audioEQ.txaceq_c0);
+  WriteRAM(pProHW,pProslic->channel,TXACEQ_C1,
+           Si3226x_Impedance_Presets[preset].audioEQ.txaceq_c1);
+  WriteRAM(pProHW,pProslic->channel,TXACEQ_C2,
+           Si3226x_Impedance_Presets[preset].audioEQ.txaceq_c2);
+  WriteRAM(pProHW,pProslic->channel,TXACEQ_C3,
+           Si3226x_Impedance_Presets[preset].audioEQ.txaceq_c3);
+  WriteRAM(pProHW,pProslic->channel,RXACEQ_C0,
+           Si3226x_Impedance_Presets[preset].audioEQ.rxaceq_c0);
+  WriteRAM(pProHW,pProslic->channel,RXACEQ_C1,
+           Si3226x_Impedance_Presets[preset].audioEQ.rxaceq_c1);
+  WriteRAM(pProHW,pProslic->channel,RXACEQ_C2,
+           Si3226x_Impedance_Presets[preset].audioEQ.rxaceq_c2);
+  WriteRAM(pProHW,pProslic->channel,RXACEQ_C3,
+           Si3226x_Impedance_Presets[preset].audioEQ.rxaceq_c3);
+  WriteRAM(pProHW,pProslic->channel,ECFIR_C2,
+           Si3226x_Impedance_Presets[preset].hybrid.ecfir_c2);
+  WriteRAM(pProHW,pProslic->channel,ECFIR_C3,
+           Si3226x_Impedance_Presets[preset].hybrid.ecfir_c3);
+  WriteRAM(pProHW,pProslic->channel,ECFIR_C4,
+           Si3226x_Impedance_Presets[preset].hybrid.ecfir_c4);
+  WriteRAM(pProHW,pProslic->channel,ECFIR_C5,
+           Si3226x_Impedance_Presets[preset].hybrid.ecfir_c5);
+  WriteRAM(pProHW,pProslic->channel,ECFIR_C6,
+           Si3226x_Impedance_Presets[preset].hybrid.ecfir_c6);
+  WriteRAM(pProHW,pProslic->channel,ECFIR_C7,
+           Si3226x_Impedance_Presets[preset].hybrid.ecfir_c7);
+  WriteRAM(pProHW,pProslic->channel,ECFIR_C8,
+           Si3226x_Impedance_Presets[preset].hybrid.ecfir_c8);
+  WriteRAM(pProHW,pProslic->channel,ECFIR_C9,
+           Si3226x_Impedance_Presets[preset].hybrid.ecfir_c9);
+  WriteRAM(pProHW,pProslic->channel,ECIIR_B0,
+           Si3226x_Impedance_Presets[preset].hybrid.ecfir_b0);
+  WriteRAM(pProHW,pProslic->channel,ECIIR_B1,
+           Si3226x_Impedance_Presets[preset].hybrid.ecfir_b1);
+  WriteRAM(pProHW,pProslic->channel,ECIIR_A1,
+           Si3226x_Impedance_Presets[preset].hybrid.ecfir_a1);
+  WriteRAM(pProHW,pProslic->channel,ECIIR_A2,
+           Si3226x_Impedance_Presets[preset].hybrid.ecfir_a2);
+  WriteRAM(pProHW,pProslic->channel,ZSYNTH_A1,
+           Si3226x_Impedance_Presets[preset].zsynth.zsynth_a1);
+  WriteRAM(pProHW,pProslic->channel,ZSYNTH_A2,
+           Si3226x_Impedance_Presets[preset].zsynth.zsynth_a2);
+  WriteRAM(pProHW,pProslic->channel,ZSYNTH_B1,
+           Si3226x_Impedance_Presets[preset].zsynth.zsynth_b1);
+  WriteRAM(pProHW,pProslic->channel,ZSYNTH_B0,
+           Si3226x_Impedance_Presets[preset].zsynth.zsynth_b0);
+  WriteRAM(pProHW,pProslic->channel,ZSYNTH_B2,
+           Si3226x_Impedance_Presets[preset].zsynth.zsynth_b2);
+  WriteReg(pProHW,pProslic->channel,RA,
+           Si3226x_Impedance_Presets[preset].zsynth.ra);
+  WriteRAM(pProHW,pProslic->channel,TXACGAIN,
+           Si3226x_Impedance_Presets[preset].txgain);
+  WriteRAM(pProHW,pProslic->channel,RXACGAIN_SAVE,
+           Si3226x_Impedance_Presets[preset].rxgain);
+  WriteRAM(pProHW,pProslic->channel,RXACGAIN,
+           Si3226x_Impedance_Presets[preset].rxgain);
+  WriteRAM(pProHW,pProslic->channel,RXACHPF_B0_1,
+           Si3226x_Impedance_Presets[preset].rxachpf_b0_1);
+  WriteRAM(pProHW,pProslic->channel,RXACHPF_B1_1,
+           Si3226x_Impedance_Presets[preset].rxachpf_b1_1);
+  WriteRAM(pProHW,pProslic->channel,RXACHPF_A1_1,
+           Si3226x_Impedance_Presets[preset].rxachpf_a1_1);
+
+  /*
+  ** Scale based on desired gain plan
+  */
+  Si3226x_dbgSetTXGain(pProslic,Si3226x_Impedance_Presets[preset].txgain_db,
+                       preset,TXACGAIN_SEL);
+  Si3226x_dbgSetRXGain(pProslic,Si3226x_Impedance_Presets[preset].rxgain_db,
+                       preset,RXACGAIN_SEL);
+  Si3226x_TXAudioGainSetup(pProslic,TXACGAIN_SEL);
+  Si3226x_RXAudioGainSetup(pProslic,RXACGAIN_SEL);
+
+  /*
+  ** Perform Zcal in case OHT used (eg. no offhook event to trigger auto Zcal)
+  */
+  WriteReg(pProHW,pProslic->channel,CALR0,0x00);
+  WriteReg(pProHW,pProslic->channel,CALR1,0x40);
+  WriteReg(pProHW,pProslic->channel,CALR2,0x00);
+  WriteReg(pProHW,pProslic->channel,CALR3,0x80);  /* start cal */
+
+  /* Wait for zcal to finish */
+  do
+  {
+    cal_en = ReadReg(pProHW,pProslic->channel,CALR3);
+    Delay(pProTimer,1);
+    timer--;
+  }
+  while((cal_en&0x80)&&(timer>0));
+
+  WriteReg(pProHW,pProslic->channel,LINEFEED,lf);
+
+  if(timer > 0)
+  {
+    return 0;
+  }
+  else
+  {
+    return RC_CAL_TIMEOUT;
+  }
+}
+#endif
+
+/*
+** Function: PROSLIC_GciCISetup
+**
+** Description:
+** configure CI bits (GCI mode)
+*/
+#ifndef DISABLE_CI_SETUP
+int Si3226x_GciCISetup (proslicChanType *pProslic, int preset)
+{
+  WriteReg(pProHW,pProslic->channel,GCI_CI,Si3226x_CI_Presets[preset].gci_ci);
+  return 0;
+}
+#endif
+
+/*
+** Function: PROSLIC_AudioGainSetup
+**
+** Description:
+** configure audio gains
+*/
+int Si3226x_TXAudioGainSetup (proslicChanType *pProslic, int preset)
+{
+  WriteRAM(pProHW,pProslic->channel,TXACGAIN,
+           Si3226x_audioGain_Presets[preset].acgain);
+  WriteRAM(pProHW,pProslic->channel,TXACEQ_C0,
+           Si3226x_audioGain_Presets[preset].aceq_c0);
+  WriteRAM(pProHW,pProslic->channel,TXACEQ_C1,
+           Si3226x_audioGain_Presets[preset].aceq_c1);
+  WriteRAM(pProHW,pProslic->channel,TXACEQ_C2,
+           Si3226x_audioGain_Presets[preset].aceq_c2);
+  WriteRAM(pProHW,pProslic->channel,TXACEQ_C3,
+           Si3226x_audioGain_Presets[preset].aceq_c3);
+  return 0;
+}
+
+
+/*
+** Function: PROSLIC_AudioGainScale
+**
+** Description:
+** Multiply path gain by passed value for PGA and EQ scale (no reference to dB,
+** multiply by a scale factor)
+*/
+int Si3226x_AudioGainScale (proslicChanType *pProslic, int preset,
+                            uInt32 pga_scale, uInt32 eq_scale,int rx_tx_sel)
+{
+
+  if(rx_tx_sel == TXACGAIN_SEL)
+  {
+    Si3226x_audioGain_Presets[TXACGAIN_SEL].acgain =
+      (Si3226x_Impedance_Presets[preset].txgain/1000)*pga_scale;
+    if (Si3226x_Impedance_Presets[preset].audioEQ.txaceq_c0 & 0x10000000L)
+    {
+      Si3226x_Impedance_Presets[preset].audioEQ.txaceq_c0 |= 0xf0000000L;
+    }
+    if (Si3226x_Impedance_Presets[preset].audioEQ.txaceq_c1 & 0x10000000L)
+    {
+      Si3226x_Impedance_Presets[preset].audioEQ.txaceq_c1 |= 0xf0000000L;
+    }
+    if (Si3226x_Impedance_Presets[preset].audioEQ.txaceq_c2 & 0x10000000L)
+    {
+      Si3226x_Impedance_Presets[preset].audioEQ.txaceq_c2 |= 0xf0000000L;
+    }
+    if (Si3226x_Impedance_Presets[preset].audioEQ.txaceq_c3 & 0x10000000L)
+    {
+      Si3226x_Impedance_Presets[preset].audioEQ.txaceq_c3 |= 0xf0000000L;
+    }
+    Si3226x_audioGain_Presets[TXACGAIN_SEL].aceq_c0 = ((int32)
+        Si3226x_Impedance_Presets[preset].audioEQ.txaceq_c0/1000)*eq_scale;
+    Si3226x_audioGain_Presets[TXACGAIN_SEL].aceq_c1 = ((int32)
+        Si3226x_Impedance_Presets[preset].audioEQ.txaceq_c1/1000)*eq_scale;
+    Si3226x_audioGain_Presets[TXACGAIN_SEL].aceq_c2 = ((int32)
+        Si3226x_Impedance_Presets[preset].audioEQ.txaceq_c2/1000)*eq_scale;
+    Si3226x_audioGain_Presets[TXACGAIN_SEL].aceq_c3 = ((int32)
+        Si3226x_Impedance_Presets[preset].audioEQ.txaceq_c3/1000)*eq_scale;
+
+    WriteRAM(pProHW,pProslic->channel,TXACGAIN,
+             Si3226x_audioGain_Presets[TXACGAIN_SEL].acgain);
+    WriteRAM(pProHW,pProslic->channel,TXACEQ_C0,
+             Si3226x_audioGain_Presets[TXACGAIN_SEL].aceq_c0);
+    WriteRAM(pProHW,pProslic->channel,TXACEQ_C1,
+             Si3226x_audioGain_Presets[TXACGAIN_SEL].aceq_c1);
+    WriteRAM(pProHW,pProslic->channel,TXACEQ_C2,
+             Si3226x_audioGain_Presets[TXACGAIN_SEL].aceq_c2);
+    WriteRAM(pProHW,pProslic->channel,TXACEQ_C3,
+             Si3226x_audioGain_Presets[TXACGAIN_SEL].aceq_c3);
+  }
+  else
+  {
+    Si3226x_audioGain_Presets[RXACGAIN_SEL].acgain =
+      (Si3226x_Impedance_Presets[preset].rxgain/1000)*pga_scale;
+    if (Si3226x_Impedance_Presets[preset].audioEQ.rxaceq_c0 & 0x10000000L)
+    {
+      Si3226x_Impedance_Presets[preset].audioEQ.rxaceq_c0 |= 0xf0000000L;
+    }
+    if (Si3226x_Impedance_Presets[preset].audioEQ.rxaceq_c1 & 0x10000000L)
+    {
+      Si3226x_Impedance_Presets[preset].audioEQ.rxaceq_c1 |= 0xf0000000L;
+    }
+    if (Si3226x_Impedance_Presets[preset].audioEQ.rxaceq_c2 & 0x10000000L)
+    {
+      Si3226x_Impedance_Presets[preset].audioEQ.rxaceq_c2 |= 0xf0000000L;
+    }
+    if (Si3226x_Impedance_Presets[preset].audioEQ.rxaceq_c3 & 0x10000000L)
+    {
+      Si3226x_Impedance_Presets[preset].audioEQ.rxaceq_c3 |= 0xf0000000L;
+    }
+    Si3226x_audioGain_Presets[RXACGAIN_SEL].aceq_c0 = ((int32)
+        Si3226x_Impedance_Presets[preset].audioEQ.rxaceq_c0/1000)*eq_scale;
+    Si3226x_audioGain_Presets[RXACGAIN_SEL].aceq_c1 = ((int32)
+        Si3226x_Impedance_Presets[preset].audioEQ.rxaceq_c1/1000)*eq_scale;
+    Si3226x_audioGain_Presets[RXACGAIN_SEL].aceq_c2 = ((int32)
+        Si3226x_Impedance_Presets[preset].audioEQ.rxaceq_c2/1000)*eq_scale;
+    Si3226x_audioGain_Presets[RXACGAIN_SEL].aceq_c3 = ((int32)
+        Si3226x_Impedance_Presets[preset].audioEQ.rxaceq_c3/1000)*eq_scale;
+
+    WriteRAM(pProHW,pProslic->channel,RXACGAIN_SAVE,
+             Si3226x_audioGain_Presets[RXACGAIN_SEL].acgain);
+    WriteRAM(pProHW,pProslic->channel,RXACGAIN,
+             Si3226x_audioGain_Presets[RXACGAIN_SEL].acgain);
+    WriteRAM(pProHW,pProslic->channel,RXACEQ_C0,
+             Si3226x_audioGain_Presets[RXACGAIN_SEL].aceq_c0);
+    WriteRAM(pProHW,pProslic->channel,RXACEQ_C1,
+             Si3226x_audioGain_Presets[RXACGAIN_SEL].aceq_c1);
+    WriteRAM(pProHW,pProslic->channel,RXACEQ_C2,
+             Si3226x_audioGain_Presets[RXACGAIN_SEL].aceq_c2);
+    WriteRAM(pProHW,pProslic->channel,RXACEQ_C3,
+             Si3226x_audioGain_Presets[RXACGAIN_SEL].aceq_c3);
+  }
+  return 0;
+}
+int Si3226x_TXAudioGainScale (proslicChanType *pProslic, int preset,
+                              uInt32 pga_scale, uInt32 eq_scale)
+{
+  return Si3226x_AudioGainScale(pProslic,preset,pga_scale,eq_scale,TXACGAIN_SEL);
+}
+int Si3226x_RXAudioGainScale (proslicChanType *pProslic, int preset,
+                              uInt32 pga_scale, uInt32 eq_scale)
+{
+  return Si3226x_AudioGainScale(pProslic,preset,pga_scale,eq_scale,RXACGAIN_SEL);
+}
+/*
+** Function: PROSLIC_AudioGainSetup
+**
+** Description:
+** configure audio gains
+*/
+int Si3226x_RXAudioGainSetup (proslicChanType *pProslic, int preset)
+{
+  WriteRAM(pProHW,pProslic->channel,RXACGAIN_SAVE,
+           Si3226x_audioGain_Presets[preset].acgain);
+  WriteRAM(pProHW,pProslic->channel,RXACGAIN,
+           Si3226x_audioGain_Presets[preset].acgain);
+  WriteRAM(pProHW,pProslic->channel,RXACEQ_C0,
+           Si3226x_audioGain_Presets[preset].aceq_c0);
+  WriteRAM(pProHW,pProslic->channel,RXACEQ_C1,
+           Si3226x_audioGain_Presets[preset].aceq_c1);
+  WriteRAM(pProHW,pProslic->channel,RXACEQ_C2,
+           Si3226x_audioGain_Presets[preset].aceq_c2);
+  WriteRAM(pProHW,pProslic->channel,RXACEQ_C3,
+           Si3226x_audioGain_Presets[preset].aceq_c3);
+  return 0;
+}
+
+
+/*
+** Function: PROSLIC_DCFeedSetupCfg
+**
+** Description:
+** configure dc feed
+*/
+#ifndef DISABLE_DCFEED_SETUP
+int Si3226x_DCFeedSetupCfg (proslicChanType *pProslic, Si3226x_DCfeed_Cfg *cfg,
+                            int preset)
+{
+  uInt8 lf;
+
+  if(pProslic->channelType != PROSLIC)
+  {
+    return RC_CHANNEL_TYPE_ERR;
+  }
+  lf = ReadReg(pProHW,pProslic->channel,LINEFEED);
+  WriteReg(pProHW,pProslic->channel,LINEFEED,0);
+  WriteRAM(pProHW,pProslic->channel,SLOPE_VLIM,cfg[preset].slope_vlim);
+  WriteRAM(pProHW,pProslic->channel,SLOPE_RFEED,cfg[preset].slope_rfeed);
+  WriteRAM(pProHW,pProslic->channel,SLOPE_ILIM,cfg[preset].slope_ilim);
+  WriteRAM(pProHW,pProslic->channel,SLOPE_DELTA1,cfg[preset].delta1);
+  WriteRAM(pProHW,pProslic->channel,SLOPE_DELTA2,cfg[preset].delta2);
+  WriteRAM(pProHW,pProslic->channel,V_VLIM,cfg[preset].v_vlim);
+  WriteRAM(pProHW,pProslic->channel,V_RFEED,cfg[preset].v_rfeed);
+  WriteRAM(pProHW,pProslic->channel,V_ILIM,cfg[preset].v_ilim);
+  WriteRAM(pProHW,pProslic->channel,CONST_RFEED,cfg[preset].const_rfeed);
+  WriteRAM(pProHW,pProslic->channel,CONST_ILIM,cfg[preset].const_ilim);
+  WriteRAM(pProHW,pProslic->channel,I_VLIM,cfg[preset].i_vlim);
+  WriteRAM(pProHW,pProslic->channel,LCRONHK,cfg[preset].lcronhk);
+  WriteRAM(pProHW,pProslic->channel,LCROFFHK,cfg[preset].lcroffhk);
+  WriteRAM(pProHW,pProslic->channel,LCRDBI,cfg[preset].lcrdbi);
+  WriteRAM(pProHW,pProslic->channel,LONGHITH,cfg[preset].longhith);
+  WriteRAM(pProHW,pProslic->channel,LONGLOTH,cfg[preset].longloth);
+  WriteRAM(pProHW,pProslic->channel,LONGDBI,cfg[preset].longdbi);
+  WriteRAM(pProHW,pProslic->channel,LCRMASK,cfg[preset].lcrmask);
+  WriteRAM(pProHW,pProslic->channel,LCRMASK_POLREV,cfg[preset].lcrmask_polrev);
+  WriteRAM(pProHW,pProslic->channel,LCRMASK_STATE,cfg[preset].lcrmask_state);
+  WriteRAM(pProHW,pProslic->channel,LCRMASK_LINECAP,cfg[preset].lcrmask_linecap);
+  WriteRAM(pProHW,pProslic->channel,VCM_OH,cfg[preset].vcm_oh);
+  WriteRAM(pProHW,pProslic->channel,VOV_BAT,cfg[preset].vov_bat);
+  WriteRAM(pProHW,pProslic->channel,VOV_GND,cfg[preset].vov_gnd);
+
+#ifdef SIVOICE_MULTI_BOM_SUPPORT
+#define VOV_BAT_6V 0x624DD2L   /* 6v */
+  if(Si3226x_General_Configuration.batType == BO_DCDC_FIXED_RAIL)
+  {
+    WriteRAM(pProHW,pProslic->channel,VOV_BAT,VOV_BAT_6V);
+  }
+#endif
+  WriteReg(pProHW,pProslic->channel,LINEFEED,lf);
+  return RC_NONE;
+}
+
+#endif
+
+
+/*
+** Function: PROSLIC_GPIOSetup
+**
+** Description:
+** configure gpio
+*/
+#ifndef DISABLE_GPIO_SETUP
+int Si3226x_GPIOSetup (proslicChanType *pProslic)
+{
+  uInt8 data;
+  data = ReadReg(pProHW,pProslic->channel,GPIO);
+  data |= Si3226x_GPIO_Configuration.outputEn << 4;
+  WriteReg(pProHW,pProslic->channel,GPIO,data);
+  data = Si3226x_GPIO_Configuration.analog << 4;
+  data |= Si3226x_GPIO_Configuration.direction;
+  WriteReg(pProHW,pProslic->channel,GPIO_CFG1,data);
+  data = Si3226x_GPIO_Configuration.manual << 4;
+  data |= Si3226x_GPIO_Configuration.polarity;
+  WriteReg(pProHW,pProslic->channel,GPIO_CFG2,data);
+  data |= Si3226x_GPIO_Configuration.openDrain;
+  WriteReg(pProHW,pProslic->channel,GPIO_CFG3,data);
+  return 0;
+}
+#endif
+
+/*
+** Function: PROSLIC_PulseMeterSetup
+**
+** Description:
+** configure pulse metering
+*/
+#ifndef DISABLE_PULSE_SETUP
+int Si3226x_PulseMeterSetup (proslicChanType *pProslic, int preset)
+{
+  uInt8 reg;
+  WriteRAM(pProHW,pProslic->channel,PM_AMP_THRESH,
+           Si3226x_PulseMeter_Presets[preset].pm_amp_thresh);
+  reg = (Si3226x_PulseMeter_Presets[preset].pm_freq<<1)|
+        (Si3226x_PulseMeter_Presets[preset].pm_auto<<3);
+  WriteRAM(pProHW,pProslic->channel,PM_ACTIVE,
+           Si3226x_PulseMeter_Presets[preset].pm_active);
+  WriteRAM(pProHW,pProslic->channel,PM_INACTIVE,
+           Si3226x_PulseMeter_Presets[preset].pm_inactive);
+  WriteReg(pProHW,pProslic->channel,PMCON,reg);
+  return 0;
+}
+#endif
+/*
+** Function: PROSLIC_PCMSetup
+**
+** Description:
+** configure pcm
+*/
+#ifndef DISABLE_PCM_SETUP
+int Si3226x_PCMSetup (proslicChanType *pProslic, int preset)
+{
+  uInt8 regTemp;
+
+  if (Si3226x_PCM_Presets[preset].widebandEn)
+  {
+    /* TXIIR settings */
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_B0_1,0x3538E80L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_B1_1,0x3538E80L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_A1_1,0x1AA9100L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_B0_2,0x216D100L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_B1_2,0x2505400L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_B2_2,0x216D100L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_A1_2,0x2CB8100L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_A2_2,0x1D7FA500L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_B0_3,0x2CD9B00L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_B1_3,0x1276D00L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_B2_3,0x2CD9B00L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_A1_3,0x2335300L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_A2_3,0x19D5F700L);
+    /* RXIIR settings */
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_B0_1,0x6A71D00L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_B1_1,0x6A71D00L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_A1_1,0x1AA9100L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_B0_2,0x216D100L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_B1_2,0x2505400L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_B2_2,0x216D100L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_A1_2,0x2CB8100L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_A2_2,0x1D7FA500L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_B0_3,0x2CD9B00L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_B1_3,0x1276D00L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_B2_3,0x2CD9B00L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_A1_3,0x2335300L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_A2_3,0x19D5F700L);
+    /*
+    ** RXHPF
+    ** Note:  Calling ProSLIC_ZsynthSetup() will overwrite some
+    **        of these values.  ProSLIC_PCMSetup() should always
+    **        be called after loading coefficients when using
+    **        wideband mode
+    */
+    WriteRAM(pProHW,pProslic->channel,RXACHPF_B0_1,0x7CFF900L);
+    WriteRAM(pProHW,pProslic->channel,RXACHPF_B1_1,0x18300700L);
+    WriteRAM(pProHW,pProslic->channel,RXACHPF_A1_1,0x79FF201L);
+    WriteRAM(pProHW,pProslic->channel,RXACHPF_B0_2,0x7CEDA1DL);
+    WriteRAM(pProHW,pProslic->channel,RXACHPF_B1_2,0x106320D4L);
+    WriteRAM(pProHW,pProslic->channel,RXACHPF_B2_2,0x7CEDA1DL);
+    WriteRAM(pProHW,pProslic->channel,RXACHPF_A1_2,0xF9A910FL);
+    WriteRAM(pProHW,pProslic->channel,RXACHPF_A2_2,0x185FFDA8L);
+    WriteRAM(pProHW,pProslic->channel,RXACHPF_GAIN,0x08000000L);
+    /* TXHPF */
+    WriteRAM(pProHW,pProslic->channel,TXACHPF_B0_1,0x0C7FF4CEL);
+    WriteRAM(pProHW,pProslic->channel,TXACHPF_B1_1,0x13800B32L);
+    WriteRAM(pProHW,pProslic->channel,TXACHPF_A1_1,0x079FF201L);
+    WriteRAM(pProHW,pProslic->channel,TXACHPF_B0_2,0x030FDD10L);
+    WriteRAM(pProHW,pProslic->channel,TXACHPF_B1_2,0x19E0996CL);
+    WriteRAM(pProHW,pProslic->channel,TXACHPF_B2_2,0x030FDD10L);
+    WriteRAM(pProHW,pProslic->channel,TXACHPF_A1_2,0x0F9A910FL);
+    WriteRAM(pProHW,pProslic->channel,TXACHPF_A2_2,0x185FFDA8L);
+    WriteRAM(pProHW,pProslic->channel,TXACHPF_GAIN,0x0CD30000L);
+
+    regTemp = ReadReg(pProHW,pProslic->channel,DIGCON);
+#ifndef DISABLE_HPF_WIDEBAND
+    WriteReg(pProHW,pProslic->channel,DIGCON,regTemp&~(0xC)); /* Enable HPF */
+#else
+    WriteReg(pProHW,pProslic->channel,DIGCON,regTemp|(0xC)); /* Disable HPF */
+#endif
+    regTemp = ReadReg(pProHW,pProslic->channel,ENHANCE);
+    WriteReg(pProHW,pProslic->channel,ENHANCE,regTemp|1);
+  }
+  else
+  {
+    regTemp = ReadReg(pProHW,pProslic->channel,DIGCON);
+    WriteReg(pProHW,pProslic->channel,DIGCON,regTemp&~(0xC));
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_B0_1,0x3538E80L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_B1_1,0x3538E80L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_A1_1,0x1AA9100L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_B0_2,0x216D100L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_B1_2,0x2505400L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_B2_2,0x216D100L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_A1_2,0x2CB8100L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_A2_2,0x1D7FA500L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_B0_3,0x2CD9B00L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_B1_3,0x1276D00L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_B2_3,0x2CD9B00L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_A1_3,0x2335300L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_A2_3,0x19D5F700L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_B0_1,0x6A71D00L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_B1_1,0x6A71D00L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_A1_1,0x1AA9100L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_B0_2,0x216D100L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_B1_2,0x2505400L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_B2_2,0x216D100L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_A1_2,0x2CB8100L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_A2_2,0x1D7FA500L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_B0_3,0x2CD9B00L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_B1_3,0x1276D00L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_B2_3,0x2CD9B00L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_A1_3,0x2335300L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_A2_3,0x19D5F700L);
+    regTemp = ReadReg(pProHW,pProslic->channel,ENHANCE);
+    WriteReg(pProHW,pProslic->channel,ENHANCE,regTemp&~(1));
+  }
+  regTemp = Si3226x_PCM_Presets[preset].pcmFormat;
+  regTemp |= Si3226x_PCM_Presets[preset].pcm_tri << 5;
+  regTemp |= Si3226x_PCM_Presets[preset].alaw_inv << 2;
+  WriteReg(pProHW,pProslic->channel,PCMMODE,regTemp);
+  regTemp = ReadReg(pProHW,pProslic->channel,PCMTXHI);
+  regTemp &= 3;
+  regTemp |= Si3226x_PCM_Presets[preset].tx_edge<<4;
+  WriteReg(pProHW,pProslic->channel,PCMTXHI,regTemp);
+
+  return 0;
+}
+#endif
+
+/*
+**
+** PROSLIC CONTROL FUNCTIONS
+**
+*/
+
+/*
+** Function: PROSLIC_dbgSetDCFeed
+**
+** Description:
+** provisionary function for setting up
+** dcfeed given desired open circuit voltage
+** and loop current.
+*/
+int Si3226x_dbgSetDCFeed (proslicChanType *pProslic, uInt32 v_vlim_val,
+                          uInt32 i_ilim_val, int32 preset)
+{
+#ifndef DISABLE_DCFEED_SETUP
+  /* Note:  * needs more descriptive return codes in the event of an out of range argument */
+  uInt16 vslope = 160;
+  uInt16 rslope = 720;
+  uInt32 vscale1 = 1386;
+  uInt32 vscale2 =
+    1422;   /* 1386x1422 = 1970892 broken down to minimize trunc err */
+  uInt32 iscale1 = 913;
+  uInt32 iscale2 = 334;    /* 913x334 = 304942 */
+  uInt32 i_rfeed_val, v_rfeed_val, const_rfeed_val, i_vlim_val, const_ilim_val,
+         v_ilim_val;
+  int32 signedVal;
+  SILABS_UNREFERENCED_PARAMETER(pProslic);
+  /* Set Linefeed to open state before modifying DC Feed */
+
+  /* Assumptions must be made to minimize computations.  This limits the
+  ** range of available settings, but should be more than adequate for
+  ** short loop applications.
+  **
+  ** Assumtions:
+  **
+  ** SLOPE_VLIM      =>  160ohms
+  ** SLOPE_RFEED     =>  720ohms
+  ** I_RFEED         =>  3*I_ILIM/4
+  **
+  ** With these assumptions, the DC Feed parameters now become
+  **
+  ** Inputs:      V_VLIM, I_ILIM
+  ** Constants:   SLOPE_VLIM, SLOPE_ILIM, SLOPE_RFEED, SLOPE_DELTA1, SLOPE_DELTA2
+  ** Outputs:     V_RFEED, V_ILIM, I_VLIM, CONST_RFEED, CONST_ILIM
+  **
+  */
+
+  /* Validate arguments */
+  if((i_ilim_val < 15)||(i_ilim_val > 45))
+  {
+    return 1;  /* need error code */
+  }
+  if((v_vlim_val < 30)||(v_vlim_val > 52))
+  {
+    return 1;  /* need error code */
+  }
+
+  /* Calculate voltages in mV and currents in uA */
+  v_vlim_val *= 1000;
+  i_ilim_val *= 1000;
+
+  /* I_RFEED */
+  i_rfeed_val = (3*i_ilim_val)/4;
+
+  /* V_RFEED */
+  v_rfeed_val = v_vlim_val - (i_rfeed_val*vslope)/1000;
+
+  /* V_ILIM */
+  v_ilim_val = v_rfeed_val - (rslope*(i_ilim_val - i_rfeed_val))/1000;
+
+  /* I_VLIM */
+  i_vlim_val = (v_vlim_val*1000)/4903;
+
+  /* CONST_RFEED */
+  signedVal = v_rfeed_val * (i_ilim_val - i_rfeed_val);
+  signedVal /= (v_rfeed_val - v_ilim_val);
+  signedVal = i_rfeed_val + signedVal;
+
+  /* signedVal in uA here */
+  signedVal *= iscale1;
+  signedVal /= 100;
+  signedVal *= iscale2;
+  signedVal /= 10;
+
+  if(signedVal < 0)
+  {
+    const_rfeed_val = (signedVal)+ (1L<<29);
+  }
+  else
+  {
+    const_rfeed_val = signedVal & 0x1FFFFFFF;
+  }
+
+  /* CONST_ILIM */
+  const_ilim_val = i_ilim_val;
+
+  /* compute RAM values */
+  v_vlim_val *= vscale1;
+  v_vlim_val /= 100;
+  v_vlim_val *= vscale2;
+  v_vlim_val /= 10;
+
+  v_rfeed_val *= vscale1;
+  v_rfeed_val /= 100;
+  v_rfeed_val *= vscale2;
+  v_rfeed_val /= 10;
+
+  v_ilim_val *= vscale1;
+  v_ilim_val /= 100;
+  v_ilim_val *= vscale2;
+  v_ilim_val /= 10;
+
+  const_ilim_val *= iscale1;
+  const_ilim_val /= 100;
+  const_ilim_val *= iscale2;
+  const_ilim_val /= 10;
+
+  i_vlim_val *= iscale1;
+  i_vlim_val /= 100;
+  i_vlim_val *= iscale2;
+  i_vlim_val /= 10;
+
+  Si3226x_DCfeed_Presets[preset].slope_vlim = 0x18842BD7L;
+  Si3226x_DCfeed_Presets[preset].slope_rfeed = 0x1E8886DEL;
+  Si3226x_DCfeed_Presets[preset].slope_ilim = 0x40A0E0L;
+  Si3226x_DCfeed_Presets[preset].delta1 = 0x1EABA1BFL;
+  Si3226x_DCfeed_Presets[preset].delta2 = 0x1EF744EAL;
+  Si3226x_DCfeed_Presets[preset].v_vlim = v_vlim_val;
+  Si3226x_DCfeed_Presets[preset].v_rfeed = v_rfeed_val;
+  Si3226x_DCfeed_Presets[preset].v_ilim = v_ilim_val;
+  Si3226x_DCfeed_Presets[preset].const_rfeed = const_rfeed_val;
+  Si3226x_DCfeed_Presets[preset].const_ilim = const_ilim_val;
+  Si3226x_DCfeed_Presets[preset].i_vlim = i_vlim_val;
+
+  return RC_NONE;
+#else
+  SILABS_UNREFERENCED_PARAMETER(pProslic);
+  SILABS_UNREFERENCED_PARAMETER(preset);
+  SILABS_UNREFERENCED_PARAMETER(v_vlim_val);
+  SILABS_UNREFERENCED_PARAMETER(i_ilim_val);
+  return RC_IGNORE;
+#endif
+}
+
+/*
+** Function: PROSLIC_dbgSetDCFeedVopen
+**
+** Description:
+** provisionary function for setting up
+** dcfeed given desired open circuit voltage.
+** Entry I_ILIM value will be used.
+*/
+int Si3226x_dbgSetDCFeedVopen (proslicChanType *pProslic, uInt32 v_vlim_val,
+                               int32 preset)
+{
+#ifndef DISABLE_DCFEED_SETUP
+  uInt32 i_ilim_val;
+  uInt32 iscale1 = 913;
+  uInt32 iscale2 = 334;    /* 913x334 = 304942 */
+
+  /* Read present CONST_ILIM value */
+  i_ilim_val = Si3226x_DCfeed_Presets[preset].const_ilim;
+
+
+  i_ilim_val /= iscale2;
+  i_ilim_val /= iscale1;
+
+  return Si3226x_dbgSetDCFeed(pProslic,v_vlim_val,i_ilim_val,preset);
+#else
+  SILABS_UNREFERENCED_PARAMETER(pProslic);
+  SILABS_UNREFERENCED_PARAMETER(preset);
+  SILABS_UNREFERENCED_PARAMETER(v_vlim_val);
+  return RC_IGNORE;
+#endif
+}
+
+/*
+** Function: PROSLIC_dbgSetDCFeedIloop
+**
+** Description:
+** provisionary function for setting up
+** dcfeed given desired loop current.
+** Entry V_VLIM value will be used.
+*/
+int Si3226x_dbgSetDCFeedIloop (proslicChanType *pProslic, uInt32 i_ilim_val,
+                               int32 preset)
+{
+#ifndef DISABLE_DCFEED_SETUP
+  uInt32 v_vlim_val;
+  uInt32 vscale1 = 1386;
+  uInt32 vscale2 =
+    1422;   /* 1386x1422 = 1970892 broken down to minimize trunc err */
+
+  /* Read present V_VLIM value */
+  v_vlim_val = Si3226x_DCfeed_Presets[preset].v_vlim;
+
+  v_vlim_val /= vscale2;
+  v_vlim_val /= vscale1;
+
+  return Si3226x_dbgSetDCFeed(pProslic,v_vlim_val,i_ilim_val, preset);
+#else
+  SILABS_UNREFERENCED_PARAMETER(pProslic);
+  SILABS_UNREFERENCED_PARAMETER(preset);
+  SILABS_UNREFERENCED_PARAMETER(i_ilim_val);
+  return RC_IGNORE;
+#endif
+}
+
+typedef struct
+{
+  uInt8   freq;
+  ramData ringfr;      /* trise scale for trap */
+  uInt32  ampScale;
+} ProSLIC_SineRingFreqLookup;
+
+typedef struct
+{
+  uInt8    freq;
+  ramData  rtacth;
+  ramData rtper;
+  ramData rtdb;
+} ProSLIC_SineRingtripLookup;
+
+typedef struct
+{
+  uInt8   freq;
+  uInt16  cfVal[6];
+} ProSLIC_TrapRingFreqLookup;
+
+typedef struct
+{
+  uInt8   freq;
+  ramData rtper;
+  ramData rtdb;
+  uInt32  rtacth[6];
+} ProSLIC_TrapRingtripLookup;
+
+
+static const ProSLIC_SineRingFreqLookup sineRingFreqTable[] =
+    /*  Freq RINGFR, vScale */
+  {
+    {15, 0x7F6E930L, 18968L},
+    {16, 0x7F5A8E0L, 20234L},
+    {20, 0x7EFD9D5L, 25301L},
+    {22, 0x7EC770AL, 27843L},
+    {23, 0x7EAA6E2L, 29113L},
+    {25, 0x7E6C925L, 31649L},
+    {30, 0x7DBB96BL, 38014L},
+    {34, 0x7D34155L, 42270L}, /* Actually 33.33Hz */
+    {35, 0x7CEAD72L, 44397L},
+    {40, 0x7BFA887L, 50802L},
+    {45, 0x7AEAE74L, 57233L},
+    {50, 0x79BC384L, 63693L},
+    {0,0,0}
+  }; /* terminator */
+
+static const ProSLIC_SineRingtripLookup sineRingtripTable[] =
+    /*  Freq rtacth */
+  {
+    {15, 11440000L, 0x6A000L, 0x4000L },
+    {16, 10810000L, 0x64000L, 0x4000L },
+    {20, 8690000L,  0x50000L, 0x8000L },
+    {22, 7835000L,  0x48000L, 0x8000L },
+    {23, 7622000L,  0x46000L, 0x8000L },
+    {25, 6980000L,  0x40000L, 0xA000L },
+    {30, 5900000L,  0x36000L, 0xA000L },
+    {34, 10490000L, 0x60000L, 0x6000L }, /* Actually 33.33 */
+    {35, 10060000L, 0x5C000L, 0x6000L },
+    {40, 8750000L,  0x50000L, 0x8000L },
+    {45, 7880000L,  0x48000L, 0x8000L },
+    {50, 7010000L,  0x40000L, 0xA000L },
+    {0,0L, 0L, 0L}
+  }; /* terminator */
+
+static const ProSLIC_TrapRingFreqLookup trapRingFreqTable[] =
+    /*  Freq multCF11 multCF12 multCF13 multCF14 multCF15 multCF16*/
+  {
+    {15, {69,122, 163, 196, 222,244}},
+    {16, {65,115, 153, 184, 208,229}},
+    {20, {52,92, 122, 147, 167,183}},
+    {22, {47,83, 111, 134, 152,166}},
+    {23, {45,80, 107, 128, 145,159}},
+    {25, {42,73, 98, 118, 133,146}},
+    {30, {35,61, 82, 98, 111,122}},
+    {34, {31,55, 73, 88, 100,110}},
+    {35, {30,52, 70, 84, 95,104}},
+    {40, {26,46, 61, 73, 83,91}},
+    {45, {23,41, 54, 65, 74,81}},
+    {50, {21,37, 49, 59, 67,73}},
+    {0,{0L,0L,0L,0L}} /* terminator */
+  };
+
+
+static const ProSLIC_TrapRingtripLookup trapRingtripTable[] =
+    /*  Freq rtper rtdb rtacthCR11 rtacthCR12 rtacthCR13 rtacthCR14 rtacthCR15 rtacthCR16*/
+  {
+    {15, 0x6A000L,  0x4000L, {16214894L, 14369375L, 12933127L, 11793508L, 10874121L, 10121671L}},
+    {16, 0x64000L,  0x4000L, {15201463L, 13471289L, 12124806L, 11056414L, 10194489L, 9489067L}},
+    {20, 0x50000L,  0x6000L, {12161171L, 10777031L, 9699845L, 8845131L, 8155591L, 7591253L}},
+    {22, 0x48000L,  0x6000L, {11055610L, 9797301L, 8818041L, 8041028L, 7414174L, 6901139L}},
+    {23, 0x46000L,  0x6000L, {10574931L, 9371331L, 8434648L, 7691418L, 7091818L, 6601090L}},
+    {25, 0x40000L,  0x8000L, {9728937L, 8621625L, 7759876L, 7076105L, 6524473L, 6073003L}},
+    {30, 0x36000L,  0x8000L, {8107447L, 7184687L, 6466563L, 5896754L, 5437061L, 5060836L}},
+    {34, 0x60000L,  0x6000L, {7297432L, 6466865L, 5820489L, 5307609L, 4893844L, 4555208L}},
+    {35, 0x5C000L,  0x6000L, {6949240L, 6158303L, 5542769L, 5054361L, 4660338L, 4337859L}},
+    {40, 0x50000L,  0x6000L, {6080585L, 5388516L, 4849923L, 4422565L, 4077796L, 3795627L}},
+    {45, 0x48000L,  0x6000L, {5404965L, 4789792L, 4311042L, 3931169L, 3624707L, 3373890L}},
+    {50, 0x40000L,  0x8000L, {4864468L, 4310812L, 3879938L, 3538052L, 3262236L, 3036501L}},
+    {0,0x0L, 0x0L, {0L,0L,0L,0L}} /* terminator */
+  };
+
+
+/*
+** Function: PROSLIC_dbgRingingSetup
+**
+** Description:
+** Provisionary function for setting up
+** Ring type, frequency, amplitude and dc offset.
+** Main use will be by peek/poke applications.
+*/
+int Si3226x_dbgSetRinging (proslicChanType *pProslic,
+                           ProSLIC_dbgRingCfg *ringCfg, int preset)
+{
+#ifndef DISABLE_RING_SETUP
+  int errVal,i=0;
+  uInt32 vScale = 1608872L;   /* (2^28/170.25)*((100+4903)/4903) */
+  ramData dcdcVminTmp;
+
+  SILABS_UNREFERENCED_PARAMETER(pProslic);
+  errVal = 0;
+
+  switch(ringCfg->ringtype)
+  {
+    case ProSLIC_RING_SINE:
+      i=0;
+      do
+      {
+        if(sineRingFreqTable[i].freq >= ringCfg->freq)
+        {
+          break;
+        }
+        i++;
+      }
+      while (sineRingFreqTable[i].freq);
+
+      /* Set to maximum value if exceeding maximum value from table */
+      if(sineRingFreqTable[i].freq == 0)
+      {
+        i--;
+        errVal = 1;
+      }
+
+      /* Update RINGFR RINGAMP, RINGOFFSET, and RINGCON */
+      Si3226x_Ring_Presets[preset].freq = sineRingFreqTable[i].ringfr;
+      Si3226x_Ring_Presets[preset].amp = ringCfg->amp * sineRingFreqTable[i].ampScale;
+      Si3226x_Ring_Presets[preset].offset = ringCfg->offset * vScale;
+      Si3226x_Ring_Presets[preset].phas = 0L;
+
+      /* Don't alter anything in RINGCON other than clearing the TRAP bit */
+      Si3226x_Ring_Presets[preset].ringcon &= 0xFE;
+
+      Si3226x_Ring_Presets[preset].rtper = sineRingtripTable[i].rtper;
+      Si3226x_Ring_Presets[preset].rtacdb = sineRingtripTable[i].rtdb;
+      Si3226x_Ring_Presets[preset].rtdcdb = sineRingtripTable[i].rtdb;
+      Si3226x_Ring_Presets[preset].rtdcth = 0xFFFFFFFL;
+      Si3226x_Ring_Presets[preset].rtacth = sineRingtripTable[i].rtacth;
+      break;
+
+    case ProSLIC_RING_TRAP_CF11:
+    case ProSLIC_RING_TRAP_CF12:
+    case ProSLIC_RING_TRAP_CF13:
+    case ProSLIC_RING_TRAP_CF14:
+    case ProSLIC_RING_TRAP_CF15:
+    case ProSLIC_RING_TRAP_CF16:
+      i=0;
+      do
+      {
+        if(trapRingFreqTable[i].freq >= ringCfg->freq)
+        {
+          break;
+        }
+        i++;
+      }
+      while (trapRingFreqTable[i].freq);
+
+      /* Set to maximum value if exceeding maximum value from table */
+      if(trapRingFreqTable[i].freq == 0)
+      {
+        i--;
+        errVal = 1;
+      }
+
+      /* Update RINGFR RINGAMP, RINGOFFSET, and RINGCON */
+      Si3226x_Ring_Presets[preset].amp = ringCfg->amp * vScale;
+      Si3226x_Ring_Presets[preset].freq =
+        Si3226x_Ring_Presets[preset].amp/trapRingFreqTable[i].cfVal[ringCfg->ringtype];
+      Si3226x_Ring_Presets[preset].offset = ringCfg->offset * vScale;
+      Si3226x_Ring_Presets[preset].phas = 262144000L/trapRingFreqTable[i].freq;
+
+      /* Don't alter anything in RINGCON other than setting the TRAP bit */
+      Si3226x_Ring_Presets[preset].ringcon |= 0x01;
+
+      /* RTPER and debouce timers  */
+      Si3226x_Ring_Presets[preset].rtper = trapRingtripTable[i].rtper;
+      Si3226x_Ring_Presets[preset].rtacdb = trapRingtripTable[i].rtdb;
+      Si3226x_Ring_Presets[preset].rtdcdb = trapRingtripTable[i].rtdb;
+
+
+      Si3226x_Ring_Presets[preset].rtdcth = 0xFFFFFFFL;
+      Si3226x_Ring_Presets[preset].rtacth =
+        trapRingtripTable[i].rtacth[ringCfg->ringtype];
+
+
+      break;
+  }
+
+  /*
+  ** DCDC tracking sluggish under light load at higher ring freq.
+  ** Reduce tracking depth above 40Hz.  This should have no effect
+  ** if using the Buck-Boost architecture.
+  */
+  if((sineRingFreqTable[i].freq >= 40)
+      ||(Si3226x_General_Configuration.bomOpt == BO_DCDC_BUCK_BOOST))
+  {
+    dcdcVminTmp = ringCfg->amp + ringCfg->offset;
+    dcdcVminTmp *= 1000;
+    dcdcVminTmp *= SCALE_V_MADC;
+    Si3226x_Ring_Presets[preset].vbat_track_min_rng = dcdcVminTmp;
+  }
+  else
+  {
+    Si3226x_Ring_Presets[preset].vbat_track_min_rng = 0x1800000L;
+  }
+
+  return errVal;
+#else
+  SILABS_UNREFERENCED_PARAMETER(pProslic);
+  SILABS_UNREFERENCED_PARAMETER(preset);
+  SILABS_UNREFERENCED_PARAMETER(ringCfg);
+  return RC_IGNORE;
+#endif
+}
+
+
+typedef struct
+{
+  int32   gain;
+  uInt32 scale;
+} ProSLIC_GainScaleLookup;
+
+#ifndef ENABLE_HIRES_GAIN
+static int Si3226x_dbgSetGain (proslicChanType *pProslic, int32 gain,
+                               int impedance_preset, int tx_rx_sel)
+{
+  int errVal = 0;
+  int32 i;
+  int32 gain_pga, gain_eq;
+  const ProSLIC_GainScaleLookup gainScaleTable[]
+  =  /*  gain, scale=10^(gain/20) */
+  {
+    {-30, 32},
+    {-29, 35},
+    {-28, 40},
+    {-27, 45},
+    {-26, 50},
+    {-25, 56},
+    {-24, 63},
+    {-23, 71},
+    {-22, 79},
+    {-21, 89},
+    {-20, 100},
+    {-19, 112},
+    {-18, 126},
+    {-17, 141},
+    {-16, 158},
+    {-15, 178},
+    {-14, 200},
+    {-13, 224},
+    {-12, 251},
+    {-11, 282},
+    {-10, 316},
+    {-9, 355},
+    {-8, 398},
+    {-7, 447},
+    {-6, 501},
+    {-5, 562},
+    {-4, 631},
+    {-3, 708},
+    {-2, 794},
+    {-1, 891},
+    {0, 1000},
+    {1, 1122},
+    {2, 1259},
+    {3, 1413},
+    {4, 1585},
+    {5, 1778},
+    {6, 1995},
+    {0xff,0}  /* terminator */
+  };
+
+  SILABS_UNREFERENCED_PARAMETER(pProslic);
+
+  /*
+  ** 5.4.0 - Removed relative gain scaling. to support automatic adjustment based on
+  **         gain plan provided in txgain_db and rxgain_db.  It is presumed that all
+  **         coefficients were generated for 0dB/0dB gain and the txgain_db and rxgain_db
+  **         parameters will be used to scale the gain using the existing gain provisioning
+  **         infrastructure when the zsynth preset is loaded.  This function will ignore
+  **         the txgain_db and rxgain_db parameters and scale absolute gain presuming a
+  **         0dB/0dB coefficient set.
+  */
+  /*
+  ** 6.0.0 - Modifying where gain/attenuation is placed to minimize clipping.
+  **
+  **         RX Path:   -30dB < gain <  0dB -   All in RXACGAIN
+  **                      0dB < gain <  6dB -   All in RXACEQ
+  **
+  **         TX Path:   -30dB < gain <  0dB -   All in TXACEQ
+  **                      0dB < gain <  6dB -   All in TXACGAIN
+  */
+  /* Test against max gain */
+  if (gain > PROSLIC_EXTENDED_GAIN_MAX)
+  {
+    errVal = RC_GAIN_OUT_OF_RANGE;
+#ifdef ENABLE_DEBUG
+    if(pProslic->debugMode)
+    {
+      LOGPRINT("%sdbgSetGain : Gain %d out of range\n", LOGPRINT_PREFIX, (int)gain);
+    }
+#endif
+    gain = PROSLIC_EXTENDED_GAIN_MAX; /* Clamp to maximum */
+  }
+
+  /* Test against min gain */
+  if (gain < PROSLIC_GAIN_MIN)
+  {
+    errVal = RC_GAIN_OUT_OF_RANGE;
+#ifdef ENABLE_DEBUG
+    if(pProslic->debugMode)
+    {
+      LOGPRINT("%sdbgSetGain : Gain %d out of range\n", LOGPRINT_PREFIX, (int)gain);
+    }
+#endif
+    gain = PROSLIC_GAIN_MIN; /* Clamp to minimum */
+  }
+
+  /* Distribute gain */
+  if(gain == 0)
+  {
+    gain_pga = 0;
+    gain_eq = 0;
+  }
+  else if(gain > PROSLIC_GAIN_MAX)
+  {
+    if(tx_rx_sel == TXACGAIN_SEL)
+    {
+      gain_pga = PROSLIC_GAIN_MAX;
+      gain_eq = gain - PROSLIC_GAIN_MAX;
+    }
+    else
+    {
+      gain_pga = gain - PROSLIC_GAIN_MAX;
+      gain_eq = PROSLIC_GAIN_MAX;
+    }
+  }
+  else if(gain > 0)
+  {
+    if(tx_rx_sel == TXACGAIN_SEL)
+    {
+      gain_pga = gain;
+      gain_eq  = 0;
+    }
+    else
+    {
+      gain_pga = 0;
+      gain_eq = gain;
+    }
+  }
+  else
+  {
+    if(tx_rx_sel == TXACGAIN_SEL)
+    {
+      gain_pga = 0;
+      gain_eq  = gain;
+    }
+    else
+    {
+      gain_pga = gain;
+      gain_eq = 0;
+    }
+
+  }
+
+  /*
+  ** Lookup PGA Appropriate PGA Gain
+  */
+  i=0;
+  do
+  {
+    if(gainScaleTable[i].gain >= gain_pga)
+    {
+      break;
+    }
+    i++;
+  }
+  while (gainScaleTable[i].gain!=0xff);
+
+  /* Set to maximum value if exceeding maximum value from table */
+  if(gainScaleTable[i].gain == 0xff)
+  {
+    i--;
+    errVal = RC_GAIN_DELTA_TOO_LARGE;
+  }
+
+  if(tx_rx_sel == TXACGAIN_SEL)
+  {
+    Si3226x_audioGain_Presets[0].acgain =
+      (Si3226x_Impedance_Presets[impedance_preset].txgain/1000)
+      *gainScaleTable[i].scale;
+  }
+  else
+  {
+    Si3226x_audioGain_Presets[1].acgain =
+      (Si3226x_Impedance_Presets[impedance_preset].rxgain/1000)
+      *gainScaleTable[i].scale;
+  }
+
+  /*
+  ** Lookup EQ Gain
+  */
+  i=0;
+  do
+  {
+    if(gainScaleTable[i].gain >= gain_eq)
+    {
+      break;
+    }
+    i++;
+  }
+  while (gainScaleTable[i].gain!=0xff);
+
+  /* Set to maximum value if exceeding maximum value from table */
+  if(gainScaleTable[i].gain == 0xff)
+  {
+    i--;
+    errVal = RC_GAIN_DELTA_TOO_LARGE;
+  }
+
+  if(tx_rx_sel == TXACGAIN_SEL)
+  {
+    /*sign extend negative numbers*/
+    if (Si3226x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c0 & 0x10000000L)
+    {
+      Si3226x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c0 |= 0xf0000000L;
+    }
+    if (Si3226x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c1 & 0x10000000L)
+    {
+      Si3226x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c1 |= 0xf0000000L;
+    }
+    if (Si3226x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c2 & 0x10000000L)
+    {
+      Si3226x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c2 |= 0xf0000000L;
+    }
+    if (Si3226x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c3 & 0x10000000L)
+    {
+      Si3226x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c3 |= 0xf0000000L;
+    }
+
+    Si3226x_audioGain_Presets[0].aceq_c0 = ((int32)
+                                            Si3226x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c0/1000)
+                                           *gainScaleTable[i].scale;
+    Si3226x_audioGain_Presets[0].aceq_c1 = ((int32)
+                                            Si3226x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c1/1000)
+                                           *gainScaleTable[i].scale;
+    Si3226x_audioGain_Presets[0].aceq_c2 = ((int32)
+                                            Si3226x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c2/1000)
+                                           *gainScaleTable[i].scale;
+    Si3226x_audioGain_Presets[0].aceq_c3 = ((int32)
+                                            Si3226x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c3/1000)
+                                           *gainScaleTable[i].scale;
+  }
+  else
+  {
+    /*sign extend negative numbers*/
+    if (Si3226x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c0 & 0x10000000L)
+    {
+      Si3226x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c0 |= 0xf0000000L;
+    }
+    if (Si3226x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c1 & 0x10000000L)
+    {
+      Si3226x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c1 |= 0xf0000000L;
+    }
+    if (Si3226x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c2 & 0x10000000L)
+    {
+      Si3226x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c2 |= 0xf0000000L;
+    }
+    if (Si3226x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c3 & 0x10000000L)
+    {
+      Si3226x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c3 |= 0xf0000000L;
+    }
+
+    Si3226x_audioGain_Presets[1].aceq_c0 = ((int32)
+                                            Si3226x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c0/1000)
+                                           *gainScaleTable[i].scale;
+    Si3226x_audioGain_Presets[1].aceq_c1 = ((int32)
+                                            Si3226x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c1/1000)
+                                           *gainScaleTable[i].scale;
+    Si3226x_audioGain_Presets[1].aceq_c2 = ((int32)
+                                            Si3226x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c2/1000)
+                                           *gainScaleTable[i].scale;
+    Si3226x_audioGain_Presets[1].aceq_c3 = ((int32)
+                                            Si3226x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c3/1000)
+                                           *gainScaleTable[i].scale;
+  }
+
+
+  return errVal;
+}
+
+#else /* ENABLE_HIRES_GAIN */
+/* Same as Si3226x_dbgSetGain() except gain is expressed in dB*10 to achieve 0.1dB resolution */
+static int Si3226x_dbgSetGainHiRes (proslicChanType *pProslic, int32 gain,
+                                    int impedance_preset, int tx_rx_sel)
+{
+  int errVal = 0;
+  int32 i;
+  int32 coarseGainIndex, fineGainIndex;
+  int32 gain_pga, gain_eq;
+  int32 coarseGain, fineGain;
+  int32 tmp;
+  const ProSLIC_GainScaleLookup coarseGainScaleTable[]
+  =  /*  gain, scale=10^(gain/20) */
+  {
+    {-30, 32},
+    {-29, 35},
+    {-28, 40},
+    {-27, 45},
+    {-26, 50},
+    {-25, 56},
+    {-24, 63},
+    {-23, 71},
+    {-22, 79},
+    {-21, 89},
+    {-20, 100},
+    {-19, 112},
+    {-18, 126},
+    {-17, 141},
+    {-16, 158},
+    {-15, 178},
+    {-14, 200},
+    {-13, 224},
+    {-12, 251},
+    {-11, 282},
+    {-10, 316},
+    {-9, 355},
+    {-8, 398},
+    {-7, 447},
+    {-6, 501},
+    {-5, 562},
+    {-4, 631},
+    {-3, 708},
+    {-2, 794},
+    {-1, 891},
+    {0, 1000},
+    {1, 1122},
+    {2, 1259},
+    {3, 1413},
+    {4, 1585},
+    {5, 1778},
+    {6, 1995},
+    {0xff,0}  /* terminator */
+  };
+
+  const ProSLIC_GainScaleLookup fineGainScaleTable[]
+  =  /*  gain, scale=10^(gain/20) */
+  {
+    {-9, 902},
+    {-8, 912},
+    {-7, 923},
+    {-6, 933},
+    {-5, 944},
+    {-4, 955},
+    {-3, 966},
+    {-2, 977},
+    {-1, 989},
+    {0, 1000},
+    {1, 1012},
+    {2, 1023},
+    {3, 1035},
+    {4, 1047},
+    {5, 1059},
+    {6, 1072},
+    {7, 1084},
+    {8, 1096},
+    {9, 1109},
+    {0xff,0}  /* terminator */
+  };
+
+  SILABS_UNREFERENCED_PARAMETER(pProslic);
+
+  /*
+  ** 6.0.0 - Modifying where gain/attenuation is placed to minimize clipping.
+  **
+  **         RX Path:   -30dB < gain <  0dB -   All in RXACGAIN
+  **                      0dB < gain <  6dB -   All in RXACEQ
+  **
+  **         TX Path:   -30dB < gain <  0dB -   All in TXACEQ
+  **                      0dB < gain <  6dB -   All in TXACGAIN
+  **
+  ** 6.2.1 - Added option for fine gain adjust.  All fine adjustment done
+  **         in RXACGAIN and TXACEQ
+  */
+
+  /* Test against max gain */
+  if (gain > (PROSLIC_GAIN_MAX*10L))
+  {
+    errVal = RC_GAIN_OUT_OF_RANGE;
+#ifdef ENABLE_DEBUG
+    if(pProslic->debugMode)
+    {
+      LOGPRINT("%s dbgSetGain : Gain %d dB*10 out of range\n", LOGPRINT_PREFIX, gain);
+    }
+#endif
+    gain = (PROSLIC_GAIN_MAX*10L); /* Clamp to maximum */
+  }
+
+  /* Test against min gain */
+  if (gain < (PROSLIC_GAIN_MIN*10L))
+  {
+    errVal = RC_GAIN_OUT_OF_RANGE;
+#ifdef ENABLE_DEBUG
+    if(pProslic->debugMode)
+    {
+      LOGPRINT("%sdbgSetGain : Gain %d dB*10 out of range\n", LOGPRINT_PREFIX, gain);
+    }
+#endif
+    gain = (PROSLIC_GAIN_MIN*10); /* Clamp to minimum */
+  }
+
+  /* Distribute gain */
+  coarseGain = gain/10L;
+  fineGain = gain - (coarseGain*10L);
+
+  /* Distribute coarseGain */
+  if(coarseGain == 0)
+  {
+    gain_pga = 0;
+    gain_eq = 0;
+  }
+  else if(coarseGain > 0)
+  {
+    if(tx_rx_sel == TXACGAIN_SEL)
+    {
+      gain_pga = coarseGain;
+      gain_eq  = 0;
+    }
+    else
+    {
+      gain_pga = 0;
+      gain_eq = coarseGain;
+    }
+  }
+  else
+  {
+    if(tx_rx_sel == TXACGAIN_SEL)
+    {
+      gain_pga = 0;
+      gain_eq  = coarseGain;
+    }
+    else
+    {
+      gain_pga = coarseGain;
+      gain_eq = 0;
+    }
+  }
+
+  /*
+  ** Lookup PGA Appopriate PGA Gain
+  */
+  i=0;
+  do
+  {
+    if(coarseGainScaleTable[i].gain >= gain_pga)
+    {
+      break;
+    }
+    i++;
+  }
+  while (coarseGainScaleTable[i].gain!=0xff);
+
+  /* Set to maximum value if exceeding maximum value from table */
+  if(coarseGainScaleTable[i].gain == 0xff)
+  {
+    i--;
+    errVal = RC_GAIN_DELTA_TOO_LARGE;
+  }
+
+  coarseGainIndex = i;  /* Store coarse index */
+
+  /* Find fineGain */
+  i = 0;
+  do
+  {
+    if(fineGainScaleTable[i].gain >= fineGain)
+    {
+      break;
+    }
+    i++;
+  }
+  while (fineGainScaleTable[i].gain!=0xff);
+
+  /* Set to maximum value if exceeding maximum value from table */
+  if(fineGainScaleTable[i].gain == 0xff)
+  {
+    i--;
+    errVal = RC_GAIN_DELTA_TOO_LARGE;
+  }
+
+  fineGainIndex = i;
+
+  if(tx_rx_sel == TXACGAIN_SEL)
+  {
+    Si3226x_audioGain_Presets[0].acgain = ((
+        Si3226x_Impedance_Presets[impedance_preset].txgain/1000L)
+                                           *coarseGainScaleTable[coarseGainIndex].scale); /* /1000L * fineGainScaleTable[fineGainIndex].scale; */
+  }
+  else
+  {
+    Si3226x_audioGain_Presets[1].acgain = ((
+        Si3226x_Impedance_Presets[impedance_preset].rxgain/1000L)
+                                           *coarseGainScaleTable[coarseGainIndex].scale)/1000L *
+                                          fineGainScaleTable[fineGainIndex].scale;
+  }
+
+  /*
+  ** Lookup EQ Gain
+  */
+  i=0;
+  do
+  {
+    if(coarseGainScaleTable[i].gain >= gain_eq)
+    {
+      break;
+    }
+    i++;
+  }
+  while (coarseGainScaleTable[i].gain!=0xff);
+
+  /* Set to maximum value if exceeding maximum value from table */
+  if(coarseGainScaleTable[i].gain == 0xff)
+  {
+    i--;
+    errVal = RC_GAIN_DELTA_TOO_LARGE;
+  }
+
+  coarseGainIndex = i;  /* Store coarse index */
+
+  if(tx_rx_sel == TXACGAIN_SEL)
+  {
+    /*sign extend negative numbers*/
+    if (Si3226x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c0 & 0x10000000L)
+    {
+      Si3226x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c0 |= 0xf0000000L;
+    }
+    if (Si3226x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c1 & 0x10000000L)
+    {
+      Si3226x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c1 |= 0xf0000000L;
+    }
+    if (Si3226x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c2 & 0x10000000L)
+    {
+      Si3226x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c2 |= 0xf0000000L;
+    }
+    if (Si3226x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c3 & 0x10000000L)
+    {
+      Si3226x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c3 |= 0xf0000000L;
+    }
+
+    tmp = (((int32)
+            Si3226x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c0/1000L)
+           *coarseGainScaleTable[coarseGainIndex].scale);
+    tmp = tmp / (int32)1000L;
+    tmp = tmp * (int32)fineGainScaleTable[fineGainIndex].scale;
+    Si3226x_audioGain_Presets[0].aceq_c0 = tmp;
+
+    tmp = (((int32)
+            Si3226x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c1/1000L)
+           *coarseGainScaleTable[coarseGainIndex].scale);
+    tmp = tmp / (int32)1000L;
+    tmp = tmp * (int32)fineGainScaleTable[fineGainIndex].scale;
+    Si3226x_audioGain_Presets[0].aceq_c1 = tmp;
+
+    tmp = (((int32)
+            Si3226x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c2/1000L)
+           *coarseGainScaleTable[coarseGainIndex].scale);
+    tmp = tmp / (int32)1000L;
+    tmp = tmp * (int32)fineGainScaleTable[fineGainIndex].scale;
+    Si3226x_audioGain_Presets[0].aceq_c2 = tmp;
+
+    tmp = (((int32)
+            Si3226x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c3/1000L)
+           *coarseGainScaleTable[coarseGainIndex].scale);
+    tmp = tmp / (int32)1000L;
+    tmp = tmp * (int32)fineGainScaleTable[fineGainIndex].scale;
+    Si3226x_audioGain_Presets[0].aceq_c3 = tmp;
+  }
+  else
+  {
+    /*sign extend negative numbers*/
+    if (Si3226x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c0 & 0x10000000L)
+    {
+      Si3226x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c0 |= 0xf0000000L;
+    }
+    if (Si3226x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c1 & 0x10000000L)
+    {
+      Si3226x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c1 |= 0xf0000000L;
+    }
+    if (Si3226x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c2 & 0x10000000L)
+    {
+      Si3226x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c2 |= 0xf0000000L;
+    }
+    if (Si3226x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c3 & 0x10000000L)
+    {
+      Si3226x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c3 |= 0xf0000000L;
+    }
+
+    Si3226x_audioGain_Presets[1].aceq_c0 = ((int32)
+                                            Si3226x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c0/1000)
+                                           *coarseGainScaleTable[i].scale;
+    Si3226x_audioGain_Presets[1].aceq_c1 = ((int32)
+                                            Si3226x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c1/1000)
+                                           *coarseGainScaleTable[i].scale;
+    Si3226x_audioGain_Presets[1].aceq_c2 = ((int32)
+                                            Si3226x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c2/1000)
+                                           *coarseGainScaleTable[i].scale;
+    Si3226x_audioGain_Presets[1].aceq_c3 = ((int32)
+                                            Si3226x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c3/1000)
+                                           *coarseGainScaleTable[i].scale;
+  }
+
+
+  return errVal;
+}
+#endif
+/*
+** Function: PROSLIC_dbgSetTXGain
+**
+** Description:
+** Provisionary function for setting up
+** TX gain
+*/
+int Si3226x_dbgSetTXGain (proslicChanType *pProslic, int32 gain,
+                          int impedance_preset, int audio_gain_preset)
+{
+#ifdef ENABLE_HIRES_GAIN
+  return Si3226x_dbgSetGainHiRes(pProslic,gain,impedance_preset,
+                                 audio_gain_preset);
+#else
+  return Si3226x_dbgSetGain(pProslic,gain,impedance_preset,audio_gain_preset);
+#endif
+}
+
+/*
+** Function: PROSLIC_dbgSetRXGain
+**
+** Description:
+** Provisionary function for setting up
+** RX gain
+*/
+int Si3226x_dbgSetRXGain (proslicChanType *pProslic, int32 gain,
+                          int impedance_preset, int audio_gain_preset)
+{
+#ifdef ENABLE_HIRES_GAIN
+  return Si3226x_dbgSetGainHiRes(pProslic,gain,impedance_preset,
+                                 audio_gain_preset);
+#else
+  return Si3226x_dbgSetGain(pProslic,gain,impedance_preset,audio_gain_preset);
+#endif
+}
+
+
+/*
+** Function: Si3226x_LineMonitor
+**
+** Description:
+** Monitor line voltages and currents
+*/
+int Si3226x_LineMonitor(proslicChanType *pProslic, proslicMonitorType *monitor)
+{
+  if(pProslic->channelEnable)
+  {
+    monitor->vtr    = ReadRAM(pProHW,pProslic->channel,VDIFF_FILT);
+    if(monitor->vtr & 0x10000000L)
+    {
+      monitor->vtr |= 0xf0000000L;
+    }
+    monitor->vtr /= SCALE_V_MADC;
+
+    monitor->vtip    = ReadRAM(pProHW,pProslic->channel,VTIP);
+    if(monitor->vtip & 0x10000000L)
+    {
+      monitor->vtip |= 0xf0000000L;
+    }
+    monitor->vtip /= SCALE_V_MADC;
+
+    monitor->vring    = ReadRAM(pProHW,pProslic->channel,VRING);
+    if(monitor->vring & 0x10000000L)
+    {
+      monitor->vring |= 0xf0000000L;
+    }
+    monitor->vring /= SCALE_V_MADC;
+
+    monitor->vlong    = ReadRAM(pProHW,pProslic->channel,MADC_VLONG);
+    if(monitor->vlong & 0x10000000L)
+    {
+      monitor->vlong |= 0xf0000000L;
+    }
+    monitor->vlong /= SCALE_V_MADC;
+
+    monitor->vbat    = ReadRAM(pProHW,pProslic->channel,MADC_VBAT);
+    if(monitor->vbat & 0x10000000L)
+    {
+      monitor->vbat |= 0xf0000000L;
+    }
+    monitor->vbat /= SCALE_V_MADC;
+
+    monitor->vdc    = ReadRAM(pProHW,pProslic->channel,MADC_VDC);
+    if(monitor->vdc & 0x10000000L)
+    {
+      monitor->vdc |= 0xf0000000L;
+    }
+    monitor->vdc *= -1L;    /* Invert since sensor inverted */
+    monitor->vdc /= SCALE_V_MADC;
+
+    monitor->itr  = ReadRAM(pProHW,pProslic->channel,MADC_ILOOP);
+    if(monitor->itr & 0x10000000L)
+    {
+      monitor->itr |= 0xf0000000L;
+    }
+    monitor->itr /= SCALE_I_MADC;
+
+    monitor->itip  = ReadRAM(pProHW,pProslic->channel,MADC_ITIP);
+    if(monitor->itip & 0x10000000L)
+    {
+      monitor->itip |= 0xf0000000L;
+    }
+    monitor->itip /= SCALE_I_MADC;
+
+    monitor->iring  = ReadRAM(pProHW,pProslic->channel,MADC_IRING);
+    if(monitor->iring & 0x10000000L)
+    {
+      monitor->iring |= 0xf0000000L;
+    }
+    monitor->iring /= SCALE_I_MADC;
+
+    monitor->ilong  = ReadRAM(pProHW,pProslic->channel,MADC_ILONG);
+    if(monitor->ilong & 0x10000000L)
+    {
+      monitor->ilong |= 0xf0000000L;
+    }
+    monitor->ilong /= SCALE_I_MADC;
+
+    monitor->p_hvic  = ReadRAM(pProHW,pProslic->channel,P_Q1_D); /* P_HVIC_LPF */
+    if(monitor->p_hvic & 0x10000000L)
+    {
+      monitor->p_hvic |= 0xf0000000L;
+    }
+    monitor->p_hvic /= SCALE_P_MADC;
+
+  }
+
+  return 0;
+}
+
+/*
+** Function: Si3226x_PSTNCheck
+**
+** Description:
+** Continuous monitoring of longitudinal current.
+** If an average of N samples exceed avgThresh or a
+** single sample exceeds singleThresh, the linefeed
+** is forced into the open state.
+**
+** This protects the port from connecting to a live
+** pstn line (faster than power alarm).
+**
+** TODO:  need error handling
+*/
+int Si3226x_PSTNCheck (proslicChanType *pProslic,
+                       proslicPSTNCheckObjType *pPSTNCheck)
+{
+  uInt8 i;
+
+  if(pPSTNCheck->samples == 0)
+  {
+    return RC_NONE;
+  }
+
+  /* Adjust buffer index */
+  if(pPSTNCheck->count >= pPSTNCheck->samples)
+  {
+    pPSTNCheck->buffFull = TRUE;
+    pPSTNCheck->count = 0;   /* reset buffer ptr */
+  }
+
+  /* Read next sample */
+  pPSTNCheck->ilong[pPSTNCheck->count]  = ReadRAM(pProHW,pProslic->channel,
+                                          MADC_ILONG);
+  if(pPSTNCheck->ilong[pPSTNCheck->count] & 0x10000000L)
+  {
+    pPSTNCheck->ilong[pPSTNCheck->count] |= 0xf0000000L;
+  }
+  pPSTNCheck->ilong[pPSTNCheck->count] /= SCALE_I_MADC;
+
+  /* Monitor magnitude only */
+  if(pPSTNCheck->ilong[pPSTNCheck->count] < 0)
+  {
+    pPSTNCheck->ilong[pPSTNCheck->count] = -pPSTNCheck->ilong[pPSTNCheck->count];
+  }
+
+  /* Quickly test for single measurement violation */
+  if(pPSTNCheck->ilong[pPSTNCheck->count] > pPSTNCheck->singleThresh)
+  {
+    return 1;  /* fail */
+  }
+
+  /* Average once buffer is full */
+  if(pPSTNCheck->buffFull == TRUE)
+  {
+    pPSTNCheck->avgIlong = 0;
+    for(i=0; i<pPSTNCheck->samples; i++)
+    {
+      pPSTNCheck->avgIlong += pPSTNCheck->ilong[i];
+    }
+    pPSTNCheck->avgIlong /= pPSTNCheck->samples;
+
+    if(pPSTNCheck->avgIlong > pPSTNCheck->avgThresh)
+    {
+      /* reinit obj and return fail */
+      pPSTNCheck->count = 0;
+      pPSTNCheck->buffFull = FALSE;
+      return 1;
+    }
+    else
+    {
+      pPSTNCheck->count++;
+      return 0;
+    }
+  }
+  else
+  {
+    pPSTNCheck->count++;
+    return 0;
+  }
+}
+
+/*
+** Function: Si3226x_GetRAMScale
+**
+** Description:
+** Read scale factor for passed RAM location
+**
+** Return Value:
+** int32 scale
+*/
+static int32 Si3226x_GetRAMScale(uInt16 addr)
+{
+  int32 scale;
+
+  switch(addr)
+  {
+    case MADC_ILOOP:
+    case MADC_ITIP:
+    case MADC_IRING:
+    case MADC_ILONG:
+      scale = SCALE_I_MADC;
+      break;
+
+    case MADC_VTIPC:
+    case MADC_VRINGC:
+    case MADC_VBAT:
+    case MADC_VLONG:
+    case MADC_VDC:
+    case MADC_VDC_OS:
+    case VDIFF_SENSE:
+    case VDIFF_FILT:
+    case VDIFF_COARSE:
+    case VTIP:
+    case VRING:
+    case SI3226X_PRAM_VBATH_NEON:
+      scale = SCALE_V_MADC;
+      break;
+
+    case P_HVIC:
+    case P_Q1_D:   /* P_HVIC_LPF */
+      scale = SCALE_P_MADC;
+      break;
+    default:
+      scale = 1;
+      break;
+  }
+
+  return scale;
+}
+
+/*
+** Function: Si3226x_ReadMADCScaled
+**
+** Description:
+** Read MADC (or other sensed voltages/currents) and
+** return scaled value in int32 format.
+**
+** Return Value:
+** int32 voltage in mV or
+** int32 current in uA
+*/
+int32 Si3226x_ReadMADCScaled(proslicChanType_ptr pProslic,uInt16 addr,
+                             int32 scale)
+{
+  int32 data;
+
+  /*
+  ** Read 29-bit RAM and sign extend to 32-bits
+  */
+  data = ReadRAM(pProHW,pProslic->channel,addr);
+  if(data & 0x10000000L)
+  {
+    data |= 0xF0000000L;
+  }
+
+  /*
+  ** Scale to provided value, or use defaults if scale = 0
+  */
+  if(scale == 0)
+  {
+    scale = Si3226x_GetRAMScale(addr);
+  }
+
+  data /= scale;
+
+  return data;
+}
+
+#ifdef PSTN_DET_ENABLE
+/*
+** Function: abs_int32
+**
+** Description:
+** abs implementation for int32 type
+*/
+static int32 abs_int32(int32 a)
+{
+  if(a < 0)
+  {
+    return -1*a;
+  }
+  return a;
+}
+
+/*
+** Function: Si3226x_DiffPSTNCheck
+**
+** Description:
+** Monitor for excessive longitudinal current, which
+** would be present if a live pstn line was connected
+** to the port.
+**
+** Returns:
+** RC_NONE             - test in progress
+** RC_COMPLETE_NO_ERR  - test complete, no alarms or errors
+** RC_PSTN_OPEN_FEMF   - test detected foreign voltage
+**
+*/
+
+int Si3226x_DiffPSTNCheck (proslicChanType *pProslic,
+                           proslicDiffPSTNCheckObjType *pPSTNCheck)
+{
+  uInt8 loop_status;
+  int i;
+
+  if(pProslic->channelType != PROSLIC)
+  {
+    return RC_CHANNEL_TYPE_ERR;    /* Ignore DAA channels */
+  }
+
+
+  switch(pPSTNCheck->pState.stage)
+  {
+    case 0:
+      /* Optional OPEN foreign voltage measurement - only execute if LCS = 0 */
+      /* Disable low power mode */
+      pPSTNCheck->enhanceRegSave = ReadReg(pProHW,pProslic->channel,ENHANCE);
+      if(pProslic->deviceId->chipRev != 0)    /* must stay in pwrsave mode on rev A */
+      {
+        WriteReg(pProHW,pProslic->channel, ENHANCE,
+                 pPSTNCheck->enhanceRegSave&0x07); /* Disable powersave */
+      }
+      pPSTNCheck->vdiff1_avg = 0;
+      pPSTNCheck->vdiff2_avg = 0;
+      pPSTNCheck->iloop1_avg = 0;
+      pPSTNCheck->iloop2_avg = 0;
+      pPSTNCheck->return_status = RC_COMPLETE_NO_ERR;
+      /* Do OPEN state hazardous voltage measurement if enabled and ONHOOK */
+      ProSLIC_ReadHookStatus(pProslic,&loop_status);
+      if((loop_status == PROSLIC_ONHOOK)&&(pPSTNCheck->femf_enable == 1))
+      {
+        pPSTNCheck->pState.stage++;
+      }
+      else
+      {
+        pPSTNCheck->pState.stage = 10;
+      }
+      return RC_NONE;
+
+    case 1:
+      /* Change linefeed to OPEN state for HAZV measurement, setup coarse sensors */
+      pPSTNCheck->lfstate_entry = ReadReg(pProHW,pProslic->channel, LINEFEED);
+      ProSLIC_SetLinefeedStatus(pProslic,LF_OPEN);
+      pPSTNCheck->pState.stage++;
+      return RC_NONE;
+
+    case 2:
+      /* Settle */
+      ProSLIC_PSTN_delay_poll(&(pPSTNCheck->pState), PSTN_DET_OPEN_FEMF_SETTLE);
+      return RC_NONE;
+
+    case 3:
+      /* Measure HAZV */
+      pPSTNCheck->vdiff_open = Si3226x_ReadMADCScaled(pProslic,VDIFF_COARSE,0);
+      /* Stop PSTN check if differential voltage > max_femf_vopen present */
+#ifdef ENABLE_DEBUG
+      if (pProslic->debugMode)
+      {
+        LOGPRINT("%sDiff PSTN : Vopen = %d mV\n", LOGPRINT_PREFIX,
+                 pPSTNCheck->vdiff_open);
+      }
+#endif
+      if(abs_int32(pPSTNCheck->vdiff_open) > pPSTNCheck->max_femf_vopen)
+      {
+        pPSTNCheck->pState.stage = 70;
+        pPSTNCheck->return_status = RC_PSTN_OPEN_FEMF;
+      }
+      else
+      {
+        pPSTNCheck->pState.stage = 10;
+      }
+      return 0;
+
+    case 10:
+      /* Load first DC feed preset */
+      ProSLIC_DCFeedSetup(pProslic,pPSTNCheck->dcfPreset1);
+      ProSLIC_SetLinefeedStatus(pProslic,LF_FWD_ACTIVE);
+      pPSTNCheck->pState.stage++;
+      return RC_NONE;
+
+    case 11:
+      /* Settle */
+      ProSLIC_PSTN_delay_poll(&(pPSTNCheck->pState), PSTN_DET_DIFF_IV1_SETTLE);
+      return RC_NONE;
+
+    case 12:
+      /* Measure VDIFF and ILOOP, switch to 2nd DCFEED setup */
+      pPSTNCheck->vdiff1[pPSTNCheck->pState.sampleIterations] =
+        Si3226x_ReadMADCScaled(pProslic,VDIFF_FILT,0);
+      pPSTNCheck->iloop1[pPSTNCheck->pState.sampleIterations] =
+        Si3226x_ReadMADCScaled(pProslic,MADC_ILOOP,0);
+#ifdef ENABLE_DEBUG
+      if (pProslic->debugMode)
+      {
+        LOGPRINT("%sDiff PSTN : Vdiff1[%d] = %d mV\n",
+                 LOGPRINT_PREFIX,
+                 pPSTNCheck->pState.sampleIterations,
+                 pPSTNCheck->vdiff1[pPSTNCheck->pState.sampleIterations]);
+        LOGPRINT("%sDiff PSTN : Iloop1[%d] = %d uA\n",
+                 LOGPRINT_PREFIX,
+                 pPSTNCheck->pState.sampleIterations,
+                 pPSTNCheck->iloop1[pPSTNCheck->pState.sampleIterations]);
+      }
+#endif
+      pPSTNCheck->pState.sampleIterations++;
+      if(pPSTNCheck->pState.sampleIterations >= pPSTNCheck->samples)
+      {
+        ProSLIC_DCFeedSetup(pProslic,pPSTNCheck->dcfPreset2);
+        pPSTNCheck->pState.stage++;
+        pPSTNCheck->pState.sampleIterations = 0;
+      }
+      return RC_NONE;
+
+    case 13:
+      /* Settle feed 500ms */
+      ProSLIC_PSTN_delay_poll(&(pPSTNCheck->pState), PSTN_DET_DIFF_IV2_SETTLE);
+      return RC_NONE;
+
+    case 14:
+      /* Measure VDIFF and ILOOP*/
+      pPSTNCheck->vdiff2[pPSTNCheck->pState.sampleIterations] =
+        Si3226x_ReadMADCScaled(pProslic,VDIFF_FILT,0);
+      pPSTNCheck->iloop2[pPSTNCheck->pState.sampleIterations] =
+        Si3226x_ReadMADCScaled(pProslic,MADC_ILOOP,0);
+#ifdef ENABLE_DEBUG
+      if (pProslic->debugMode)
+      {
+        LOGPRINT("%sDiff PSTN : Vdiff2[%d] = %d mV\n", LOGPRINT_PREFIX,
+                 pPSTNCheck->pState.sampleIterations,
+                 pPSTNCheck->vdiff2[pPSTNCheck->pState.sampleIterations]);
+        LOGPRINT("%sDiff PSTN : Iloop2[%d] = %d uA\n", LOGPRINT_PREFIX,
+                 pPSTNCheck->pState.sampleIterations,
+                 pPSTNCheck->iloop2[pPSTNCheck->pState.sampleIterations]);
+      }
+#endif
+      pPSTNCheck->pState.sampleIterations++;
+      if(pPSTNCheck->pState.sampleIterations >= pPSTNCheck->samples)
+      {
+        /* Compute averages */
+        for (i=0; i<pPSTNCheck->samples; i++)
+        {
+          pPSTNCheck->vdiff1_avg += pPSTNCheck->vdiff1[i];
+          pPSTNCheck->iloop1_avg += pPSTNCheck->iloop1[i];
+          pPSTNCheck->vdiff2_avg += pPSTNCheck->vdiff2[i];
+          pPSTNCheck->iloop2_avg += pPSTNCheck->iloop2[i];
+        }
+        pPSTNCheck->vdiff1_avg /= pPSTNCheck->samples;
+        pPSTNCheck->iloop1_avg /= pPSTNCheck->samples;
+        pPSTNCheck->vdiff2_avg /= pPSTNCheck->samples;
+        pPSTNCheck->iloop2_avg /= pPSTNCheck->samples;
+
+        /* Force small (probably offset) currents to minimum value */
+        if(abs_int32(pPSTNCheck->iloop1_avg) < PSTN_DET_MIN_ILOOP)
+        {
+          pPSTNCheck->iloop1_avg = PSTN_DET_MIN_ILOOP;
+        }
+        if(abs_int32(pPSTNCheck->iloop2_avg) < PSTN_DET_MIN_ILOOP)
+        {
+          pPSTNCheck->iloop2_avg = PSTN_DET_MIN_ILOOP;
+        }
+
+
+        /* Calculate measured loop impedance */
+        pPSTNCheck->rl1 = abs_int32((
+                                      pPSTNCheck->vdiff1_avg*1000L)/pPSTNCheck->iloop1_avg);
+        pPSTNCheck->rl2 = abs_int32((
+                                      pPSTNCheck->vdiff2_avg*1000L)/pPSTNCheck->iloop2_avg);
+
+        /* Force non-zero loop resistance */
+        if(pPSTNCheck->rl1 == 0)
+        {
+          pPSTNCheck->rl1 = 1;
+        }
+        if(pPSTNCheck->rl2 == 0)
+        {
+          pPSTNCheck->rl2 = 1;
+        }
+
+        /* Qualify loop impedances */
+        pPSTNCheck->rl_ratio = (pPSTNCheck->rl1*1000L)/pPSTNCheck->rl2;
+#ifdef ENABLE_DEBUG
+        if (pProslic->debugMode)
+        {
+          const char func_string[] = "DiffPSTN: ";
+          LOGPRINT("%s%sVDIFF1 = %d mV\n", LOGPRINT_PREFIX, func_string,
+                   pPSTNCheck->vdiff1_avg);
+          LOGPRINT("%s%sILOOP1 = %d uA\n", LOGPRINT_PREFIX, func_string,
+                   pPSTNCheck->iloop1_avg);
+          LOGPRINT("%s%sVDIFF2 = %d mV\n", LOGPRINT_PREFIX, func_string,
+                   pPSTNCheck->vdiff2_avg);
+          LOGPRINT("%s%sILOOP2 = %d uA\n", LOGPRINT_PREFIX, func_string,
+                   pPSTNCheck->iloop2_avg);
+          LOGPRINT("%s%sRL1 = %d ohm\n", LOGPRINT_PREFIX, func_string,
+                   pPSTNCheck->rl1);
+          LOGPRINT("%s%sRL2 = %d ohm\n", LOGPRINT_PREFIX, func_string,
+                   pPSTNCheck->rl2);
+          LOGPRINT("%s%sRL_Ratio = %d \n", LOGPRINT_PREFIX, func_string,
+                   pPSTNCheck->rl_ratio);
+        }
+#endif
+
+        /* Restore */
+        pPSTNCheck->pState.sampleIterations = 0;
+        pPSTNCheck->pState.stage = 70;
+      }
+      return RC_NONE;
+
+    case 70:  /* Reset test state, restore entry conditions */
+      ProSLIC_DCFeedSetup(pProslic,pPSTNCheck->entryDCFeedPreset);
+      ProSLIC_SetLinefeedStatus(pProslic,pPSTNCheck->lfstate_entry);
+      if(pProslic->deviceId->chipRev != 0)
+      {
+        WriteReg(pProHW,pProslic->channel,ENHANCE, pPSTNCheck->enhanceRegSave);
+      }
+      pPSTNCheck->pState.stage = 0;
+      pPSTNCheck->pState.waitIterations = 0;
+      pPSTNCheck->pState.sampleIterations = 0;
+      return pPSTNCheck->return_status;
+
+  }
+  return RC_NONE;
+}
+
+#endif
+
Index: linux-5.4.171/sound/soc/codecs/si3218x/src/si3228x_LCCB_constants.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-5.4.171/sound/soc/codecs/si3218x/src/si3228x_LCCB_constants.c	2022-02-22 10:59:29.000000000 +0800
@@ -0,0 +1,723 @@
+/*
+** Copyright (c) 2017 Silicon Laboratories, Inc.
+** 2017-09-14 19:29:30
+**
+** Si3228x ProSLIC API Configuration Tool Version 4.2.0
+** Last Updated in API Release: 9.1.0
+** source XML file: si3228x_LCCB_constants.xml
+**
+** Auto generated file from configuration tool.
+*/
+
+
+#include "../inc/proslic.h"
+#include "../inc/si3228x.h"
+
+Si3228x_General_Cfg Si3228x_General_Configuration  = {
+0x78,     /* DEVICE_KEY */
+BO_DCDC_LCCB,    /* BOM_OPT */
+BO_DCDC_TRACKING,    /* BAT_RAIL_TYPE */
+0x000AD000L,    /* bat_hyst */
+0x06666635L,    /* VBATR_EXPECT (100.00) */
+0x03D70A20L,    /* VBATH_EXPECT (60.00) */
+0x0FFF0000L,    /* PWRSAVE_TIMER */
+0x01999A00L,    /* OFFHOOK_THRESH */
+0x00F00000L,    /* VBAT_TRACK_MIN */
+0x00F00000L,    /* VBAT_TRACK_MIN_RNG */
+0x00014000L,    /* PWRSAVE_DBI */
+0x0ADD5500L,    /* DCDC_ANA_SCALE */
+0x00312700L,    /* VOV_BAT_PWRSAVE_MIN */
+0x00395800L,    /* VOV_BAT_PWRSAVE_MIN_RNG */
+0x00800000L,    /* THERM_DBI */
+0x00004000L,    /* CPUMP_DBI */
+0x00F18900L,    /* DCDC_VERR */
+0x00809D80L,    /* DCDC_VERR_HYST */
+0x00000000L,    /* DCDC_OITHRESH_LO */
+0x01A00000L,    /* DCDC_OITHRESH_HI */
+0x00400000L,    /* PD_UVLO */
+0x00400000L,    /* PD_OVLO */
+0x00200000L,    /* PD_OCLO */
+0x00400000L,    /* PD_SWDRV */
+0x00500000L,    /* DCDC_UVHYST */
+0x00000000L,    /* DCDC_UVTHRESH */
+0x00A00000L,    /* DCDC_OVTHRESH */
+0x00800000L,    /* DCDC_OITHRESH */
+0x00000000L,    /* DCDC_SWDRV_POL */
+0x00000000L,    /* DCDC_UVPOL */
+0x00000000L,    /* DCDC_VREF_MAN */
+0x00000000L,    /* DCDC_VREF_CTRL */
+0x00200000L,    /* DCDC_RNGTYPE */
+0x05B00000L,    /* DCDC_ANA_VREF */
+0x00300000L,    /* DCDC_ANA_GAIN */
+0x00180000L,    /* DCDC_ANA_TOFF */
+0x00100000L,    /* DCDC_ANA_TONMIN */
+0x012FC000L,    /* DCDC_ANA_TONMAX */
+0x00F00000L,    /* DCDC_ANA_DSHIFT */
+0x0FDA4000L,    /* DCDC_ANA_LPOLY */
+0x00000000L,    /* DCDC_AUX_INVERT */
+0x00400000L,    /* DCDC_CPUMP_LP */
+0x00000000L,    /* DCDC_CPUMP_PULLDOWN */
+0x00000000L,    /* DCDC_LIFT_EN */
+0x07FEB800L,    /* COEF_P_HVIC */
+0x005B05B2L,    /* P_TH_HVIC */
+VDC_4P5_16P0,    /* VDC_RANGE_OPT */
+0x3F,     /* AUTO */
+0x50,     /* IRQEN1 */
+0x13,     /* IRQEN2 */
+0x07,     /* IRQEN3 */
+0x00,     /* IRQEN4 */
+0x10,     /* ENHANCE */
+0x03A2E8BAL,    /* SCALE_KAUDIO */
+0x04,    /* ZCAL_EN */
+0x03000000L,    /* LKG_OFHK_OFFSET */
+0x05000000L,    /* LKG_LB_OFFSET */
+0x01000000L,    /* VBATH_DELTA */
+0x03700000L,    /* UVTHRESH_MAX */
+0x04B80200L,    /* UVTHRESH_SCALE */
+0x00823000L     /* UVTHRESH_BIAS */
+};
+
+Si3228x_audioGain_Cfg Si3228x_audioGain_Presets [] = {
+{0x1377080L,0, 0x0L, 0x0L, 0x0L, 0x0L},
+{0x80C3180L,0, 0x0L, 0x0L, 0x0L, 0x0L}
+};
+
+Si3228x_Ring_Cfg Si3228x_Ring_Presets[] ={
+{
+/*
+    Loop = 500.0 ft @ 0.044 ohms/ft, REN = 2, Rcpe = 600 ohms
+    Rprot = 54 ohms, Type = LPR, Waveform = SINE
+*/ 
+0x00050000L,    /* RTPER */
+0x07EFE000L,    /* RINGFR (20.000 Hz) */
+0x0019F559L,    /* RINGAMP (45.000 vrms)  */
+0x00000000L,    /* RINGPHAS */
+0x00000000L,    /* RINGOF (0.000 vdc) */
+0x15E5200EL,    /* SLOPE_RING (100.000 ohms) */
+0x006C94D6L,    /* IRING_LIM (70.000 mA) */
+0x0030C067L,    /* RTACTH (26.922 mA) */
+0x0FFFFFFFL,    /* RTDCTH (450.000 mA) */
+0x00006000L,    /* RTACDB (75.000 ms) */
+0x00006000L,    /* RTDCDB (75.000 ms) */
+0x0051EB82L,    /* VOV_RING_BAT (5.000 v) */
+0x00000000L,    /* VOV_RING_GND (0.000 v) */
+0x049F66B5L,    /* VBATR_EXPECT (72.229 v) */
+0x80,            /* RINGTALO (2.000 s) */
+0x3E,            /* RINGTAHI */
+0x00,            /* RINGTILO (4.000 s) */
+0x7D,            /* RINGTIHI */
+0x00000000L,    /* ADAP_RING_MIN_I */
+0x00003000L,    /* COUNTER_IRING_VAL */
+0x00051EB8L,    /* COUNTER_VTR_VAL */
+0x00000000L,    /* CONST_028 */
+0x00000000L,    /* CONST_032 */
+0x00000000L,    /* CONST_038 */
+0x00000000L,    /* CONST_046 */
+0x00000000L,    /* RRD_DELAY */
+0x00000000L,    /* RRD_DELAY2 */
+0x01893740L,    /* VBAT_TRACK_MIN_RNG */
+0x98,            /* RINGCON */
+0x00,            /* USERSTAT */
+0x024FB35AL,    /* VCM_RING (34.865 v) */
+0x024FB35AL,    /* VCM_RING_FIXED */
+0x003126E8L,    /* DELTA_VCM */
+0x00200000L,    /* DCDC_RNGTYPE */
+0x00FFFFFFL,    /* VOV_DCDC_SLOPE */
+0x00A18937L,    /* VOV_DCDC_OS */
+0x00E49BA5L,    /* VOV_RING_BAT_MAX */
+0x00000000L,    /* SMART_RING_PERIOD */
+0x00000000L,    /* SMART_RING_PHASE */
+},  /* RING_MAX_VBAT_PROVISIONING */
+{
+/*
+    Loop = 500.0 ft @ 0.044 ohms/ft, REN = 2, Rcpe = 600 ohms
+    Rprot = 54 ohms, Type = LPR, Waveform = SINE
+*/ 
+0x00050000L,    /* RTPER */
+0x07EFE000L,    /* RINGFR (20.000 Hz) */
+0x0019F559L,    /* RINGAMP (45.000 vrms)  */
+0x00000000L,    /* RINGPHAS */
+0x00000000L,    /* RINGOF (0.000 vdc) */
+0x15E5200EL,    /* SLOPE_RING (100.000 ohms) */
+0x006C94D6L,    /* IRING_LIM (70.000 mA) */
+0x0030C067L,    /* RTACTH (26.922 mA) */
+0x0FFFFFFFL,    /* RTDCTH (450.000 mA) */
+0x00006000L,    /* RTACDB (75.000 ms) */
+0x00006000L,    /* RTDCDB (75.000 ms) */
+0x0051EB82L,    /* VOV_RING_BAT (5.000 v) */
+0x00000000L,    /* VOV_RING_GND (0.000 v) */
+0x049F66B5L,    /* VBATR_EXPECT (72.229 v) */
+0x80,            /* RINGTALO (2.000 s) */
+0x3E,            /* RINGTAHI */
+0x00,            /* RINGTILO (4.000 s) */
+0x7D,            /* RINGTIHI */
+0x00000000L,    /* ADAP_RING_MIN_I */
+0x00003000L,    /* COUNTER_IRING_VAL */
+0x00051EB8L,    /* COUNTER_VTR_VAL */
+0x00000000L,    /* CONST_028 */
+0x00000000L,    /* CONST_032 */
+0x00000000L,    /* CONST_038 */
+0x00000000L,    /* CONST_046 */
+0x00000000L,    /* RRD_DELAY */
+0x00000000L,    /* RRD_DELAY2 */
+0x01893740L,    /* VBAT_TRACK_MIN_RNG */
+0x98,            /* RINGCON */
+0x00,            /* USERSTAT */
+0x024FB35AL,    /* VCM_RING (34.865 v) */
+0x024FB35AL,    /* VCM_RING_FIXED */
+0x003126E8L,    /* DELTA_VCM */
+0x00200000L,    /* DCDC_RNGTYPE */
+0x00FFFFFFL,    /* VOV_DCDC_SLOPE */
+0x00A18937L,    /* VOV_DCDC_OS */
+0x00E49BA5L,    /* VOV_RING_BAT_MAX */
+0x00000000L,    /* SMART_RING_PERIOD */
+0x00000000L,    /* SMART_RING_PHASE */
+}   /* RING_F20_45VRMS_0VDC_LPR */
+};
+
+Si3228x_DCfeed_Cfg Si3228x_DCfeed_Presets[] = {
+{
+0x1C8A024CL,    /* SLOPE_VLIM */
+0x1F909679L,    /* SLOPE_RFEED */
+0x0040A0E0L,    /* SLOPE_ILIM */
+0x1D5B21A9L,    /* SLOPE_DELTA1 */
+0x1DD87A3EL,    /* SLOPE_DELTA2 */
+0x05A38633L,    /* V_VLIM (48.000 v) */
+0x050D2839L,    /* V_RFEED (43.000 v) */
+0x03FE7F0FL,    /* V_ILIM  (34.000 v) */
+0x00B4F3C3L,    /* CONST_RFEED (15.000 mA) */
+0x005D0FA6L,    /* CONST_ILIM (20.000 mA) */
+0x002D8D96L,    /* I_VLIM (0.000 mA) */
+0x005B0AFBL,    /* LCRONHK (10.000 mA) */
+0x006D4060L,    /* LCROFFHK (12.000 mA) */
+0x00008000L,    /* LCRDBI (5.000 ms) */
+0x0048D595L,    /* LONGHITH (8.000 mA) */
+0x003FBAE2L,    /* LONGLOTH (7.000 mA) */
+0x00008000L,    /* LONGDBI (5.000 ms) */
+0x000F0000L,    /* LCRMASK (150.000 ms) */
+0x00080000L,    /* LCRMASK_POLREV (80.000 ms) */
+0x00140000L,    /* LCRMASK_STATE (200.000 ms) */
+0x00140000L,    /* LCRMASK_LINECAP (200.000 ms) */
+0x01BA5E35L,    /* VCM_OH (27.000 v) */
+0x0051EB85L,    /* VOV_BAT (5.000 v) */
+0x00415F45L,    /* VOV_GND (3.990 v) */
+},  /* DCFEED_48V_20MA */
+{
+0x1C8A024CL,    /* SLOPE_VLIM */
+0x1EE08C11L,    /* SLOPE_RFEED */
+0x0040A0E0L,    /* SLOPE_ILIM */
+0x1C940D71L,    /* SLOPE_DELTA1 */
+0x1DD87A3EL,    /* SLOPE_DELTA2 */
+0x05A38633L,    /* V_VLIM (48.000 v) */
+0x050D2839L,    /* V_RFEED (43.000 v) */
+0x03FE7F0FL,    /* V_ILIM  (34.000 v) */
+0x01241BC9L,    /* CONST_RFEED (15.000 mA) */
+0x0074538FL,    /* CONST_ILIM (25.000 mA) */
+0x002D8D96L,    /* I_VLIM (0.000 mA) */
+0x005B0AFBL,    /* LCRONHK (10.000 mA) */
+0x006D4060L,    /* LCROFFHK (12.000 mA) */
+0x00008000L,    /* LCRDBI (5.000 ms) */
+0x0048D595L,    /* LONGHITH (8.000 mA) */
+0x003FBAE2L,    /* LONGLOTH (7.000 mA) */
+0x00008000L,    /* LONGDBI (5.000 ms) */
+0x000F0000L,    /* LCRMASK (150.000 ms) */
+0x00080000L,    /* LCRMASK_POLREV (80.000 ms) */
+0x00140000L,    /* LCRMASK_STATE (200.000 ms) */
+0x00140000L,    /* LCRMASK_LINECAP (200.000 ms) */
+0x01BA5E35L,    /* VCM_OH (27.000 v) */
+0x0051EB85L,    /* VOV_BAT (5.000 v) */
+0x00415F45L,    /* VOV_GND (3.990 v) */
+},  /* DCFEED_48V_25MA */
+{
+0x1E655196L,    /* SLOPE_VLIM */
+0x001904EFL,    /* SLOPE_RFEED */
+0x0040A0E0L,    /* SLOPE_ILIM */
+0x1B4CAD9EL,    /* SLOPE_DELTA1 */
+0x1BB0F47CL,    /* SLOPE_DELTA2 */
+0x05A38633L,    /* V_VLIM (48.000 v) */
+0x043AA4A6L,    /* V_RFEED (36.000 v) */
+0x025977EAL,    /* V_ILIM  (20.000 v) */
+0x0068B19AL,    /* CONST_RFEED (18.000 mA) */
+0x005D0FA6L,    /* CONST_ILIM (20.000 mA) */
+0x002D8D96L,    /* I_VLIM (0.000 mA) */
+0x005B0AFBL,    /* LCRONHK (10.000 mA) */
+0x006D4060L,    /* LCROFFHK (12.000 mA) */
+0x00008000L,    /* LCRDBI (5.000 ms) */
+0x0048D595L,    /* LONGHITH (8.000 mA) */
+0x003FBAE2L,    /* LONGLOTH (7.000 mA) */
+0x00008000L,    /* LONGDBI (5.000 ms) */
+0x000F0000L,    /* LCRMASK (150.000 ms) */
+0x00080000L,    /* LCRMASK_POLREV (80.000 ms) */
+0x00140000L,    /* LCRMASK_STATE (200.000 ms) */
+0x00140000L,    /* LCRMASK_LINECAP (200.000 ms) */
+0x01BA5E35L,    /* VCM_OH (27.000 v) */
+0x0051EB85L,    /* VOV_BAT (5.000 v) */
+0x00415F45L,    /* VOV_GND (3.990 v) */
+},  /* DCFEED_PSTN_DET_1 */
+{
+0x1A10433FL,    /* SLOPE_VLIM */
+0x1C206275L,    /* SLOPE_RFEED */
+0x0040A0E0L,    /* SLOPE_ILIM */
+0x1C1F426FL,    /* SLOPE_DELTA1 */
+0x1EB51625L,    /* SLOPE_DELTA2 */
+0x041C91DBL,    /* V_VLIM (35.000 v) */
+0x03E06C43L,    /* V_RFEED (33.000 v) */
+0x038633E0L,    /* V_ILIM  (30.000 v) */
+0x022E5DE5L,    /* CONST_RFEED (10.000 mA) */
+0x005D0FA6L,    /* CONST_ILIM (20.000 mA) */
+0x0021373DL,    /* I_VLIM (0.000 mA) */
+0x005B0AFBL,    /* LCRONHK (10.000 mA) */
+0x006D4060L,    /* LCROFFHK (12.000 mA) */
+0x00008000L,    /* LCRDBI (5.000 ms) */
+0x0048D595L,    /* LONGHITH (8.000 mA) */
+0x003FBAE2L,    /* LONGLOTH (7.000 mA) */
+0x00008000L,    /* LONGDBI (5.000 ms) */
+0x000F0000L,    /* LCRMASK (150.000 ms) */
+0x00080000L,    /* LCRMASK_POLREV (80.000 ms) */
+0x00140000L,    /* LCRMASK_STATE (200.000 ms) */
+0x00140000L,    /* LCRMASK_LINECAP (200.000 ms) */
+0x01BA5E35L,    /* VCM_OH (27.000 v) */
+0x0051EB85L,    /* VOV_BAT (5.000 v) */
+0x00415F45L,    /* VOV_GND (3.990 v) */
+}   /* DCFEED_PSTN_DET_2 */
+};
+
+Si3228x_Impedance_Cfg Si3228x_Impedance_Presets[] ={
+/* Source: Database file: cwdb.db */
+/* Database information: */
+/* parameters: zref=600_0_0 rprot=30 rfuse=24 emi_cap=10*/
+{
+{0x07F3A400L, 0x000FF180L, 0x00009380L, 0x1FFDA800L,    /* TXACEQ */
+ 0x07EF1600L, 0x0014B500L, 0x1FFD6580L, 0x1FFCA400L},   /* RXACEQ */
+{0x0008EF00L, 0x00099780L, 0x017DF600L, 0x0096B900L,    /* ECFIR/ECIIR */
+ 0x02549000L, 0x1E4B7D00L, 0x018EEE00L, 0x1EEE0600L,
+ 0x008A8080L, 0x1F713080L, 0x0489BA00L, 0x03592500L},
+{0x0086CE00L, 0x1EF46980L, 0x0084CB00L, 0x0FE34F00L,    /* ZSYNTH */
+ 0x181CA780L, 0x5D}, 
+ 0x08EB8E00L,   /* TXACGAIN */
+ 0x01532100L,   /* RXACGAIN */
+ 0x07AA7180L, 0x18558F00L, 0x0754E300L,    /* RXACHPF */
+#ifdef ENABLE_HIRES_GAIN
+ 0, 0  /* TXGAIN*10, RXGAIN*10 (hi_res) */
+#else
+ 0, 0  /* TXGAIN, RXGAIN */
+#endif
+ },  /* ZSYN_600_0_0_30_0 */
+/* Source: Database file: cwdb.db */
+/* Database information: */
+/* parameters: zref=270_750_150 rprot=30 rfuse=24 emi_cap=10*/
+{
+{0x0750E500L, 0x1FC70280L, 0x000BA980L, 0x1FFD2880L,    /* TXACEQ */
+ 0x0A8E2380L, 0x1B905280L, 0x00847700L, 0x1FDAFA00L},   /* RXACEQ */
+{0x002C8880L, 0x1F630D80L, 0x027F7980L, 0x1F3AD200L,    /* ECFIR/ECIIR */
+ 0x040B8680L, 0x1F414D00L, 0x01427B00L, 0x00208200L,
+ 0x0026AE00L, 0x1FD71680L, 0x0C8EDB00L, 0x1B688A00L},
+{0x1F657980L, 0x0096FE00L, 0x00035500L, 0x0D7FE800L,    /* ZSYNTH */
+ 0x1A7F1A80L, 0xB4}, 
+ 0x08000000L,   /* TXACGAIN */
+ 0x01106B80L,   /* RXACGAIN */
+ 0x07BC8400L, 0x18437C80L, 0x07790880L,    /* RXACHPF */
+#ifdef ENABLE_HIRES_GAIN
+ 0, 0  /* TXGAIN*10, RXGAIN*10 (hi_res) */
+#else
+ 0, 0  /* TXGAIN, RXGAIN */
+#endif
+ },  /* ZSYN_270_750_150_30_0 */
+/* Source: Database file: cwdb.db */
+/* Database information: */
+/* parameters: zref=370_620_310 rprot=30 rfuse=24 emi_cap=10*/
+{
+{0x08363C80L, 0x1FB03200L, 0x1FFBD200L, 0x1FFC7A00L,    /* TXACEQ */
+ 0x0A0D0800L, 0x1BEB0880L, 0x1F9DF080L, 0x1FE07F00L},   /* RXACEQ */
+{0x00236380L, 0x1F947D00L, 0x020DE380L, 0x1FBEED00L,    /* ECFIR/ECIIR */
+ 0x03050300L, 0x1F7D1D00L, 0x010A9F80L, 0x00329D80L,
+ 0x003E4100L, 0x1FC0DF00L, 0x0DAADE80L, 0x1A4F2600L},
+{0x00226100L, 0x1F8EEE80L, 0x004E9D00L, 0x0F0B9B00L,    /* ZSYNTH */
+ 0x18F3E580L, 0x99}, 
+ 0x0808D100L,   /* TXACGAIN */
+ 0x0131BE80L,   /* RXACGAIN */
+ 0x07B5C100L, 0x184A3F80L, 0x076B8200L,    /* RXACHPF */
+#ifdef ENABLE_HIRES_GAIN
+ 0, 0  /* TXGAIN*10, RXGAIN*10 (hi_res) */
+#else
+ 0, 0  /* TXGAIN, RXGAIN */
+#endif
+ },  /* ZSYN_370_620_310_30_0 */
+/* Source: Database file: cwdb.db */
+/* Database information: */
+/* parameters: zref=220_820_120 rprot=30 rfuse=24 emi_cap=10*/
+{
+{0x07194B80L, 0x1FC63800L, 0x0008D280L, 0x1FFC0600L,    /* TXACEQ */
+ 0x0A849680L, 0x1BB04480L, 0x00A4AA00L, 0x1FD3E680L},   /* RXACEQ */
+{0x001B8C00L, 0x1FC65400L, 0x016A5F00L, 0x01323C80L,    /* ECFIR/ECIIR */
+ 0x01DB4980L, 0x01484700L, 0x00258000L, 0x007E9C80L,
+ 0x0016FF00L, 0x1FE69100L, 0x0CE9A400L, 0x1B0EA980L},
+{0x00B3D800L, 0x1D2F8280L, 0x021C8B00L, 0x0A157F00L,    /* ZSYNTH */
+ 0x1DE99E80L, 0xAD}, 
+ 0x08000000L,   /* TXACGAIN */
+ 0x01084680L,   /* RXACGAIN */
+ 0x07BBFA80L, 0x18440600L, 0x0777F580L,    /* RXACHPF */
+#ifdef ENABLE_HIRES_GAIN
+ 0, 0  /* TXGAIN*10, RXGAIN*10 (hi_res) */
+#else
+ 0, 0  /* TXGAIN, RXGAIN */
+#endif
+ },  /* ZSYN_220_820_120_30_0 */
+/* Source: Database file: cwdb.db */
+/* Database information: */
+/* parameters: zref=600_0_0 rprot=30 rfuse=24 emi_cap=10*/
+{
+{0x07F3A400L, 0x000FF180L, 0x00009380L, 0x1FFDA800L,    /* TXACEQ */
+ 0x07EF1600L, 0x0014B500L, 0x1FFD6580L, 0x1FFCA400L},   /* RXACEQ */
+{0x0008EF00L, 0x00099780L, 0x017DF600L, 0x0096B900L,    /* ECFIR/ECIIR */
+ 0x02549000L, 0x1E4B7D00L, 0x018EEE00L, 0x1EEE0600L,
+ 0x008A8080L, 0x1F713080L, 0x0489BA00L, 0x03592500L},
+{0x0086CE00L, 0x1EF46980L, 0x0084CB00L, 0x0FE34F00L,    /* ZSYNTH */
+ 0x181CA780L, 0x5D}, 
+ 0x08EB8E00L,   /* TXACGAIN */
+ 0x01532100L,   /* RXACGAIN */
+ 0x07AA7180L, 0x18558F00L, 0x0754E300L,    /* RXACHPF */
+#ifdef ENABLE_HIRES_GAIN
+ 0, 0  /* TXGAIN*10, RXGAIN*10 (hi_res) */
+#else
+ 0, 0  /* TXGAIN, RXGAIN */
+#endif
+ },  /* ZSYN_600_0_1000_30_0 */
+/* Source: Database file: cwdb.db */
+/* Database information: */
+/* parameters: zref=200_680_100 rprot=30 rfuse=24 emi_cap=10*/
+{
+{0x0778B980L, 0x1FB97E00L, 0x00030780L, 0x1FFC2580L,    /* TXACEQ */
+ 0x09CC0780L, 0x1D104400L, 0x0076CB80L, 0x1FDE3D80L},   /* RXACEQ */
+{0x1FF64C00L, 0x00456280L, 0x00BEC500L, 0x014D3E80L,    /* ECFIR/ECIIR */
+ 0x02EB2B00L, 0x1E983B80L, 0x029EE280L, 0x1E7B7400L,
+ 0x00D19A80L, 0x1F293D80L, 0x06116D00L, 0x01D55C00L},
+{0x01241700L, 0x1CB53A80L, 0x02269400L, 0x0A14BA00L,    /* ZSYNTH */
+ 0x1DE9D080L, 0x99}, 
+ 0x08000000L,   /* TXACGAIN */
+ 0x01152480L,   /* RXACGAIN */
+ 0x07B96C00L, 0x18469480L, 0x0772D800L,    /* RXACHPF */
+#ifdef ENABLE_HIRES_GAIN
+ 0, 0  /* TXGAIN*10, RXGAIN*10 (hi_res) */
+#else
+ 0, 0  /* TXGAIN, RXGAIN */
+#endif
+ },  /* ZSYN_200_680_100_30_0 */
+/* Source: Database file: cwdb.db */
+/* Database information: */
+/* parameters: zref=220_820_115 rprot=30 rfuse=24 emi_cap=10*/
+{
+{0x070AC700L, 0x1FCC7280L, 0x00098700L, 0x1FFCE080L,    /* TXACEQ */
+ 0x0A6A6400L, 0x1BE48B80L, 0x009F3B80L, 0x1FD56000L},   /* RXACEQ */
+{0x00314700L, 0x1F6C1D80L, 0x02347480L, 0x00158B80L,    /* ECFIR/ECIIR */
+ 0x03173D00L, 0x0058E580L, 0x00A6DA80L, 0x004B0780L,
+ 0x001B1300L, 0x1FE2DE80L, 0x0C313180L, 0x1BB7FE00L},
+{0x1FD95980L, 0x1ECDE680L, 0x0156F600L, 0x0A0C9600L,    /* ZSYNTH */
+ 0x1DEBF080L, 0xB4}, 
+ 0x08000000L,   /* TXACGAIN */
+ 0x01069C80L,   /* RXACGAIN */
+ 0x07BECB80L, 0x18413500L, 0x077D9700L,    /* RXACHPF */
+#ifdef ENABLE_HIRES_GAIN
+ 0, 0  /* TXGAIN*10, RXGAIN*10 (hi_res) */
+#else
+ 0, 0  /* TXGAIN, RXGAIN */
+#endif
+ },  /* ZSYN_220_820_115_30_0 */
+/* Source: Database file: cwdb.db */
+/* Database information: */
+/* parameters: zref=600_0_0 rprot=30 rfuse=24 emi_cap=0*/
+{
+{0x081A5300L, 0x1FE00A00L, 0x00071580L, 0x1FFE2600L,    /* TXACEQ */
+ 0x07F9A800L, 0x1FFA7D80L, 0x1FF59E80L, 0x1FFF1400L},   /* RXACEQ */
+{0x0052DC80L, 0x1F455780L, 0x0297A080L, 0x0006D980L,    /* ECFIR/ECIIR */
+ 0x0195DC00L, 0x000E1E80L, 0x1FC53680L, 0x00050800L,
+ 0x00233400L, 0x1FE6DC00L, 0x1FCD1E00L, 0x1FD2FE00L},
+{0x007B9C00L, 0x1F296C80L, 0x005BCD00L, 0x09F07F00L,    /* ZSYNTH */
+ 0x1DF35080L, 0x6F}, 
+ 0x08C2DA80L,   /* TXACGAIN */
+ 0x01495A80L,   /* RXACGAIN */
+ 0x07BECC80L, 0x18413400L, 0x077D9900L,    /* RXACHPF */
+#ifdef ENABLE_HIRES_GAIN
+ 0, 0  /* TXGAIN*10, RXGAIN*10 (hi_res) */
+#else
+ 0, 0  /* TXGAIN, RXGAIN */
+#endif
+ }   /* WB_ZSYN_600_0_0_20_0 */
+};
+
+Si3228x_FSK_Cfg Si3228x_FSK_Presets[] ={
+{
+{
+0x02232000L,     /* FSK01 */
+0x077C2000L      /* FSK10 */
+},
+{
+0x0015C000L,     /* FSKAMP0 (0.080 vrms )*/
+0x000BA000L      /* FSKAMP1 (0.080 vrms) */
+},
+{
+0x06B60000L,     /* FSKFREQ0 (2200.0 Hz space) */
+0x079C0000L      /* FSKFREQ1 (1200.0 Hz mark) */
+},
+0x00,             /* FSK8 */
+0x00,             /* FSKDEPTH (1 deep fifo) */
+},  /* DEFAULT_FSK */
+{
+{
+0x026E4000L,     /* FSK01 */
+0x0694C000L      /* FSK10 */
+},
+{
+0x0014C000L,     /* FSKAMP0 (0.080 vrms )*/
+0x000CA000L      /* FSKAMP1 (0.080 vrms) */
+},
+{
+0x06D20000L,     /* FSKFREQ0 (2100.0 Hz space) */
+0x078B0000L      /* FSKFREQ1 (1300.0 Hz mark) */
+},
+0x00,             /* FSK8 */
+0x00,             /* FSKDEPTH (1 deep fifo) */
+}   /* ETSI_FSK */
+};
+
+Si3228x_PulseMeter_Cfg Si3228x_PulseMeter_Presets[] ={
+{
+0x007A2B6AL,  /* PM_AMP_THRESH (1.000) */
+0,            /* Freq (12kHz) */ 
+0,            /* PM_AUTO (off)*/
+0x07D00000L,  /* PM_active (2000 ms) */
+0x07D00000L   /* PM_inactive (2000 ms) */
+ }   /* DEFAULT_PULSE_METERING */
+};
+
+Si3228x_Tone_Cfg Si3228x_Tone_Presets[] = {
+{
+    {
+    0x07B30000L,     /* OSC1FREQ (350.000 Hz) */
+    0x000C6000L,     /* OSC1AMP (-18.000 dBm) */
+    0x00000000L,     /* OSC1PHAS (0.000 rad) */
+    0x00,             /* O1TALO (0 ms) */
+    0x00,             /* O1TAHI */
+    0x00,             /* O1TILO (0 ms) */
+    0x00             /* O1TIHI */
+    },
+    {
+    0x07870000L,     /* OSC2FREQ (440.000 Hz) */
+    0x000FA000L,     /* OSC2AMP (-18.000 dBm) */
+    0x00000000L,     /* OSC2PHAS (0.000 rad) */
+    0x00,             /* O2TALO (0 ms) */
+    0x00,             /* O2TAHI */
+    0x00,             /* O2TILO (0 ms) */
+    0x00              /* O2TIHI */
+    },
+    0x66              /* OMODE */
+},  /* TONEGEN_FCC_DIAL */
+{
+    {
+    0x07700000L,     /* OSC1FREQ (480.000 Hz) */
+    0x00112000L,     /* OSC1AMP (-18.000 dBm) */
+    0x00000000L,     /* OSC1PHAS (0.000 rad) */
+    0xA0,             /* O1TALO (500 ms) */
+    0x0F,             /* O1TAHI */
+    0xA0,             /* O1TILO (500 ms) */
+    0x0F             /* O1TIHI */
+    },
+    {
+    0x07120000L,     /* OSC2FREQ (620.000 Hz) */
+    0x00164000L,     /* OSC2AMP (-18.000 dBm) */
+    0x00000000L,     /* OSC2PHAS (0.000 rad) */
+    0xA0,             /* O2TALO (500 ms) */
+    0x0F,             /* O2TAHI */
+    0xA0,             /* O2TILO (500 ms) */
+    0x0F              /* O2TIHI */
+    },
+    0x66              /* OMODE */
+},  /* TONEGEN_FCC_BUSY */
+{
+    {
+    0x07700000L,     /* OSC1FREQ (480.000 Hz) */
+    0x00112000L,     /* OSC1AMP (-18.000 dBm) */
+    0x00000000L,     /* OSC1PHAS (0.000 rad) */
+    0x80,             /* O1TALO (2000 ms) */
+    0x3E,             /* O1TAHI */
+    0x00,             /* O1TILO (4000 ms) */
+    0x7D             /* O1TIHI */
+    },
+    {
+    0x07870000L,     /* OSC2FREQ (440.000 Hz) */
+    0x000FA000L,     /* OSC2AMP (-18.000 dBm) */
+    0x00000000L,     /* OSC2PHAS (0.000 rad) */
+    0x80,             /* O2TALO (2000 ms) */
+    0x3E,             /* O2TAHI */
+    0x00,             /* O2TILO (4000 ms) */
+    0x7D              /* O2TIHI */
+    },
+    0x66              /* OMODE */
+},  /* TONEGEN_FCC_RINGBACK */
+{
+    {
+    0x07700000L,     /* OSC1FREQ (480.000 Hz) */
+    0x00112000L,     /* OSC1AMP (-18.000 dBm) */
+    0x00000000L,     /* OSC1PHAS (0.000 rad) */
+    0x60,             /* O1TALO (300 ms) */
+    0x09,             /* O1TAHI */
+    0x60,             /* O1TILO (300 ms) */
+    0x09             /* O1TIHI */
+    },
+    {
+    0x07120000L,     /* OSC2FREQ (620.000 Hz) */
+    0x00164000L,     /* OSC2AMP (-18.000 dBm) */
+    0x00000000L,     /* OSC2PHAS (0.000 rad) */
+    0x60,             /* O2TALO (300 ms) */
+    0x09,             /* O2TAHI */
+    0x40,             /* O2TILO (200 ms) */
+    0x06              /* O2TIHI */
+    },
+    0x66              /* OMODE */
+},  /* TONEGEN_FCC_REORDER */
+{
+    {
+    0x07700000L,     /* OSC1FREQ (480.000 Hz) */
+    0x00112000L,     /* OSC1AMP (-18.000 dBm) */
+    0x00000000L,     /* OSC1PHAS (0.000 rad) */
+    0x40,             /* O1TALO (200 ms) */
+    0x06,             /* O1TAHI */
+    0x40,             /* O1TILO (200 ms) */
+    0x06             /* O1TIHI */
+    },
+    {
+    0x07120000L,     /* OSC2FREQ (620.000 Hz) */
+    0x00164000L,     /* OSC2AMP (-18.000 dBm) */
+    0x00000000L,     /* OSC2PHAS (0.000 rad) */
+    0x40,             /* O2TALO (200 ms) */
+    0x06,             /* O2TAHI */
+    0x40,             /* O2TILO (200 ms) */
+    0x06              /* O2TIHI */
+    },
+    0x66              /* OMODE */
+},  /* TONEGEN_FCC_CONGESTION */
+{
+    {
+    0x1F2F0000L,     /* OSC1FREQ (2130.000 Hz) */
+    0x0063A000L,     /* OSC1AMP (-18.000 dBm) */
+    0x00000000L,     /* OSC1PHAS (0.000 rad) */
+    0x80,             /* O1TALO (80 ms) */
+    0x02,             /* O1TAHI */
+    0x80,             /* O1TILO (80 ms) */
+    0x02             /* O1TIHI */
+    },
+    {
+    0x1B8E0000L,     /* OSC2FREQ (2750.000 Hz) */
+    0x00A84000L,     /* OSC2AMP (-18.000 dBm) */
+    0x00000000L,     /* OSC2PHAS (0.000 rad) */
+    0x80,             /* O2TALO (80 ms) */
+    0x02,             /* O2TAHI */
+    0x40,             /* O2TILO (1000 ms) */
+    0x1F              /* O2TIHI */
+    },
+    0x66              /* OMODE */
+},  /* TONEGEN_FCC_CAS */
+{
+    {
+    0x07870000L,     /* OSC1FREQ (440.000 Hz) */
+    0x000FA000L,     /* OSC1AMP (-18.000 dBm) */
+    0x00000000L,     /* OSC1PHAS (0.000 rad) */
+    0x60,             /* O1TALO (300 ms) */
+    0x09,             /* O1TAHI */
+    0x00,             /* O1TILO (8000 ms) */
+    0xFA             /* O1TIHI */
+    },
+    {
+    0x1B8E0000L,     /* OSC2FREQ (2750.000 Hz) */
+    0x00A84000L,     /* OSC2AMP (-18.000 dBm) */
+    0x00000000L,     /* OSC2PHAS (0.000 rad) */
+    0x80,             /* O2TALO (2000 ms) */
+    0x3E,             /* O2TAHI */
+    0x00,             /* O2TILO (4000 ms) */
+    0x7D              /* O2TIHI */
+    },
+    0x06              /* OMODE */
+},  /* TONEGEN_FCC_SAS */
+{
+    {
+    0x1F2F0000L,     /* OSC1FREQ (2130.000 Hz) */
+    0x01BD0000L,     /* OSC1AMP (-5.000 dBm) */
+    0x00000000L,     /* OSC1PHAS (0.000 rad) */
+    0x20,             /* O1TALO (100 ms) */
+    0x03,             /* O1TAHI */
+    0x20,             /* O1TILO (100 ms) */
+    0x03             /* O1TIHI */
+    },
+    {
+    0x1B8E0000L,     /* OSC2FREQ (2750.000 Hz) */
+    0x02EFC000L,     /* OSC2AMP (-5.000 dBm) */
+    0x00000000L,     /* OSC2PHAS (0.000 rad) */
+    0x20,             /* O2TALO (100 ms) */
+    0x03,             /* O2TAHI */
+    0x20,             /* O2TILO (100 ms) */
+    0x03              /* O2TIHI */
+    },
+    0x66              /* OMODE */
+},  /* TONEGEN_ETSI_DTAS */
+{
+    {
+    0x05A40000L,     /* OSC1FREQ (1004.000 Hz) */
+    0x005DE000L,     /* OSC1AMP (-10.000 dBm) */
+    0x00000000L,     /* OSC1PHAS (0.000 rad) */
+    0x00,             /* O1TALO (8000 ms) */
+    0xFA,             /* O1TAHI */
+    0x00,             /* O1TILO (8000 ms) */
+    0xFA             /* O1TIHI */
+    },
+    {
+    0x07870000L,     /* OSC2FREQ (440.000 Hz) */
+    0x000FA000L,     /* OSC2AMP (-18.000 dBm) */
+    0x00000000L,     /* OSC2PHAS (0.000 rad) */
+    0x80,             /* O2TALO (2000 ms) */
+    0x3E,             /* O2TAHI */
+    0x00,             /* O2TILO (4000 ms) */
+    0x7D              /* O2TIHI */
+    },
+    0x47              /* OMODE */
+}   /* TONEGEN_1004 */
+};
+
+Si3228x_PCM_Cfg Si3228x_PCM_Presets[] ={
+    {
+    0x01,      /* PCM_FMT - u-Law */
+    0x00,      /* WIDEBAND - DISABLED (3.4kHz BW) */
+    0x00,      /* PCM_TRI - PCLK RISING EDGE */
+    0x00,      /* TX_EDGE - PCLK RISING EDGE */
+    0x00      /* A-LAW -  INVERT NONE */
+    },  /* PCM_8ULAW */
+    {
+    0x00,      /* PCM_FMT - A-Law */
+    0x00,      /* WIDEBAND - DISABLED (3.4kHz BW) */
+    0x00,      /* PCM_TRI - PCLK RISING EDGE */
+    0x00,      /* TX_EDGE - PCLK RISING EDGE */
+    0x00      /* A-LAW -  INVERT NONE */
+    },  /* PCM_8ALAW */
+    {
+    0x03,      /* PCM_FMT - 16-bit Linear */
+    0x00,      /* WIDEBAND - DISABLED (3.4kHz BW) */
+    0x00,      /* PCM_TRI - PCLK RISING EDGE */
+    0x00,      /* TX_EDGE - PCLK RISING EDGE */
+    0x00      /* A-LAW -  INVERT NONE */
+    },  /* PCM_16LIN */
+    {
+    0x03,      /* PCM_FMT - 16-bit Linear */
+    0x01,      /* WIDEBAND - ENABLED (7kHz BW) */
+    0x00,      /* PCM_TRI - PCLK RISING EDGE */
+    0x00,      /* TX_EDGE - PCLK RISING EDGE */
+    0x00      /* A-LAW -  INVERT NONE */
+    },   /* PCM_16LIN_WB */
+    {
+    0x03,      /* PCM_FMT - 16-bit Linear */
+    0x00,      /* WIDEBAND - DISABLED (3.4kHz BW) */
+    0x01,      /* PCM_TRI - PCLK RISING EDGE */
+    0x01,      /* TX_EDGE - PCLK RISING EDGE */
+    0x00      /* A-LAW -  INVERT NONE */
+    }   /* PCM_16LIN */
+
+};
+
Index: linux-5.4.171/sound/soc/codecs/si3218x/src/si3228x_intf.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-5.4.171/sound/soc/codecs/si3218x/src/si3228x_intf.c	2022-02-22 10:59:29.000000000 +0800
@@ -0,0 +1,3143 @@
+/*
+** Copyright (c) 2015-2017 by Silicon Laboratories
+**
+** $Id: si3228x_intf.c 48623 2020-01-09 06:37:04Z ahuang $
+**
+** SI3228X ProSLIC interface implementation file
+**
+** Distributed by:
+** Silicon Laboratories, Inc
+**
+** This file contains proprietary information.
+** No dissemination allowed without prior written permission from
+** Silicon Laboratories, Inc.
+**
+** File Description:
+** This is the interface file for the Si3228x family of chips.
+**
+*/
+
+#include "../config_inc/si_voice_datatypes.h"
+#include "../inc/si_voice_ctrl.h"
+#include "../inc/si_voice_timer_intf.h"
+#include "../inc/proslic.h"
+#include "../inc/si3228x.h"
+#include "../inc/si3228x_intf.h"
+#include "../inc/si3228x_registers.h"
+#include "../config_inc/proslic_api_config.h"
+
+#define DEVICE_KEY_MIN              120 
+#define DEVICE_KEY_MAX              129
+#define SI3228X_REVA                3
+
+#define WriteReg        pProslic->deviceId->ctrlInterface->WriteRegister_fptr
+#define ReadReg         pProslic->deviceId->ctrlInterface->ReadRegister_fptr
+#define pProHW          pProslic->deviceId->ctrlInterface->hCtrl
+#define Reset           pProslic->deviceId->ctrlInterface->Reset_fptr
+#define Delay           pProslic->deviceId->ctrlInterface->Delay_fptr
+#define pProTimer       pProslic->deviceId->ctrlInterface->hTimer
+#define WriteRAM        pProslic->deviceId->ctrlInterface->WriteRAM_fptr
+#define ReadRAM         pProslic->deviceId->ctrlInterface->ReadRAM_fptr
+#define TimeElapsed     pProslic->deviceId->ctrlInterface->timeElapsed_fptr
+#define getTime         pProslic->deviceId->ctrlInterface->getTime_fptr
+#define SetSemaphore    pProslic->deviceId->ctrlInterface->Semaphore_fptr
+
+#define WriteRegX               deviceId->ctrlInterface->WriteRegister_fptr
+#define ReadRegX                deviceId->ctrlInterface->ReadRegister_fptr
+#define pProHWX                 deviceId->ctrlInterface->hCtrl
+#define DelayX                  deviceId->ctrlInterface->Delay_fptr
+#define pProTimerX              deviceId->ctrlInterface->hTimer
+#define WriteRAMX               deviceId->ctrlInterface->WriteRAM_fptr
+#define ReadRAMX                deviceId->ctrlInterface->ReadRAM_fptr
+#define getTimeX                deviceId->ctrlInterface->getTime_fptr
+#define TimeElapsedX            deviceId->ctrlInterface->timeElapsed_fptr
+
+#ifdef ENABLE_DEBUG
+static const char LOGPRINT_PREFIX[] = "Si3228x: ";
+#endif
+
+/*
+** Define patch parameters that can be modified by API
+*/
+#define SI3228X_PRAM_VBATH_NEON         799
+
+/*
+** Parameter Limits
+*/
+#define SI3228X_IRING_LIM_MAX 0xA00000L   /* ~103mA */
+
+/*
+** Externs
+*/
+
+/* General Configuration */
+extern Si3228x_General_Cfg Si3228x_General_Configuration;
+#ifdef SIVOICE_MULTI_BOM_SUPPORT
+extern const proslicPatch SI3228X_PATCH_A;
+extern Si3228x_General_Cfg Si3228x_General_Configuration_MultiBOM[];
+extern int si3228x_genconf_multi_max_preset;
+#else
+extern const proslicPatch SI3228X_PATCH_A_DEFAULT;
+#endif
+
+/* Ringing */
+#ifndef DISABLE_RING_SETUP
+extern Si3228x_Ring_Cfg Si3228x_Ring_Presets[];
+#endif
+
+/* Zsynth */
+#ifndef DISABLE_ZSYNTH_SETUP
+extern Si3228x_Impedance_Cfg Si3228x_Impedance_Presets [];
+#endif
+
+/* Audio Gain Scratch */
+extern Si3228x_audioGain_Cfg Si3228x_audioGain_Presets[];
+
+/* DC Feed */
+#ifndef DISABLE_DCFEED_SETUP
+extern Si3228x_DCfeed_Cfg Si3228x_DCfeed_Presets[];
+#endif
+
+/* Pulse Metering */
+#ifndef DISABLE_PULSE_SETUP
+extern Si3228x_PulseMeter_Cfg Si3228x_PulseMeter_Presets [];
+#endif
+
+/* PCM */
+#ifndef DISABLE_PCM_SETUP
+extern Si3228x_PCM_Cfg Si3228x_PCM_Presets [];
+#endif
+
+extern BOOLEAN ProSLIC_LoadPatch_extended(proslicChanType *pProslic,
+                                   const proslicPatch *pPatch, 
+                                   BOOLEAN is_broadcast, BOOLEAN is_second_chan);
+
+/*
+** Local functions are defined first
+*/
+
+int Si3228x_GetChipInfo(proslicChanType_ptr pProslic)
+{
+  const uInt8 partNums[16] =
+  {
+    SI32283, SI32282, SI32287, SI32286,
+    UNSUPPORTED_PART_NUM, UNSUPPORTED_PART_NUM, UNSUPPORTED_PART_NUM, UNSUPPORTED_PART_NUM,
+    SI32281, SI32280, SI32285, SI32284,
+    UNSUPPORTED_PART_NUM, UNSUPPORTED_PART_NUM, UNSUPPORTED_PART_NUM, UNSUPPORTED_PART_NUM
+  };
+  uInt8 id;
+
+  id = ReadReg(pProHW, pProslic->channel, PROSLIC_REG_ID);
+  pProslic->deviceId->chipRev = id & 0x7;
+  id &= 0x38;
+  id = id >> 3;
+  id += 8*(ReadReg(pProHW, pProslic->channel, PROSLIC_REG_ENHANCE)>>7);
+  pProslic->deviceId->chipType = partNums[id];
+
+  if(pProslic->deviceId->chipType  == UNSUPPORTED_PART_NUM)
+  {
+#ifdef ENABLE_DEBUG
+    LOGPRINT("%sregister 0 read = 0x%02X\n", LOGPRINT_PREFIX, id);
+#endif
+    return RC_SPI_FAIL;
+  }
+  else
+  {
+    return RC_NONE;
+  }
+}
+
+/*
+** Function: Si3228x_PowerUpConverter
+**
+** Description:
+** Powers all DC/DC converters sequentially with delay to minimize
+** peak power draw on VDC.
+**
+** Returns:
+** int (error)
+**
+*/
+int Si3228x_PowerUpConverter(proslicChanType_ptr pProslic)
+{
+  errorCodeType error = RC_NONE;
+  int32 vbath,vbat;
+  uInt8 reg;
+  ramData data;
+  int timer = 0;
+
+  ProSLIC_SetUserMode(pProslic,TRUE, FALSE);
+
+  /*
+  ** Check to see if already powered, return if so
+  */
+  data = ReadRAM(pProHW,pProslic->channel,PD_DCDC);
+  if(!(data & 0x100000))
+  {
+    return RC_NONE;   /* Return if already powered up */
+  }
+
+  /*
+  ** Power up sequence
+  */
+  if(Si3228x_General_Configuration.batType == BO_DCDC_TRACKING)
+  {
+    /*
+    ** TRACKING CONVERTER SEQUENCE
+    **
+    ** - clear previous ov/uv lockout
+    ** - powerup charge pump
+    ** - delay
+    ** - powerup digital dc/dc w/ OV clamping and shutdown
+    ** - delay
+    ** - verify no short circuits by looking for vbath/2
+    ** - clear dcdc status
+    ** - switch to analog converter with OV clamping only (no shutdown)
+    ** - select analog dcdc and disable pwrsave
+    ** - delay
+    */
+
+    WriteRAM(pProHW,pProslic->channel,DCDC_OITHRESH,
+             Si3228x_General_Configuration.dcdc_oithresh_lo);
+    WriteReg(pProHW,pProslic->channel,LINEFEED,
+             LF_OPEN);  /* Ensure open before powering converter */
+    reg = ReadReg(pProHW,pProslic->channel,
+                  ENHANCE);      /* Read ENHANCE entry settings */
+    WriteReg(pProHW,pProslic->channel,ENHANCE,
+             reg&0x07);  /* Disable powersave during bringup */
+    WriteRAM(pProHW,pProslic->channel,PD_DCDC,
+             0x700000L);   /* In case OV or UV previously occurred */
+    WriteRAM(pProHW,pProslic->channel,DCDC_CPUMP,
+             0x100000L);/* Turn on charge pump */
+
+    Delay(pProTimer,10);
+    WriteRAM(pProHW,pProslic->channel,PD_DCDC,0x600000L);
+    Delay(pProTimer,50);
+    vbath = ReadRAM(pProHW,pProslic->channel,VBATH_EXPECT);
+    vbat = ReadRAM(pProHW,pProslic->channel,MADC_VBAT);
+    if(vbat & 0x10000000L)
+    {
+      vbat |= 0xF0000000L;
+    }
+#ifdef ENABLE_DEBUG
+    if(pProslic->debugMode)
+    {
+      LOGPRINT ("%sVBAT @ 50ms = %d.%d v\n",
+                LOGPRINT_PREFIX,
+                (int)((vbat/SCALE_V_MADC)/1000),
+                (int)(((vbat/SCALE_V_MADC) - (vbat/SCALE_V_MADC)/1000*1000)));
+    }
+#endif
+    if(vbat < (vbath / 2))
+    {
+      pProslic->channelEnable = 0;
+      error = RC_VBAT_UP_TIMEOUT;
+      WriteRAM(pProHW,pProslic->channel,PD_DCDC, 0x300000L); /* shutdown converter */
+#ifdef ENABLE_DEBUG
+      if(pProslic->debugMode)
+      {
+        LOGPRINT ("%sDCDC Short Circuit Failure %d - disabling channel\n",
+                  LOGPRINT_PREFIX,
+                  pProslic->channel);
+      }
+#endif
+      return error;
+    }
+    else   /* Enable analog converter */
+    {
+      WriteRAM(pProHW,pProslic->channel,DCDC_STATUS,0L);
+      WriteRAM(pProHW,pProslic->channel,PD_DCDC,0x400000L);
+      WriteReg(pProHW,pProslic->channel,ENHANCE,reg);   /* restore ENHANCE setting */
+      Delay(pProTimer,50);
+    }
+
+    /*
+    ** - monitor vbat vs expected level (VBATH_EXPECT)
+    */
+    vbath = ReadRAM(pProHW,pProslic->channel,VBATH_EXPECT);
+    do
+    {
+      vbat = ReadRAM(pProHW,pProslic->channel,MADC_VBAT);
+      if(vbat & 0x10000000L)
+      {
+        vbat |= 0xF0000000L;
+      }
+      Delay(pProTimer,10);
+    }
+    while((vbat < (vbath - COMP_5V))&&(timer++ < 200));   /* 2 sec timeout */
+
+#ifdef ENABLE_DEBUG
+    if(pProslic->debugMode)
+    {
+      LOGPRINT ("%sVBAT Up = %d.%d v\n",
+                LOGPRINT_PREFIX,
+                (int)((vbat/SCALE_V_MADC)/1000),
+                (int)(((vbat/SCALE_V_MADC) - (vbat/SCALE_V_MADC)/1000*1000)));
+    }
+#endif
+    if(timer > 200)
+    {
+      /* Error handling - shutdown converter, disable channel, set error tag */
+      pProslic->channelEnable = 0;
+      error = RC_VBAT_UP_TIMEOUT;
+      WriteRAM(pProHW,pProslic->channel,PD_DCDC, 0x300000L); /* shutdown converter */
+#ifdef ENABLE_DEBUG
+      if(pProslic->debugMode)
+      {
+        LOGPRINT ("%sDCDC Power up timeout channel %d - disabling channel\n",
+                  LOGPRINT_PREFIX,
+                  pProslic->channel);
+      }
+#endif
+    }
+    return error;
+  }
+  else /* external battery - just verify presence */
+  {
+    /*
+    ** - monitor vbat vs expected level (VBATH_EXPECT)
+    */
+    vbath = ReadRAM(pProHW,pProslic->channel,VBATH_EXPECT);
+    do
+    {
+      vbat = ReadRAM(pProHW,pProslic->channel,MADC_VBAT);
+      if(vbat & 0x10000000L)
+      {
+        vbat |= 0xF0000000L;
+      }
+      Delay(pProTimer,10);
+    }
+    while((vbat < (vbath - COMP_5V))&&(timer++ < 200));   /* 2 sec timeout */
+
+#ifdef ENABLE_DEBUG
+    if(pProslic->debugMode)
+    {
+      LOGPRINT ("%sExt VBAT Up = %d.%d v\n",
+                LOGPRINT_PREFIX,
+                (int)((vbat/SCALE_V_MADC)/1000),
+                (int)(((vbat/SCALE_V_MADC) - (vbat/SCALE_V_MADC)/1000*1000)));
+    }
+#endif
+    if(timer > 200)
+    {
+      /* Error handling - shutdown converter, disable channel, set error tag */
+      pProslic->channelEnable = 0;
+      error = RC_VBAT_UP_TIMEOUT;
+#ifdef ENABLE_DEBUG
+      if(pProslic->debugMode)
+      {
+        LOGPRINT ("%sExternal VBAT timeout channel %d - disabling channel\n",
+                  LOGPRINT_PREFIX,
+                  pProslic->channel);
+      }
+#endif
+    }
+
+
+  }
+
+  return error;
+}
+
+/*
+**
+** PROSLIC INITIALIZATION FUNCTIONS
+**
+*/
+
+/*
+** Function: Si3228x_Init_MultiBOM
+**
+** Description:
+** - probe SPI to establish daisy chain length
+** - load patch
+** - initialize general parameters
+** - calibrate madc
+** - bring up DC/DC converters
+** - calibrate remaining items except madc & lb
+**
+** Input Parameters:
+** pProslic: pointer to PROSLIC object array
+** fault: error code
+**
+** Return:
+** error code
+*/
+
+#ifdef SIVOICE_MULTI_BOM_SUPPORT
+
+int Si3228x_Init_MultiBOM(proslicChanType_ptr *pProslic,int size, int preset)
+{
+
+  if(preset < si3228x_genconf_multi_max_preset)
+  {
+    /* Copy selected General COnfiguration parameters to std structure */
+    Si3228x_General_Configuration = Si3228x_General_Configuration_MultiBOM[preset];
+  }
+  else
+  {
+    return RC_INVALID_PRESET;
+  }
+  return Si3228x_Init_with_Options(pProslic,size, INIT_NO_OPT );
+}
+#endif
+
+/* Deterimine which patch to load */
+static int Si3228x_SelectPatch(proslicChanType_ptr pProslic,
+  const proslicPatch **patch)
+{
+  if (pProslic->deviceId->chipRev == SI3228X_REVA )
+  {
+#ifdef SIVOICE_MULTI_BOM_SUPPORT
+    if(Si3228x_General_Configuration.batType == BO_DCDC_TRACKING)
+    {
+      if( (Si3228x_General_Configuration.bomOpt == BO_DCDC_LCQC_5W)
+          || (Si3228x_General_Configuration.bomOpt == BO_DCDC_LCCB)
+          || (Si3228x_General_Configuration.bomOpt == BO_DCDC_LCCB110))
+      {
+        *patch = &(SI3228X_PATCH_A);
+      }
+    }
+    else
+    {
+#ifdef ENABLE_DEBUG
+      if(pProslic->debugMode)
+      {
+        LOGPRINT("%sChannel %d : Invalid Patch\n",LOGPRINT_PREFIX,
+                 pProslic->channel);
+      }
+#endif
+      pProslic->channelEnable = 0;
+      pProslic->error = RC_INVALID_PATCH;
+      return RC_INVALID_PATCH;
+    }
+#else /* ! MULTIBOM */
+    *patch = &(SI3228X_PATCH_A_DEFAULT);
+#endif
+  }
+  else
+  {
+#ifdef ENABLE_DEBUG
+    if (pProslic->debugMode)
+    {
+      LOGPRINT("%sChannel %d : Unsupported Device Revision (%d)\n",
+               LOGPRINT_PREFIX,
+               pProslic->channel,pProslic->deviceId->chipRev );
+    }
+#endif
+    pProslic->channelEnable = 0;
+    pProslic->error = RC_UNSUPPORTED_DEVICE_REV;
+    return RC_UNSUPPORTED_DEVICE_REV;
+  }
+  return RC_NONE;
+}
+
+/*
+** Function: Si3228x_Init_with_Options
+**
+** Description:
+** - probe SPI to establish daisy chain length
+** - load patch
+** - initialize general parameters
+** - calibrate madc
+** - bring up DC/DC converters
+** - calibrate remaining items except madc & lb
+**
+** Input Parameters:
+** pProslic: pointer to PROSLIC object array
+** fault: error code
+**
+** Return:
+** error code
+*/
+
+int Si3228x_Init_with_Options (proslicChanType_ptr *pProslic, int size,
+                               initOptionsType init_opt)
+{
+  /*
+  ** This function will initialize the chipRev and chipType members in pProslic
+  ** as well as load the initialization structures.
+  */
+
+  uInt8 data;
+  uInt8 calSetup[] = {0x00, 0x00, 0x01, 0x80};  /* CALR0-CALR3 */
+  int k, device_count, status;
+  const proslicPatch *patch = NULL;
+  ramData swdrv_pol;
+  ramData pdn_tmp;
+
+  LOGPRINT("%s(%d) size = %d init_opt = %d\n", __FUNCTION__, __LINE__, size,
+           init_opt);
+  /*
+  **
+  ** First qualify general parameters by identifying valid device key.  This
+  ** will prevent inadvertent use of other device's preset files, which could
+  ** lead to improper initialization and high current states.
+  */
+
+  data = Si3228x_General_Configuration.device_key;
+
+  if((data < DEVICE_KEY_MIN)||(data > DEVICE_KEY_MAX))
+  {
+    pProslic[0]->error = RC_INVALID_GEN_PARAM;
+    return pProslic[0]->error;
+  }
+
+  /* reset error code */
+  for(k = 0; k < size; k++)
+  {
+    pProslic[k]->error = RC_NONE;
+  }
+
+  if((init_opt == INIT_REINIT) || (init_opt == INIT_SOFTRESET))
+  {
+    ProSLIC_ReInit_helper(pProslic, size, init_opt, SI3228X_CHAN_PER_DEVICE);
+  }
+ 
+  if( init_opt != INIT_REINIT )
+  {
+    if( (SiVoice_IdentifyChannels(pProslic, size, &device_count, NULL) != RC_NONE)
+        ||(device_count == 0) )
+    {
+      DEBUG_PRINT(*pProslic, "%s: failed to detect any ProSLICs\n", LOGPRINT_PREFIX);
+      return RC_SPI_FAIL;
+    }
+
+    data = Si3228x_General_Configuration.device_key - DEVICE_KEY_MIN;
+
+    /* Verify constants file is compatible with the given chipsets. */
+    for (k = 0; k < size; k++ )
+    {
+      if( (pProslic[k]->channelEnable) 
+        && (pProslic[k]->channelType == PROSLIC) 
+        && ( ( ( data < 4) && (pProslic[k]->deviceId->chipType- SI32280) >= 4 )
+          || ( (data >=4) && (pProslic[k]->deviceId->chipType - SI32280) < 4) ) )
+      {
+#ifdef ENABLE_DEBUG
+          LOGPRINT("%sConstants file mismatch for channel %d\n", LOGPRINT_PREFIX, k);
+#endif
+          pProslic[k]->channelEnable = 0;
+          pProslic[k]->error = RC_INVALID_GEN_PARAM;
+          return pProslic[k]->error;    
+      }
+    }
+
+    /*
+    ** Probe each channel and enable all channels that respond
+    */
+    if(init_opt != INIT_REINIT)
+    {
+      for (k=0; k<size; k++)
+      {
+        if ((pProslic[k]->channelEnable)
+            &&(pProslic[k]->channelType == PROSLIC))
+        {
+          if ( (ProSLIC_VerifyMasterStat(pProslic[k]) != RC_NONE)
+               || (ProSLIC_VerifyControlInterface(pProslic[k]) != RC_NONE) )
+          {
+            pProslic[k]->channelEnable = 0;
+            pProslic[k]->error = RC_SPI_FAIL;
+            DEBUG_PRINT(*pProslic, "%s: SPI communications or PCLK/FS failure\n", LOGPRINT_PREFIX);
+            return pProslic[k]->error;    /* Halt init if SPI fail */
+          }
+        }
+      }
+    }
+  } /* init_opt */
+
+  if((init_opt != INIT_REINIT)&&(init_opt != INIT_NO_PATCH_LOAD) )
+  {
+    /**
+     * Load patch (do not enable until patch loaded on all channels)
+     */
+    for (k=0; k<size; k++)
+    {
+      if ((pProslic[k]->channelEnable)&&(pProslic[k]->channelType == PROSLIC))
+      {
+        status = Si3228x_SelectPatch(pProslic[k], &patch);
+        
+        if(status != RC_NONE)
+        {
+          return status;
+        }
+
+        data = 1; /* Use this as a flag to see if we need to load the patch */
+        /* If the patch doesn't match, we need to do a full init, change settings */
+        if(init_opt == INIT_SOFTRESET) 
+        {
+          ramData patchData;
+          patchData = pProslic[k]->ReadRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                                            PROSLIC_RAM_PATCHID);
+
+          if( patchData ==  patch->patchSerial)
+          {
+            data = 0;
+          }
+          else
+          {
+            init_opt = INIT_NO_OPT;
+          }
+        } /* SOFTRESET */
+
+        if(data == 1)
+        {
+          ProSLIC_LoadPatch_extended(pProslic[k],patch, FALSE, (k&1));
+#ifndef DISABLE_VERIFY_PATCH
+          if(((k&1) == 0)) /* Verify only 1st channel per device */
+          {
+            data = (uInt8)ProSLIC_VerifyPatch(pProslic[k],patch);
+            if (data)
+            {
+              DEBUG_PRINT(pProslic[k], "%sChannel %d : Patch verification failed (%d)\n", 
+                   LOGPRINT_PREFIX, k, data);
+              pProslic[k]->channelEnable=0;
+              pProslic[k]->error = data;
+              return data;   /* Stop Init if patch load failure occurs */
+            }
+          }
+#endif
+          if( (k&1) == 1)
+          {
+            pProslic[k]->WriteRegX(pProslic[k]->pProHWX, pProslic[k]->channel, JMPEN,
+                                   1); /* Enable patch */
+          }
+        }
+      } /* PROSLIC */
+    } /* for loop */
+  } /* init_opt */
+  else
+  {
+    /* Since we did a soft reset, we need to reload the support RAM */
+    if(init_opt == INIT_REINIT)
+    {
+      for(k = 0; k < size; k++)
+      {
+        status = Si3228x_SelectPatch(pProslic[k], &patch);
+      
+        if(status != RC_NONE)
+        {
+          return status;
+        }
+
+        ProSLIC_LoadSupportRAM(pProslic[k], pProslic[k]->channel, 
+          patch->psRamAddr, patch->psRamData);
+      }
+    }
+  }
+
+  /*
+  ** Load general parameters - includes all BOM dependencies
+  **
+  */
+  if(init_opt != INIT_SOFTRESET)
+  {
+    for (k=0; k<size; k++)
+    {
+      if ((pProslic[k]->channelEnable)&&(pProslic[k]->channelType == PROSLIC))
+      {
+        ProSLIC_SetUserMode(pProslic[k],TRUE, FALSE);
+        /* Force pwrsave off and disable AUTO-tracking - set to user configured state after cal */
+        pProslic[k]->WriteRegX(pProslic[k]->pProHWX, pProslic[k]->channel,ENHANCE,0);
+        pProslic[k]->WriteRegX(pProslic[k]->pProHWX, pProslic[k]->channel,AUTO,0x2F);
+
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,BAT_HYST,
+                               Si3228x_General_Configuration.bat_hyst);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,VBATR_EXPECT,
+                               Si3228x_General_Configuration.vbatr_expect);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,VBATH_EXPECT,
+                               Si3228x_General_Configuration.vbath_expect);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,PWRSAVE_TIMER,
+                               Si3228x_General_Configuration.pwrsave_timer);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                               OFFHOOK_THRESH,Si3228x_General_Configuration.offhook_thresh);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                               VBAT_TRACK_MIN,Si3228x_General_Configuration.vbat_track_min);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                               VBAT_TRACK_MIN_RNG,Si3228x_General_Configuration.vbat_track_min_rng);
+
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,THERM_DBI,
+                               Si3228x_General_Configuration.therm_dbi);
+
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,DCDC_VERR,
+                               Si3228x_General_Configuration.dcdc_verr);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                               DCDC_VERR_HYST,Si3228x_General_Configuration.dcdc_verr_hyst);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                               DCDC_OITHRESH_LO,Si3228x_General_Configuration.dcdc_oithresh_lo);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                               DCDC_OITHRESH_HI,Si3228x_General_Configuration.dcdc_oithresh_hi);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,PD_UVLO,
+                               Si3228x_General_Configuration.pd_uvlo);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,PD_OVLO,
+                               Si3228x_General_Configuration.pd_ovlo);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,PD_OCLO,
+                               Si3228x_General_Configuration.pd_oclo);
+
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,DCDC_UVHYST,
+                               Si3228x_General_Configuration.dcdc_uvhyst);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,DCDC_UVTHRESH,
+                               Si3228x_General_Configuration.dcdc_uvthresh);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,DCDC_OVTHRESH,
+                               Si3228x_General_Configuration.dcdc_ovthresh);
+
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,DCDC_UVPOL,
+                               Si3228x_General_Configuration.dcdc_uvpol);
+
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                               DCDC_VREF_CTRL,Si3228x_General_Configuration.dcdc_vref_ctrl);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,DCDC_RNGTYPE,
+                               Si3228x_General_Configuration.dcdc_rngtype);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,DCDC_ANA_GAIN,
+                               Si3228x_General_Configuration.dcdc_ana_gain);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,DCDC_ANA_TOFF,
+                               Si3228x_General_Configuration.dcdc_ana_toff);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                               DCDC_ANA_TONMIN,Si3228x_General_Configuration.dcdc_ana_tonmin);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                               DCDC_ANA_TONMAX,Si3228x_General_Configuration.dcdc_ana_tonmax);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                               DCDC_ANA_DSHIFT,Si3228x_General_Configuration.dcdc_ana_dshift);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                               DCDC_ANA_LPOLY,Si3228x_General_Configuration.dcdc_ana_lpoly);
+
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,COEF_P_HVIC,
+                               Si3228x_General_Configuration.coef_p_hvic);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,P_TH_HVIC,
+                               Si3228x_General_Configuration.p_th_hvic);
+
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,SCALE_KAUDIO,
+                               Si3228x_General_Configuration.scale_kaudio);
+
+        /* GC RAM locations that moved from RevB to RevC */
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                               LKG_OFHK_OFFSET,Si3228x_General_Configuration.lkg_ofhk_offset);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,LKG_LB_OFFSET,
+                               Si3228x_General_Configuration.lkg_lb_offset);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,VBATH_DELTA,
+                               Si3228x_General_Configuration.vbath_delta);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,UVTHRESH_MAX,
+                               Si3228x_General_Configuration.uvthresh_max);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                               UVTHRESH_SCALE,Si3228x_General_Configuration.uvthresh_scale);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,UVTHRESH_BIAS,
+                               Si3228x_General_Configuration.uvthresh_bias);
+
+        /* Hardcoded mods to default settings */
+        data = pProslic[k]->ReadRegX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                                     GPIO_CFG1);
+        data &= 0xF9;  /* Clear DIR for GPIO 1&2 */
+        data |= 0x60;  /* Set ANA mode for GPIO 1&2 */
+        pProslic[k]->WriteRegX(pProslic[k]->pProHWX, pProslic[k]->channel,GPIO_CFG1,
+                               data); /* coarse sensors analog mode */
+        pProslic[k]->WriteRegX(pProslic[k]->pProHWX, pProslic[k]->channel,PDN,
+                               0x80); /* madc powered in open state */
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,TXACHPF_A1_1,
+                               0x71EB851L); /* Fix HPF corner */
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,ROW0_C2,
+                               0x723F235L);   /* improved DTMF det */
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,ROW1_C2,
+                               0x57A9804L);   /* improved DTMF det */
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,XTALK_TIMER,
+                               0x36000L); /* xtalk fix */
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                               DCDC_CPUMP_LP_MASK,0x1100000L); /* Charge pump mask */
+        /* Smart VOV Default Settings - set here in case no ring preset is loaded */
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                               VOV_DCDC_SLOPE,0xFFFFFFL); /* dcdc overhead scale */
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,VOV_DCDC_OS,
+                               0xA18937L); /* smart vov overhead offset*/
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                               VOV_RING_BAT_MAX,0xE49BA5L); /* smart vov max vov */
+
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,VDIFFLPF,
+                               0x10038DL); /* vloop lpf 10hz */
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,ILOOPLPF,
+                               0x4EDDB9L); /* iloop lpf*/
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,ILONGLPF,
+                               0x806D6L); /* ilong lpf */
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,VCMLPF,
+                               0x10059FL); /* 20pps pulse dialing */
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                               CM_SPEEDUP_TIMER,0xF0000L); /* 20pps pulse dialing */
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,VCM_TH,
+                               0x106240L); /* 20pps pulse dialing */
+
+        /* Prevent Ref Osc from powering down in PLL Freerun mode (pd_ref_osc) */
+        pdn_tmp = pProslic[k]->ReadRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                                        PWRSAVE_CTRL_LO);
+        pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                               PWRSAVE_CTRL_LO,pdn_tmp&0x0BFFFFFFL);/* clear b26 */
+
+        /* Hardcoded mods for Tracking supplies */
+        if(Si3228x_General_Configuration.batType == BO_DCDC_TRACKING)
+        {
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                                 DCDC_UV_DEBOUNCE, 0x200000L);
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                                 DCDC_OV_DEBOUNCE, 0x0L);
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,DCDC_OIMASK,
+                                 0xC00000L);
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,VCM_HYST,
+                                 0x206280L); /* 2v */
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                                 DCDC_DCFF_ENABLE,0x0L);/* disable dcff drive */
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,LPR_SCALE,
+                                 0x1F00000L);/* scale for LPR amplitude */
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,LPR_CM_OS,
+                                 0x51EB80L); /* LPR cm offset */
+        }
+        else /* EXTERNAL */
+        {
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                                 DCDC_UV_DEBOUNCE, 0x0L);
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                                 DCDC_OV_DEBOUNCE, 0xD00000L);
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,DCDC_OIMASK,
+                                 0xA00000L);
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,VCM_HYST,
+                                 0x306280L); /* 3v */
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,LPR_SCALE,
+                                 0x2A00000L);/* scale for LPR amplitude */
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,LPR_CM_OS,
+                                 0x61EB80L); /* LPR cm offset */
+
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,VBATL_EXPECT,
+                                 0xF00000L); /* force vbatl 13v to keep cm recalc */
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                                 MADC_VDC_SCALE, 0xAE924B9L);
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,DCDC_PD_ANA,
+                                 0x300000);
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,P_TH_OFFLOAD,
+                                 0x280CBFL); /* 1.1W @ 60C */
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,PD_OFFLD_DAC,
+                                 0x200000L);
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,PD_OFFLD_GM,
+                                 0x200000L);
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                                 DCDC_CPUMP_LP_MASK,0x100000L); /* Charge pump mask */
+
+          /* Setup power offloading for tracking switched supplies */
+          pProslic[k]->WriteRegX(pProslic[k]->pProHWX, pProslic[k]->channel,OFFLOAD,
+                                 0x13); /* Enable offload and vbat_l, disable fixed rail battery management. */
+        }
+
+        /* DCDC Drive Polarity */
+        if(pProslic[k]->dcdc_polarity_invert)
+        {
+          if(Si3228x_General_Configuration.dcdc_swdrv_pol == 0)
+          {
+            swdrv_pol = 0x100000L;
+          }
+          else
+          {
+            swdrv_pol = 0x0L;
+          }
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                                 DCDC_SWDRV_POL,swdrv_pol);
+        }
+        else
+        {
+          pProslic[k]->WriteRAMX(pProslic[k]->pProHWX, pProslic[k]->channel,
+                                 DCDC_SWDRV_POL,Si3228x_General_Configuration.dcdc_swdrv_pol);
+        }
+      }
+      pProslic[k]->WriteRAMX(pProslic[k]->pProHWX,pProslic[k]->channel,IRING_LIM,
+                             SI3228X_IRING_LIM_MAX);
+    }
+  } /* !INIT_SOFTRESET */
+
+  if((init_opt != INIT_NO_CAL) && (init_opt != INIT_SOFTRESET))
+  {
+    /*
+    ** Calibrate (madc offset)
+    */
+    ProSLIC_Calibrate(pProslic,size,calSetup,TIMEOUT_MADC_CAL);
+  }
+
+  /*
+  ** Bring up DC/DC converters sequentially to minimize
+  ** peak power demand on VDC
+  */
+  for (k=0; k<size; k++)
+  {
+    if ((pProslic[k]->channelEnable)&&(pProslic[k]->channelType == PROSLIC))
+    {
+      pProslic[k]->error = Si3228x_PowerUpConverter(pProslic[k]);
+    }
+  }
+
+  if((init_opt != INIT_NO_CAL)&&(init_opt != INIT_REINIT)
+      &&(init_opt != INIT_SOFTRESET))
+  {
+    /*
+    ** Calibrate remaining cals (except madc, lb)
+    */
+    calSetup[1] = SI3228X_CAL_STD_CALR1;
+    calSetup[2] = SI3228X_CAL_STD_CALR2;
+    ProSLIC_Calibrate(pProslic,size,calSetup,TIMEOUT_GEN_CAL);
+  }
+
+  /*
+  ** Apply user configured ENHANCE and AUTO
+  */
+  if(init_opt != INIT_SOFTRESET)
+  {
+    for (k=0; k<size; k++)
+    {
+      if ((pProslic[k]->channelEnable)&&(pProslic[k]->channelType == PROSLIC))
+      {
+        pProslic[k]->WriteRegX(pProslic[k]->pProHWX, pProslic[k]->channel,ENHANCE,
+                               Si3228x_General_Configuration.enhance);
+        pProslic[k]->WriteRegX(pProslic[k]->pProHWX, pProslic[k]->channel,AUTO,
+                               Si3228x_General_Configuration.autoRegister);
+        pProslic[k]->WriteRegX(pProslic[k]->pProHWX, pProslic[k]->channel,ZCAL_EN,
+                               Si3228x_General_Configuration.zcal_en);
+      }
+    }
+  }
+
+  if((init_opt == INIT_REINIT) || (init_opt == INIT_SOFTRESET))
+  {
+    for(k = 0; k < size; k++)
+    {
+      pProslic[k]->WriteRegX(pProslic[k]->pProHWX,pProslic[k]->channel,LINEFEED,
+                             pProslic[k]->scratch);
+    }
+    }
+
+#ifdef ENABLE_DEBUG
+  if(pProslic[0]->debugMode)
+    {
+    LOGPRINT("%s: ProSLIC initialization completed.\n", LOGPRINT_PREFIX);
+  }
+#endif
+
+  return RC_NONE;
+}
+
+/*
+** Function: Si3228x_EnableInterrupts
+**
+** Description:
+** Enables interrupts
+**
+** Input Parameters:
+** pProslic:   pointer to PROSLIC channel obj
+**
+** Returns:
+** 0
+*/
+int Si3228x_EnableInterrupts (proslicChanType_ptr pProslic)
+{
+  uInt8 i;
+  /* Clear interrupts prior to enabling them */
+  for(i = IRQ1; i< IRQ4; i++)
+  {
+    (void)ReadReg(pProHW,pProslic->channel, i);
+  }
+  WriteReg (pProHW,pProslic->channel,IRQEN1,Si3228x_General_Configuration.irqen1);
+  WriteReg (pProHW,pProslic->channel,IRQEN2,Si3228x_General_Configuration.irqen2);
+  WriteReg (pProHW,pProslic->channel,IRQEN3,Si3228x_General_Configuration.irqen3);
+  WriteReg (pProHW,pProslic->channel,IRQEN4,Si3228x_General_Configuration.irqen4);
+  return 0;
+}
+
+/*
+**
+** PROSLIC CONFIGURATION FUNCTIONS
+**
+*/
+
+/*
+** Function: Si3228x_RingSetup
+**
+** Description:
+** configure ringing
+**
+** Input Parameters:
+** pProslic:   pointer to PROSLIC channel obj
+** preset:     ring preset
+**
+** Returns:
+** 0
+*/
+#ifndef DISABLE_RING_SETUP
+int Si3228x_RingSetup (proslicChanType *pProslic, int preset)
+{
+
+  WriteRAM(pProHW,pProslic->channel,RTPER,Si3228x_Ring_Presets[preset].rtper);
+  WriteRAM(pProHW,pProslic->channel,RINGFR,Si3228x_Ring_Presets[preset].freq);
+  WriteRAM(pProHW,pProslic->channel,RINGAMP,Si3228x_Ring_Presets[preset].amp);
+  WriteRAM(pProHW,pProslic->channel,RINGPHAS,Si3228x_Ring_Presets[preset].phas);
+  WriteRAM(pProHW,pProslic->channel,RINGOF,Si3228x_Ring_Presets[preset].offset);
+  WriteRAM(pProHW,pProslic->channel,SLOPE_RING,
+           Si3228x_Ring_Presets[preset].slope_ring);
+
+  if(Si3228x_Ring_Presets[preset].iring_lim > SI3228X_IRING_LIM_MAX)
+  {
+    Si3228x_Ring_Presets[preset].iring_lim = SI3228X_IRING_LIM_MAX;
+  }
+
+  WriteRAM(pProHW,pProslic->channel,IRING_LIM,
+           Si3228x_Ring_Presets[preset].iring_lim);
+  WriteRAM(pProHW,pProslic->channel,RTACTH,Si3228x_Ring_Presets[preset].rtacth);
+  WriteRAM(pProHW,pProslic->channel,RTDCTH,Si3228x_Ring_Presets[preset].rtdcth);
+  WriteRAM(pProHW,pProslic->channel,RTACDB,Si3228x_Ring_Presets[preset].rtacdb);
+  WriteRAM(pProHW,pProslic->channel,RTDCDB,Si3228x_Ring_Presets[preset].rtdcdb);
+  WriteRAM(pProHW,pProslic->channel,VOV_RING_BAT,
+           Si3228x_Ring_Presets[preset].vov_ring_bat);
+  WriteRAM(pProHW,pProslic->channel,VOV_RING_GND,
+           Si3228x_Ring_Presets[preset].vov_ring_gnd);
+
+  /* Always limit VBATR_EXPECT to the general configuration maximum */
+#ifndef NOCLAMP_VBATR
+  if(Si3228x_Ring_Presets[preset].vbatr_expect >
+      Si3228x_General_Configuration.vbatr_expect)
+  {
+    WriteRAM(pProHW,pProslic->channel,VBATR_EXPECT,
+             Si3228x_General_Configuration.vbatr_expect);
+#ifdef ENABLE_DEBUG
+    if(pProslic->debugMode)
+    {
+      LOGPRINT("%sVBATR_EXPECT : Clamped to Gen Conf Limit\n", LOGPRINT_PREFIX);
+    }
+#endif
+  }
+  else
+  {
+    WriteRAM(pProHW,pProslic->channel,VBATR_EXPECT,
+             Si3228x_Ring_Presets[preset].vbatr_expect);
+  }
+#else
+  WriteRAM(pProHW,pProslic->channel,VBATR_EXPECT,
+           Si3228x_Ring_Presets[preset].vbatr_expect);
+#endif
+
+  WriteReg(pProHW,pProslic->channel,RINGTALO,Si3228x_Ring_Presets[preset].talo);
+  WriteReg(pProHW,pProslic->channel,RINGTAHI,Si3228x_Ring_Presets[preset].tahi);
+  WriteReg(pProHW,pProslic->channel,RINGTILO,Si3228x_Ring_Presets[preset].tilo);
+  WriteReg(pProHW,pProslic->channel,RINGTIHI,Si3228x_Ring_Presets[preset].tihi);
+
+  WriteRAM(pProHW,pProslic->channel,DCDC_VREF_MIN_RNG,
+           Si3228x_Ring_Presets[preset].vbat_track_min_rng);
+  WriteReg(pProHW,pProslic->channel,RINGCON,Si3228x_Ring_Presets[preset].ringcon);
+  WriteReg(pProHW,pProslic->channel,USERSTAT,
+           Si3228x_Ring_Presets[preset].userstat);
+  WriteRAM(pProHW,pProslic->channel,VCM_RING,
+           Si3228x_Ring_Presets[preset].vcm_ring);
+  WriteRAM(pProHW,pProslic->channel,VCM_RING_FIXED,
+           Si3228x_Ring_Presets[preset].vcm_ring_fixed);
+  WriteRAM(pProHW,pProslic->channel,DELTA_VCM,
+           Si3228x_Ring_Presets[preset].delta_vcm);
+
+  /* Smart VOV Parameters - set during ProSLIC_Init(). */
+  /* Compile option left to use ring preset values     */
+#ifdef ENABLE_RING_PRESET_SMART_VOV
+  WriteRAM(pProHW,pProslic->channel,VOV_DCDC_SLOPE,
+           Si3228x_Ring_Presets[preset].vov_dcdc_slope);
+  WriteRAM(pProHW,pProslic->channel,VOV_DCDC_OS,
+           Si3228x_Ring_Presets[preset].vov_dcdc_os);
+  WriteRAM(pProHW,pProslic->channel,VOV_RING_BAT_MAX,
+           Si3228x_Ring_Presets[preset].vov_ring_bat_max);
+#endif
+
+  ProSLIC_SetUserMode(pProslic,TRUE, FALSE);
+
+  /* Automatically adjust DCDC_RNGTYPE */
+  WriteRAM(pProHW,pProslic->channel,DCDC_RNGTYPE,
+           Si3228x_Ring_Presets[preset].dcdc_rngtype);
+
+  WriteRAM(pProHW,pProslic->channel,SMART_RING_COUNTER,0);
+
+  if(Si3228x_Ring_Presets[preset].smart_ring_period != 0)
+  {
+    WriteRAM(pProHW,pProslic->channel,SMART_RING_PERIOD,
+             Si3228x_Ring_Presets[preset].smart_ring_period);
+    WriteRAM(pProHW,pProslic->channel,SMART_RING_PHASE,
+             Si3228x_Ring_Presets[preset].smart_ring_phase);
+  }
+
+  return 0;
+}
+#endif
+
+/*
+** Function: PROSLIC_ZsynthSetup
+**
+** Description:
+** configure impedence synthesis
+*/
+#ifndef DISABLE_ZSYNTH_SETUP
+int Si3228x_ZsynthSetup (proslicChanType *pProslic, int preset)
+{
+  uInt8 lf;
+  uInt8 cal_en = 0;
+  uInt16 timer = 500;
+
+  lf = ReadReg(pProHW,pProslic->channel,LINEFEED);
+  WriteReg(pProHW,pProslic->channel,LINEFEED,0);
+  /*
+  ** Load provided coefficients - these are presumed to be 0dB/0dB
+  */
+  WriteRAM(pProHW,pProslic->channel,TXACEQ_C0,
+           Si3228x_Impedance_Presets[preset].audioEQ.txaceq_c0);
+  WriteRAM(pProHW,pProslic->channel,TXACEQ_C1,
+           Si3228x_Impedance_Presets[preset].audioEQ.txaceq_c1);
+  WriteRAM(pProHW,pProslic->channel,TXACEQ_C2,
+           Si3228x_Impedance_Presets[preset].audioEQ.txaceq_c2);
+  WriteRAM(pProHW,pProslic->channel,TXACEQ_C3,
+           Si3228x_Impedance_Presets[preset].audioEQ.txaceq_c3);
+  WriteRAM(pProHW,pProslic->channel,RXACEQ_C0,
+           Si3228x_Impedance_Presets[preset].audioEQ.rxaceq_c0);
+  WriteRAM(pProHW,pProslic->channel,RXACEQ_C1,
+           Si3228x_Impedance_Presets[preset].audioEQ.rxaceq_c1);
+  WriteRAM(pProHW,pProslic->channel,RXACEQ_C2,
+           Si3228x_Impedance_Presets[preset].audioEQ.rxaceq_c2);
+  WriteRAM(pProHW,pProslic->channel,RXACEQ_C3,
+           Si3228x_Impedance_Presets[preset].audioEQ.rxaceq_c3);
+  WriteRAM(pProHW,pProslic->channel,ECFIR_C2,
+           Si3228x_Impedance_Presets[preset].hybrid.ecfir_c2);
+  WriteRAM(pProHW,pProslic->channel,ECFIR_C3,
+           Si3228x_Impedance_Presets[preset].hybrid.ecfir_c3);
+  WriteRAM(pProHW,pProslic->channel,ECFIR_C4,
+           Si3228x_Impedance_Presets[preset].hybrid.ecfir_c4);
+  WriteRAM(pProHW,pProslic->channel,ECFIR_C5,
+           Si3228x_Impedance_Presets[preset].hybrid.ecfir_c5);
+  WriteRAM(pProHW,pProslic->channel,ECFIR_C6,
+           Si3228x_Impedance_Presets[preset].hybrid.ecfir_c6);
+  WriteRAM(pProHW,pProslic->channel,ECFIR_C7,
+           Si3228x_Impedance_Presets[preset].hybrid.ecfir_c7);
+  WriteRAM(pProHW,pProslic->channel,ECFIR_C8,
+           Si3228x_Impedance_Presets[preset].hybrid.ecfir_c8);
+  WriteRAM(pProHW,pProslic->channel,ECFIR_C9,
+           Si3228x_Impedance_Presets[preset].hybrid.ecfir_c9);
+  WriteRAM(pProHW,pProslic->channel,ECIIR_B0,
+           Si3228x_Impedance_Presets[preset].hybrid.ecfir_b0);
+  WriteRAM(pProHW,pProslic->channel,ECIIR_B1,
+           Si3228x_Impedance_Presets[preset].hybrid.ecfir_b1);
+  WriteRAM(pProHW,pProslic->channel,ECIIR_A1,
+           Si3228x_Impedance_Presets[preset].hybrid.ecfir_a1);
+  WriteRAM(pProHW,pProslic->channel,ECIIR_A2,
+           Si3228x_Impedance_Presets[preset].hybrid.ecfir_a2);
+  WriteRAM(pProHW,pProslic->channel,ZSYNTH_A1,
+           Si3228x_Impedance_Presets[preset].zsynth.zsynth_a1);
+  WriteRAM(pProHW,pProslic->channel,ZSYNTH_A2,
+           Si3228x_Impedance_Presets[preset].zsynth.zsynth_a2);
+  WriteRAM(pProHW,pProslic->channel,ZSYNTH_B1,
+           Si3228x_Impedance_Presets[preset].zsynth.zsynth_b1);
+  WriteRAM(pProHW,pProslic->channel,ZSYNTH_B0,
+           Si3228x_Impedance_Presets[preset].zsynth.zsynth_b0);
+  WriteRAM(pProHW,pProslic->channel,ZSYNTH_B2,
+           Si3228x_Impedance_Presets[preset].zsynth.zsynth_b2);
+  WriteReg(pProHW,pProslic->channel,RA,
+           Si3228x_Impedance_Presets[preset].zsynth.ra);
+  WriteRAM(pProHW,pProslic->channel,TXACGAIN,
+           Si3228x_Impedance_Presets[preset].txgain);
+  WriteRAM(pProHW,pProslic->channel,RXACGAIN_SAVE,
+           Si3228x_Impedance_Presets[preset].rxgain);
+  WriteRAM(pProHW,pProslic->channel,RXACGAIN,
+           Si3228x_Impedance_Presets[preset].rxgain);
+  WriteRAM(pProHW,pProslic->channel,RXACHPF_B0_1,
+           Si3228x_Impedance_Presets[preset].rxachpf_b0_1);
+  WriteRAM(pProHW,pProslic->channel,RXACHPF_B1_1,
+           Si3228x_Impedance_Presets[preset].rxachpf_b1_1);
+  WriteRAM(pProHW,pProslic->channel,RXACHPF_A1_1,
+           Si3228x_Impedance_Presets[preset].rxachpf_a1_1);
+
+  /*
+  ** Scale based on desired gain plan
+  */
+  Si3228x_dbgSetTXGain(pProslic,Si3228x_Impedance_Presets[preset].txgain_db,
+                       preset,TXACGAIN_SEL);
+  Si3228x_dbgSetRXGain(pProslic,Si3228x_Impedance_Presets[preset].rxgain_db,
+                       preset,RXACGAIN_SEL);
+  Si3228x_TXAudioGainSetup(pProslic,TXACGAIN_SEL);
+  Si3228x_RXAudioGainSetup(pProslic,RXACGAIN_SEL);
+
+  /*
+  ** Perform Zcal in case OHT used (eg. no offhook event to trigger auto Zcal)
+  */
+  WriteReg(pProHW,pProslic->channel,CALR0,0x00);
+  WriteReg(pProHW,pProslic->channel,CALR1,0x40);
+  WriteReg(pProHW,pProslic->channel,CALR2,0x00);
+  WriteReg(pProHW,pProslic->channel,CALR3,0x80);  /* start cal */
+
+  /* Wait for zcal to finish */
+  do
+  {
+    cal_en = ReadReg(pProHW,pProslic->channel,CALR3);
+    Delay(pProTimer,1);
+    timer--;
+  }
+  while((cal_en&0x80)&&(timer>0));
+
+  WriteReg(pProHW,pProslic->channel,LINEFEED,lf);
+
+  if(timer > 0)
+  {
+    return 0;
+  }
+  else
+  {
+    return RC_CAL_TIMEOUT;
+  }
+}
+#endif
+
+/*
+** Function: PROSLIC_AudioGainSetup
+**
+** Description:
+** configure audio gains
+*/
+int Si3228x_TXAudioGainSetup (proslicChanType *pProslic, int preset)
+{
+  WriteRAM(pProHW,pProslic->channel,TXACGAIN,
+           Si3228x_audioGain_Presets[preset].acgain);
+  WriteRAM(pProHW,pProslic->channel,TXACEQ_C0,
+           Si3228x_audioGain_Presets[preset].aceq_c0);
+  WriteRAM(pProHW,pProslic->channel,TXACEQ_C1,
+           Si3228x_audioGain_Presets[preset].aceq_c1);
+  WriteRAM(pProHW,pProslic->channel,TXACEQ_C2,
+           Si3228x_audioGain_Presets[preset].aceq_c2);
+  WriteRAM(pProHW,pProslic->channel,TXACEQ_C3,
+           Si3228x_audioGain_Presets[preset].aceq_c3);
+  return 0;
+}
+
+
+/*
+** Function: PROSLIC_AudioGainScale
+**
+** Description:
+** Multiply path gain by passed value for PGA and EQ scale (no reference to dB,
+** multiply by a scale factor)
+*/
+int Si3228x_AudioGainScale (proslicChanType *pProslic, int preset,
+                            uInt32 pga_scale, uInt32 eq_scale,int rx_tx_sel)
+{
+
+  if(rx_tx_sel == TXACGAIN_SEL)
+  {
+    Si3228x_audioGain_Presets[TXACGAIN_SEL].acgain =
+      (Si3228x_Impedance_Presets[preset].txgain/1000)*pga_scale;
+    if (Si3228x_Impedance_Presets[preset].audioEQ.txaceq_c0 & 0x10000000L)
+    {
+      Si3228x_Impedance_Presets[preset].audioEQ.txaceq_c0 |= 0xf0000000L;
+    }
+    if (Si3228x_Impedance_Presets[preset].audioEQ.txaceq_c1 & 0x10000000L)
+    {
+      Si3228x_Impedance_Presets[preset].audioEQ.txaceq_c1 |= 0xf0000000L;
+    }
+    if (Si3228x_Impedance_Presets[preset].audioEQ.txaceq_c2 & 0x10000000L)
+    {
+      Si3228x_Impedance_Presets[preset].audioEQ.txaceq_c2 |= 0xf0000000L;
+    }
+    if (Si3228x_Impedance_Presets[preset].audioEQ.txaceq_c3 & 0x10000000L)
+    {
+      Si3228x_Impedance_Presets[preset].audioEQ.txaceq_c3 |= 0xf0000000L;
+    }
+    Si3228x_audioGain_Presets[TXACGAIN_SEL].aceq_c0 = ((int32)
+        Si3228x_Impedance_Presets[preset].audioEQ.txaceq_c0/1000)*eq_scale;
+    Si3228x_audioGain_Presets[TXACGAIN_SEL].aceq_c1 = ((int32)
+        Si3228x_Impedance_Presets[preset].audioEQ.txaceq_c1/1000)*eq_scale;
+    Si3228x_audioGain_Presets[TXACGAIN_SEL].aceq_c2 = ((int32)
+        Si3228x_Impedance_Presets[preset].audioEQ.txaceq_c2/1000)*eq_scale;
+    Si3228x_audioGain_Presets[TXACGAIN_SEL].aceq_c3 = ((int32)
+        Si3228x_Impedance_Presets[preset].audioEQ.txaceq_c3/1000)*eq_scale;
+
+    WriteRAM(pProHW,pProslic->channel,TXACGAIN,
+             Si3228x_audioGain_Presets[TXACGAIN_SEL].acgain);
+    WriteRAM(pProHW,pProslic->channel,TXACEQ_C0,
+             Si3228x_audioGain_Presets[TXACGAIN_SEL].aceq_c0);
+    WriteRAM(pProHW,pProslic->channel,TXACEQ_C1,
+             Si3228x_audioGain_Presets[TXACGAIN_SEL].aceq_c1);
+    WriteRAM(pProHW,pProslic->channel,TXACEQ_C2,
+             Si3228x_audioGain_Presets[TXACGAIN_SEL].aceq_c2);
+    WriteRAM(pProHW,pProslic->channel,TXACEQ_C3,
+             Si3228x_audioGain_Presets[TXACGAIN_SEL].aceq_c3);
+  }
+  else
+  {
+    Si3228x_audioGain_Presets[RXACGAIN_SEL].acgain =
+      (Si3228x_Impedance_Presets[preset].rxgain/1000)*pga_scale;
+    if (Si3228x_Impedance_Presets[preset].audioEQ.rxaceq_c0 & 0x10000000L)
+    {
+      Si3228x_Impedance_Presets[preset].audioEQ.rxaceq_c0 |= 0xf0000000L;
+    }
+    if (Si3228x_Impedance_Presets[preset].audioEQ.rxaceq_c1 & 0x10000000L)
+    {
+      Si3228x_Impedance_Presets[preset].audioEQ.rxaceq_c1 |= 0xf0000000L;
+    }
+    if (Si3228x_Impedance_Presets[preset].audioEQ.rxaceq_c2 & 0x10000000L)
+    {
+      Si3228x_Impedance_Presets[preset].audioEQ.rxaceq_c2 |= 0xf0000000L;
+    }
+    if (Si3228x_Impedance_Presets[preset].audioEQ.rxaceq_c3 & 0x10000000L)
+    {
+      Si3228x_Impedance_Presets[preset].audioEQ.rxaceq_c3 |= 0xf0000000L;
+    }
+    Si3228x_audioGain_Presets[RXACGAIN_SEL].aceq_c0 = ((int32)
+        Si3228x_Impedance_Presets[preset].audioEQ.rxaceq_c0/1000)*eq_scale;
+    Si3228x_audioGain_Presets[RXACGAIN_SEL].aceq_c1 = ((int32)
+        Si3228x_Impedance_Presets[preset].audioEQ.rxaceq_c1/1000)*eq_scale;
+    Si3228x_audioGain_Presets[RXACGAIN_SEL].aceq_c2 = ((int32)
+        Si3228x_Impedance_Presets[preset].audioEQ.rxaceq_c2/1000)*eq_scale;
+    Si3228x_audioGain_Presets[RXACGAIN_SEL].aceq_c3 = ((int32)
+        Si3228x_Impedance_Presets[preset].audioEQ.rxaceq_c3/1000)*eq_scale;
+
+    WriteRAM(pProHW,pProslic->channel,RXACGAIN_SAVE,
+             Si3228x_audioGain_Presets[RXACGAIN_SEL].acgain);
+    WriteRAM(pProHW,pProslic->channel,RXACGAIN,
+             Si3228x_audioGain_Presets[RXACGAIN_SEL].acgain);
+    WriteRAM(pProHW,pProslic->channel,RXACEQ_C0,
+             Si3228x_audioGain_Presets[RXACGAIN_SEL].aceq_c0);
+    WriteRAM(pProHW,pProslic->channel,RXACEQ_C1,
+             Si3228x_audioGain_Presets[RXACGAIN_SEL].aceq_c1);
+    WriteRAM(pProHW,pProslic->channel,RXACEQ_C2,
+             Si3228x_audioGain_Presets[RXACGAIN_SEL].aceq_c2);
+    WriteRAM(pProHW,pProslic->channel,RXACEQ_C3,
+             Si3228x_audioGain_Presets[RXACGAIN_SEL].aceq_c3);
+  }
+  return 0;
+}
+int Si3228x_TXAudioGainScale (proslicChanType *pProslic, int preset,
+                              uInt32 pga_scale, uInt32 eq_scale)
+{
+  return Si3228x_AudioGainScale(pProslic,preset,pga_scale,eq_scale,TXACGAIN_SEL);
+}
+int Si3228x_RXAudioGainScale (proslicChanType *pProslic, int preset,
+                              uInt32 pga_scale, uInt32 eq_scale)
+{
+  return Si3228x_AudioGainScale(pProslic,preset,pga_scale,eq_scale,RXACGAIN_SEL);
+}
+/*
+** Function: PROSLIC_AudioGainSetup
+**
+** Description:
+** configure audio gains
+*/
+int Si3228x_RXAudioGainSetup (proslicChanType *pProslic, int preset)
+{
+  WriteRAM(pProHW,pProslic->channel,RXACGAIN_SAVE,
+           Si3228x_audioGain_Presets[preset].acgain);
+  WriteRAM(pProHW,pProslic->channel,RXACGAIN,
+           Si3228x_audioGain_Presets[preset].acgain);
+  WriteRAM(pProHW,pProslic->channel,RXACEQ_C0,
+           Si3228x_audioGain_Presets[preset].aceq_c0);
+  WriteRAM(pProHW,pProslic->channel,RXACEQ_C1,
+           Si3228x_audioGain_Presets[preset].aceq_c1);
+  WriteRAM(pProHW,pProslic->channel,RXACEQ_C2,
+           Si3228x_audioGain_Presets[preset].aceq_c2);
+  WriteRAM(pProHW,pProslic->channel,RXACEQ_C3,
+           Si3228x_audioGain_Presets[preset].aceq_c3);
+  return 0;
+}
+
+
+/*
+** Function: PROSLIC_DCFeedSetupCfg
+**
+** Description:
+** configure dc feed
+*/
+#ifndef DISABLE_DCFEED_SETUP
+int Si3228x_DCFeedSetupCfg (proslicChanType *pProslic, Si3228x_DCfeed_Cfg *cfg,
+                            int preset)
+{
+  uInt8 lf;
+
+  if(pProslic->channelType != PROSLIC)
+  {
+    return RC_CHANNEL_TYPE_ERR;
+  }
+  lf = ReadReg(pProHW,pProslic->channel,LINEFEED);
+  WriteReg(pProHW,pProslic->channel,LINEFEED,0);
+  WriteRAM(pProHW,pProslic->channel,SLOPE_VLIM,cfg[preset].slope_vlim);
+  WriteRAM(pProHW,pProslic->channel,SLOPE_RFEED,cfg[preset].slope_rfeed);
+  WriteRAM(pProHW,pProslic->channel,SLOPE_ILIM,cfg[preset].slope_ilim);
+  WriteRAM(pProHW,pProslic->channel,SLOPE_DELTA1,cfg[preset].delta1);
+  WriteRAM(pProHW,pProslic->channel,SLOPE_DELTA2,cfg[preset].delta2);
+  WriteRAM(pProHW,pProslic->channel,V_VLIM,cfg[preset].v_vlim);
+  WriteRAM(pProHW,pProslic->channel,V_RFEED,cfg[preset].v_rfeed);
+  WriteRAM(pProHW,pProslic->channel,V_ILIM,cfg[preset].v_ilim);
+  WriteRAM(pProHW,pProslic->channel,CONST_RFEED,cfg[preset].const_rfeed);
+  WriteRAM(pProHW,pProslic->channel,CONST_ILIM,cfg[preset].const_ilim);
+  WriteRAM(pProHW,pProslic->channel,I_VLIM,cfg[preset].i_vlim);
+  WriteRAM(pProHW,pProslic->channel,LCRONHK,cfg[preset].lcronhk);
+  WriteRAM(pProHW,pProslic->channel,LCROFFHK,cfg[preset].lcroffhk);
+  WriteRAM(pProHW,pProslic->channel,LCRDBI,cfg[preset].lcrdbi);
+  WriteRAM(pProHW,pProslic->channel,LONGHITH,cfg[preset].longhith);
+  WriteRAM(pProHW,pProslic->channel,LONGLOTH,cfg[preset].longloth);
+  WriteRAM(pProHW,pProslic->channel,LONGDBI,cfg[preset].longdbi);
+  WriteRAM(pProHW,pProslic->channel,LCRMASK,cfg[preset].lcrmask);
+  WriteRAM(pProHW,pProslic->channel,LCRMASK_POLREV,cfg[preset].lcrmask_polrev);
+  WriteRAM(pProHW,pProslic->channel,LCRMASK_STATE,cfg[preset].lcrmask_state);
+  WriteRAM(pProHW,pProslic->channel,LCRMASK_LINECAP,cfg[preset].lcrmask_linecap);
+  WriteRAM(pProHW,pProslic->channel,VCM_OH,cfg[preset].vcm_oh);
+  WriteRAM(pProHW,pProslic->channel,VOV_BAT,cfg[preset].vov_bat);
+  WriteRAM(pProHW,pProslic->channel,VOV_GND,cfg[preset].vov_gnd);
+
+  WriteReg(pProHW,pProslic->channel,LINEFEED,lf);
+  return RC_NONE;
+}
+
+#endif
+
+/*
+** Function: PROSLIC_PulseMeterSetup
+**
+** Description:
+** configure pulse metering
+*/
+#ifndef DISABLE_PULSE_SETUP
+int Si3228x_PulseMeterSetup (proslicChanType *pProslic, int preset)
+{
+  uInt8 reg;
+
+  WriteRAM(pProHW,pProslic->channel,PM_AMP_THRESH,
+           Si3228x_PulseMeter_Presets[preset].pm_amp_thresh);
+  reg = (Si3228x_PulseMeter_Presets[preset].pm_freq<<1)|
+        (Si3228x_PulseMeter_Presets[preset].pm_auto<<3);
+  WriteRAM(pProHW,pProslic->channel,PM_ACTIVE,
+           Si3228x_PulseMeter_Presets[preset].pm_active);
+  WriteRAM(pProHW,pProslic->channel,PM_INACTIVE,
+           Si3228x_PulseMeter_Presets[preset].pm_inactive);
+  WriteReg(pProHW,pProslic->channel,PMCON,reg);
+  return 0;
+}
+#endif
+/*
+** Function: PROSLIC_PCMSetup
+**
+** Description:
+** configure pcm
+*/
+#ifndef DISABLE_PCM_SETUP
+int Si3228x_PCMSetup (proslicChanType *pProslic, int preset)
+{
+  uInt8 regTemp;
+  uInt8 pmEn;
+
+  pmEn = ReadReg(pProHW,pProslic->channel,PMCON) & 0x01; /* PM/wideband lockout */
+  if (Si3228x_PCM_Presets[preset].widebandEn && pmEn)
+  {
+#ifdef ENABLE_DEBUG
+    LOGPRINT ("%s Wideband Mode is not supported while Pulse Metering is enabled.\n",
+              LOGPRINT_PREFIX);
+#endif
+  }
+  else if (Si3228x_PCM_Presets[preset].widebandEn && !pmEn)
+  {
+    /* TXIIR settings */
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_B0_1,0x3538E80L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_B1_1,0x3538E80L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_A1_1,0x1AA9100L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_B0_2,0x216D100L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_B1_2,0x2505400L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_B2_2,0x216D100L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_A1_2,0x2CB8100L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_A2_2,0x1D7FA500L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_B0_3,0x2CD9B00L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_B1_3,0x1276D00L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_B2_3,0x2CD9B00L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_A1_3,0x2335300L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_A2_3,0x19D5F700L);
+    /* RXIIR settings */
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_B0_1,0x6A71D00L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_B1_1,0x6A71D00L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_A1_1,0x1AA9100L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_B0_2,0x216D100L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_B1_2,0x2505400L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_B2_2,0x216D100L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_A1_2,0x2CB8100L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_A2_2,0x1D7FA500L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_B0_3,0x2CD9B00L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_B1_3,0x1276D00L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_B2_3,0x2CD9B00L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_A1_3,0x2335300L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_A2_3,0x19D5F700L);
+    /*
+    ** RXHPF
+    ** Note:  Calling ProSLIC_ZsynthSetup() will overwrite some
+    **        of these values.  ProSLIC_PCMSetup() should always
+    **        be called after loading coefficients when using
+    **        wideband mode
+    */
+    WriteRAM(pProHW,pProslic->channel,RXACHPF_B0_1,0x7CFF900L);
+    WriteRAM(pProHW,pProslic->channel,RXACHPF_B1_1,0x18300700L);
+    WriteRAM(pProHW,pProslic->channel,RXACHPF_A1_1,0x79FF201L);
+    WriteRAM(pProHW,pProslic->channel,RXACHPF_B0_2,0x7CEDA1DL);
+    WriteRAM(pProHW,pProslic->channel,RXACHPF_B1_2,0x106320D4L);
+    WriteRAM(pProHW,pProslic->channel,RXACHPF_B2_2,0x7CEDA1DL);
+    WriteRAM(pProHW,pProslic->channel,RXACHPF_A1_2,0xF9A910FL);
+    WriteRAM(pProHW,pProslic->channel,RXACHPF_A2_2,0x185FFDA8L);
+    WriteRAM(pProHW,pProslic->channel,RXACHPF_GAIN,0x08000000L);
+    /* TXHPF */
+    WriteRAM(pProHW,pProslic->channel,TXACHPF_B0_1,0x0C7FF4CEL);
+    WriteRAM(pProHW,pProslic->channel,TXACHPF_B1_1,0x13800B32L);
+    WriteRAM(pProHW,pProslic->channel,TXACHPF_A1_1,0x079FF201L);
+    WriteRAM(pProHW,pProslic->channel,TXACHPF_B0_2,0x030FDD10L);
+    WriteRAM(pProHW,pProslic->channel,TXACHPF_B1_2,0x19E0996CL);
+    WriteRAM(pProHW,pProslic->channel,TXACHPF_B2_2,0x030FDD10L);
+    WriteRAM(pProHW,pProslic->channel,TXACHPF_A1_2,0x0F9A910FL);
+    WriteRAM(pProHW,pProslic->channel,TXACHPF_A2_2,0x185FFDA8L);
+    WriteRAM(pProHW,pProslic->channel,TXACHPF_GAIN,0x0CD30000L);
+
+    regTemp = ReadReg(pProHW,pProslic->channel,DIGCON);
+#ifndef DISABLE_HPF_WIDEBAND
+    WriteReg(pProHW,pProslic->channel,DIGCON,regTemp&~(0xC)); /* Enable HPF */
+#else
+    WriteReg(pProHW,pProslic->channel,DIGCON,regTemp|(0xC)); /* Disable HPF */
+#endif
+    regTemp = ReadReg(pProHW,pProslic->channel,ENHANCE);
+    WriteReg(pProHW,pProslic->channel,ENHANCE,regTemp|1);
+  }
+  else
+  {
+    regTemp = ReadReg(pProHW,pProslic->channel,DIGCON);
+    WriteReg(pProHW,pProslic->channel,DIGCON,regTemp&~(0xC));
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_B0_1,0x3538E80L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_B1_1,0x3538E80L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_A1_1,0x1AA9100L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_B0_2,0x216D100L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_B1_2,0x2505400L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_B2_2,0x216D100L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_A1_2,0x2CB8100L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_A2_2,0x1D7FA500L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_B0_3,0x2CD9B00L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_B1_3,0x1276D00L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_B2_3,0x2CD9B00L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_A1_3,0x2335300L);
+    WriteRAM(pProHW,pProslic->channel,TXACIIR_A2_3,0x19D5F700L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_B0_1,0x6A71D00L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_B1_1,0x6A71D00L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_A1_1,0x1AA9100L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_B0_2,0x216D100L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_B1_2,0x2505400L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_B2_2,0x216D100L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_A1_2,0x2CB8100L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_A2_2,0x1D7FA500L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_B0_3,0x2CD9B00L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_B1_3,0x1276D00L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_B2_3,0x2CD9B00L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_A1_3,0x2335300L);
+    WriteRAM(pProHW,pProslic->channel,RXACIIR_A2_3,0x19D5F700L);
+    regTemp = ReadReg(pProHW,pProslic->channel,ENHANCE);
+    WriteReg(pProHW,pProslic->channel,ENHANCE,regTemp&~(1));
+  }
+  regTemp = Si3228x_PCM_Presets[preset].pcmFormat;
+  regTemp |= Si3228x_PCM_Presets[preset].pcm_tri << 5;
+  regTemp |= Si3228x_PCM_Presets[preset].alaw_inv << 2;
+  WriteReg(pProHW,pProslic->channel,PCMMODE,regTemp);
+  regTemp = ReadReg(pProHW,pProslic->channel,PCMTXHI);
+  regTemp &= 3;
+  regTemp |= Si3228x_PCM_Presets[preset].tx_edge<<4;
+  WriteReg(pProHW,pProslic->channel,PCMTXHI,regTemp);
+
+  return 0;
+}
+#endif
+
+/*
+**
+** PROSLIC CONTROL FUNCTIONS
+**
+*/
+
+/*
+** Function: PROSLIC_dbgSetDCFeed
+**
+** Description:
+** provisionary function for setting up
+** dcfeed given desired open circuit voltage
+** and loop current.
+*/
+int Si3228x_dbgSetDCFeed (proslicChanType *pProslic, uInt32 v_vlim_val,
+                          uInt32 i_ilim_val, int32 preset)
+{
+#ifndef DISABLE_DCFEED_SETUP
+
+  /* Note:  * needs more descriptive return codes in the event of an out of range argument */
+  uInt16 vslope = 160;
+  uInt16 rslope = 720;
+  uInt32 vscale1 = 1386;
+  uInt32 vscale2 =
+    1422;   /* 1386x1422 = 1970892 broken down to minimize trunc err */
+  uInt32 iscale1 = 913;
+  uInt32 iscale2 = 334;    /* 913x334 = 304942 */
+  uInt32 i_rfeed_val, v_rfeed_val, const_rfeed_val, i_vlim_val, const_ilim_val,
+         v_ilim_val;
+  int32 signedVal;
+  SILABS_UNREFERENCED_PARAMETER(pProslic);
+  /* Set Linefeed to open state before modifying DC Feed */
+
+  /* Assumptions must be made to minimize computations.  This limits the
+  ** range of available settings, but should be more than adequate for
+  ** short loop applications.
+  **
+  ** Assumtions:
+  **
+  ** SLOPE_VLIM      =>  160ohms
+  ** SLOPE_RFEED     =>  720ohms
+  ** I_RFEED         =>  3*I_ILIM/4
+  **
+  ** With these assumptions, the DC Feed parameters now become
+  **
+  ** Inputs:      V_VLIM, I_ILIM
+  ** Constants:   SLOPE_VLIM, SLOPE_ILIM, SLOPE_RFEED, SLOPE_DELTA1, SLOPE_DELTA2
+  ** Outputs:     V_RFEED, V_ILIM, I_VLIM, CONST_RFEED, CONST_ILIM
+  **
+  */
+
+  /* Validate arguments */
+  if((i_ilim_val < 15)||(i_ilim_val > 45))
+  {
+    return 1;  /* need error code */
+  }
+  if((v_vlim_val < 30)||(v_vlim_val > 52))
+  {
+    return 1;  /* need error code */
+  }
+
+  /* Calculate voltages in mV and currents in uA */
+  v_vlim_val *= 1000;
+  i_ilim_val *= 1000;
+
+  /* I_RFEED */
+  i_rfeed_val = (3*i_ilim_val)/4;
+
+  /* V_RFEED */
+  v_rfeed_val = v_vlim_val - (i_rfeed_val*vslope)/1000;
+
+  /* V_ILIM */
+  v_ilim_val = v_rfeed_val - (rslope*(i_ilim_val - i_rfeed_val))/1000;
+
+  /* I_VLIM */
+  i_vlim_val = (v_vlim_val*1000)/4903;
+
+  /* CONST_RFEED */
+  signedVal = v_rfeed_val * (i_ilim_val - i_rfeed_val);
+  signedVal /= (v_rfeed_val - v_ilim_val);
+  signedVal = i_rfeed_val + signedVal;
+
+  /* signedVal in uA here */
+  signedVal *= iscale1;
+  signedVal /= 100;
+  signedVal *= iscale2;
+  signedVal /= 10;
+
+  if(signedVal < 0)
+  {
+    const_rfeed_val = (signedVal)+ (1L<<29);
+  }
+  else
+  {
+    const_rfeed_val = signedVal & 0x1FFFFFFF;
+  }
+
+  /* CONST_ILIM */
+  const_ilim_val = i_ilim_val;
+
+  /* compute RAM values */
+  v_vlim_val *= vscale1;
+  v_vlim_val /= 100;
+  v_vlim_val *= vscale2;
+  v_vlim_val /= 10;
+
+  v_rfeed_val *= vscale1;
+  v_rfeed_val /= 100;
+  v_rfeed_val *= vscale2;
+  v_rfeed_val /= 10;
+
+  v_ilim_val *= vscale1;
+  v_ilim_val /= 100;
+  v_ilim_val *= vscale2;
+  v_ilim_val /= 10;
+
+  const_ilim_val *= iscale1;
+  const_ilim_val /= 100;
+  const_ilim_val *= iscale2;
+  const_ilim_val /= 10;
+
+  i_vlim_val *= iscale1;
+  i_vlim_val /= 100;
+  i_vlim_val *= iscale2;
+  i_vlim_val /= 10;
+
+  Si3228x_DCfeed_Presets[preset].slope_vlim = 0x18842BD7L;
+  Si3228x_DCfeed_Presets[preset].slope_rfeed = 0x1E8886DEL;
+  Si3228x_DCfeed_Presets[preset].slope_ilim = 0x40A0E0L;
+  Si3228x_DCfeed_Presets[preset].delta1 = 0x1EABA1BFL;
+  Si3228x_DCfeed_Presets[preset].delta2 = 0x1EF744EAL;
+  Si3228x_DCfeed_Presets[preset].v_vlim = v_vlim_val;
+  Si3228x_DCfeed_Presets[preset].v_rfeed = v_rfeed_val;
+  Si3228x_DCfeed_Presets[preset].v_ilim = v_ilim_val;
+  Si3228x_DCfeed_Presets[preset].const_rfeed = const_rfeed_val;
+  Si3228x_DCfeed_Presets[preset].const_ilim = const_ilim_val;
+  Si3228x_DCfeed_Presets[preset].i_vlim = i_vlim_val;
+
+  return RC_NONE;
+#else
+  SILABS_UNREFERENCED_PARAMETER(pProslic);
+  SILABS_UNREFERENCED_PARAMETER(v_vlim_val);
+  SILABS_UNREFERENCED_PARAMETER(i_ilim_val);
+  SILABS_UNREFERENCED_PARAMETER(preset);
+  return RC_IGNORE;
+#endif
+}
+
+/*
+** Function: PROSLIC_dbgSetDCFeedVopen
+**
+** Description:
+** provisionary function for setting up
+** dcfeed given desired open circuit voltage.
+** Entry I_ILIM value will be used.
+*/
+int Si3228x_dbgSetDCFeedVopen (proslicChanType *pProslic, uInt32 v_vlim_val,
+                               int32 preset)
+{
+#ifndef DISABLE_DCFEED_SETUP
+  uInt32 i_ilim_val;
+  uInt32 iscale1 = 913;
+  uInt32 iscale2 = 334;    /* 913x334 = 304942 */
+
+  /* Read present CONST_ILIM value */
+  i_ilim_val = Si3228x_DCfeed_Presets[preset].const_ilim;
+
+
+  i_ilim_val /= iscale2;
+  i_ilim_val /= iscale1;
+
+  return Si3228x_dbgSetDCFeed(pProslic,v_vlim_val,i_ilim_val,preset);
+#else
+  SILABS_UNREFERENCED_PARAMETER(pProslic);
+  SILABS_UNREFERENCED_PARAMETER(v_vlim_val);
+  SILABS_UNREFERENCED_PARAMETER(preset);
+  return RC_IGNORE;
+#endif
+}
+
+/*
+** Function: PROSLIC_dbgSetDCFeedIloop
+**
+** Description:
+** provisionary function for setting up
+** dcfeed given desired loop current.
+** Entry V_VLIM value will be used.
+*/
+int Si3228x_dbgSetDCFeedIloop (proslicChanType *pProslic, uInt32 i_ilim_val,
+                               int32 preset)
+{
+#ifndef DISABLE_DCFEED_SETUP
+  uInt32 v_vlim_val;
+  uInt32 vscale1 = 1386;
+  uInt32 vscale2 =
+    1422;   /* 1386x1422 = 1970892 broken down to minimize trunc err */
+
+  /* Read present V_VLIM value */
+  v_vlim_val = Si3228x_DCfeed_Presets[preset].v_vlim;
+
+  v_vlim_val /= vscale2;
+  v_vlim_val /= vscale1;
+
+  return Si3228x_dbgSetDCFeed(pProslic,v_vlim_val,i_ilim_val, preset);
+#else
+  SILABS_UNREFERENCED_PARAMETER(pProslic);
+  SILABS_UNREFERENCED_PARAMETER(i_ilim_val);
+  SILABS_UNREFERENCED_PARAMETER(preset);
+  return RC_IGNORE;
+#endif
+}
+
+typedef struct
+{
+  uInt8   freq;
+  ramData ringfr;      /* trise scale for trap */
+  uInt32  ampScale;
+} ProSLIC_SineRingFreqLookup;
+
+typedef struct
+{
+  uInt8    freq;
+  ramData  rtacth;
+  ramData rtper;
+  ramData rtdb;
+} ProSLIC_SineRingtripLookup;
+
+typedef struct
+{
+  uInt8   freq;
+  uInt16  cfVal[6];
+} ProSLIC_TrapRingFreqLookup;
+
+typedef struct
+{
+  uInt8   freq;
+  ramData rtper;
+  ramData rtdb;
+  uInt32  rtacth[6];
+} ProSLIC_TrapRingtripLookup;
+
+
+static const ProSLIC_SineRingFreqLookup sineRingFreqTable[] =
+    /*  Freq RINGFR, vScale */
+  {
+    {15, 0x7F6E930L, 18968L},
+    {16, 0x7F5A8E0L, 20234L},
+    {20, 0x7EFD9D5L, 25301L},
+    {22, 0x7EC770AL, 27843L},
+    {23, 0x7EAA6E2L, 29113L},
+    {25, 0x7E6C925L, 31649L},
+    {30, 0x7DBB96BL, 38014L},
+    {34, 0x7D34155L, 42270L}, /* Actually 33.33Hz */
+    {35, 0x7CEAD72L, 44397L},
+    {40, 0x7BFA887L, 50802L},
+    {45, 0x7AEAE74L, 57233L},
+    {50, 0x79BC384L, 63693L},
+    {0,0,0}
+  }; /* terminator */
+
+static const ProSLIC_SineRingtripLookup sineRingtripTable[] =
+    /*  Freq rtacth */
+  {
+    {15, 11440000L, 0x6A000L, 0x4000L },
+    {16, 10810000L, 0x64000L, 0x4000L },
+    {20, 8690000L,  0x50000L, 0x8000L },
+    {22, 7835000L,  0x48000L, 0x8000L },
+    {23, 7622000L,  0x46000L, 0x8000L },
+    {25, 6980000L,  0x40000L, 0xA000L },
+    {30, 5900000L,  0x36000L, 0xA000L },
+    {34, 10490000L, 0x60000L, 0x6000L }, /* Actually 33.33 */
+    {35, 10060000L, 0x5C000L, 0x6000L },
+    {40, 8750000L,  0x50000L, 0x8000L },
+    {45, 7880000L,  0x48000L, 0x8000L },
+    {50, 7010000L,  0x40000L, 0xA000L },
+    {0,0L, 0L, 0L}
+  }; /* terminator */
+
+static const ProSLIC_TrapRingFreqLookup trapRingFreqTable[] =
+    /*  Freq multCF11 multCF12 multCF13 multCF14 multCF15 multCF16*/
+  {
+    {15, {69,122, 163, 196, 222,244}},
+    {16, {65,115, 153, 184, 208,229}},
+    {20, {52,92, 122, 147, 167,183}},
+    {22, {47,83, 111, 134, 152,166}},
+    {23, {45,80, 107, 128, 145,159}},
+    {25, {42,73, 98, 118, 133,146}},
+    {30, {35,61, 82, 98, 111,122}},
+    {34, {31,55, 73, 88, 100,110}},
+    {35, {30,52, 70, 84, 95,104}},
+    {40, {26,46, 61, 73, 83,91}},
+    {45, {23,41, 54, 65, 74,81}},
+    {50, {21,37, 49, 59, 67,73}},
+    {0,{0L,0L,0L,0L}} /* terminator */
+  };
+
+
+static const ProSLIC_TrapRingtripLookup trapRingtripTable[] =
+    /*  Freq rtper rtdb rtacthCR11 rtacthCR12 rtacthCR13 rtacthCR14 rtacthCR15 rtacthCR16*/
+  {
+    {15, 0x6A000L,  0x4000L, {16214894L, 14369375L, 12933127L, 11793508L, 10874121L, 10121671L}},
+    {16, 0x64000L,  0x4000L, {15201463L, 13471289L, 12124806L, 11056414L, 10194489L, 9489067L}},
+    {20, 0x50000L,  0x6000L, {12161171L, 10777031L, 9699845L, 8845131L, 8155591L, 7591253L}},
+    {22, 0x48000L,  0x6000L, {11055610L, 9797301L, 8818041L, 8041028L, 7414174L, 6901139L}},
+    {23, 0x46000L,  0x6000L, {10574931L, 9371331L, 8434648L, 7691418L, 7091818L, 6601090L}},
+    {25, 0x40000L,  0x8000L, {9728937L, 8621625L, 7759876L, 7076105L, 6524473L, 6073003L}},
+    {30, 0x36000L,  0x8000L, {8107447L, 7184687L, 6466563L, 5896754L, 5437061L, 5060836L}},
+    {34, 0x60000L,  0x6000L, {7297432L, 6466865L, 5820489L, 5307609L, 4893844L, 4555208L}},
+    {35, 0x5C000L,  0x6000L, {6949240L, 6158303L, 5542769L, 5054361L, 4660338L, 4337859L}},
+    {40, 0x50000L,  0x6000L, {6080585L, 5388516L, 4849923L, 4422565L, 4077796L, 3795627L}},
+    {45, 0x48000L,  0x6000L, {5404965L, 4789792L, 4311042L, 3931169L, 3624707L, 3373890L}},
+    {50, 0x40000L,  0x8000L, {4864468L, 4310812L, 3879938L, 3538052L, 3262236L, 3036501L}},
+    {0,0x0L, 0x0L, {0L,0L,0L,0L}} /* terminator */
+  };
+
+
+/*
+** Function: PROSLIC_dbgRingingSetup
+**
+** Description:
+** Provision function for setting up
+** Ring type, frequency, amplitude and dc offset.
+** Main use will be by peek/poke applications.
+*/
+
+int Si3228x_dbgSetRinging (proslicChanType *pProslic,
+                           ProSLIC_dbgRingCfg *ringCfg, int preset)
+{
+#ifndef DISABLE_RING_SETUP  
+  int errVal,i=0;
+  uInt32 vScale = 1608872L;   /* (2^28/170.25)*((100+4903)/4903) */
+  ramData dcdcVminTmp;
+  
+  SILABS_UNREFERENCED_PARAMETER(pProslic);
+  errVal = 0;
+
+  switch(ringCfg->ringtype)
+  {
+    case ProSLIC_RING_SINE:
+      i=0;
+      do
+      {
+        if(sineRingFreqTable[i].freq >= ringCfg->freq)
+        {
+          break;
+        }
+        i++;
+      }
+      while (sineRingFreqTable[i].freq);
+
+      /* Set to maximum value if exceeding maximum value from table */
+      if(sineRingFreqTable[i].freq == 0)
+      {
+        i--;
+        errVal = 1;
+      }
+
+      /* Update RINGFR RINGAMP, RINGOFFSET, and RINGCON */
+      Si3228x_Ring_Presets[preset].freq = sineRingFreqTable[i].ringfr;
+      Si3228x_Ring_Presets[preset].amp = ringCfg->amp * sineRingFreqTable[i].ampScale;
+      Si3228x_Ring_Presets[preset].offset = ringCfg->offset * vScale;
+      Si3228x_Ring_Presets[preset].phas = 0L;
+
+      /* Don't alter anything in RINGCON other than clearing the TRAP bit */
+      Si3228x_Ring_Presets[preset].ringcon &= 0xFE;
+
+      Si3228x_Ring_Presets[preset].rtper = sineRingtripTable[i].rtper;
+      Si3228x_Ring_Presets[preset].rtacdb = sineRingtripTable[i].rtdb;
+      Si3228x_Ring_Presets[preset].rtdcdb = sineRingtripTable[i].rtdb;
+      Si3228x_Ring_Presets[preset].rtdcth = 0xFFFFFFFL;
+      Si3228x_Ring_Presets[preset].rtacth = sineRingtripTable[i].rtacth;
+      break;
+
+    case ProSLIC_RING_TRAP_CF11:
+    case ProSLIC_RING_TRAP_CF12:
+    case ProSLIC_RING_TRAP_CF13:
+    case ProSLIC_RING_TRAP_CF14:
+    case ProSLIC_RING_TRAP_CF15:
+    case ProSLIC_RING_TRAP_CF16:
+      /* If we're in SMART mode, we support Sinusoidal ringing only */
+      if(Si3228x_Ring_Presets[preset].smart_ring_phase != 0)
+      {
+        return RC_INVALID_PRESET;
+      }
+      i=0;
+      do
+      {
+        if(trapRingFreqTable[i].freq >= ringCfg->freq)
+        {
+          break;
+        }
+        i++;
+      }
+      while (trapRingFreqTable[i].freq);
+
+      /* Set to maximum value if exceeding maximum value from table */
+      if(trapRingFreqTable[i].freq == 0)
+      {
+        i--;
+        errVal = 1;
+      }
+
+      /* Update RINGFR RINGAMP, RINGOFFSET, and RINGCON */
+      Si3228x_Ring_Presets[preset].amp = ringCfg->amp * vScale;
+      Si3228x_Ring_Presets[preset].freq =
+        Si3228x_Ring_Presets[preset].amp/trapRingFreqTable[i].cfVal[ringCfg->ringtype];
+      Si3228x_Ring_Presets[preset].offset = ringCfg->offset * vScale;
+      Si3228x_Ring_Presets[preset].phas = 262144000L/trapRingFreqTable[i].freq;
+
+      /* Don't alter anything in RINGCON other than setting the TRAP bit */
+      Si3228x_Ring_Presets[preset].ringcon |= 0x01;
+
+      /* RTPER and debouce timers  */
+      Si3228x_Ring_Presets[preset].rtper = trapRingtripTable[i].rtper;
+      Si3228x_Ring_Presets[preset].rtacdb = trapRingtripTable[i].rtdb;
+      Si3228x_Ring_Presets[preset].rtdcdb = trapRingtripTable[i].rtdb;
+
+
+      Si3228x_Ring_Presets[preset].rtdcth = 0xFFFFFFFL;
+      Si3228x_Ring_Presets[preset].rtacth =
+        trapRingtripTable[i].rtacth[ringCfg->ringtype];
+
+
+      break;
+  }
+
+  /*
+  ** DCDC tracking sluggish under light load at higher ring freq.
+  ** Reduce tracking depth above 40Hz.
+  */
+  if( sineRingFreqTable[i].freq >= 40 )
+  {
+    dcdcVminTmp = ringCfg->amp + ringCfg->offset;
+    dcdcVminTmp *= 1000;
+    dcdcVminTmp *= SCALE_V_MADC;
+    Si3228x_Ring_Presets[preset].vbat_track_min_rng = dcdcVminTmp;
+  }
+  else
+  {
+    Si3228x_Ring_Presets[preset].vbat_track_min_rng = 0x1800000L;
+  }
+
+  return errVal;
+#else
+  SILABS_UNREFERENCED_PARAMETER(pProslic);
+  SILABS_UNREFERENCED_PARAMETER(ringCfg);
+  SILABS_UNREFERENCED_PARAMETER(preset);
+  return RC_IGNORE;
+#endif
+}
+
+
+typedef struct
+{
+  int32   gain;
+  uInt32 scale;
+} ProSLIC_GainScaleLookup;
+
+#ifndef ENABLE_HIRES_GAIN
+static int Si3228x_dbgSetGain (proslicChanType *pProslic, int32 gain,
+                               int impedance_preset, int tx_rx_sel)
+{
+  int errVal = 0;
+  int32 i;
+  int32 gain_pga, gain_eq;
+  const ProSLIC_GainScaleLookup gainScaleTable[]
+  =  /*  gain, scale=10^(gain/20) */
+  {
+    {-30, 32},
+    {-29, 35},
+    {-28, 40},
+    {-27, 45},
+    {-26, 50},
+    {-25, 56},
+    {-24, 63},
+    {-23, 71},
+    {-22, 79},
+    {-21, 89},
+    {-20, 100},
+    {-19, 112},
+    {-18, 126},
+    {-17, 141},
+    {-16, 158},
+    {-15, 178},
+    {-14, 200},
+    {-13, 224},
+    {-12, 251},
+    {-11, 282},
+    {-10, 316},
+    {-9, 355},
+    {-8, 398},
+    {-7, 447},
+    {-6, 501},
+    {-5, 562},
+    {-4, 631},
+    {-3, 708},
+    {-2, 794},
+    {-1, 891},
+    {0, 1000},
+    {1, 1122},
+    {2, 1259},
+    {3, 1413},
+    {4, 1585},
+    {5, 1778},
+    {6, 1995},
+    {0xff,0}  /* terminator */
+  };
+
+  SILABS_UNREFERENCED_PARAMETER(pProslic);
+
+  /*
+  ** 5.4.0 - Removed relative gain scaling. to support automatic adjustment based on
+  **         gain plan provided in txgain_db and rxgain_db.  It is presumed that all
+  **         coefficients were generated for 0dB/0dB gain and the txgain_db and rxgain_db
+  **         parameters will be used to scale the gain using the existing gain provisioning
+  **         infrastructure when the zsynth preset is loaded.  This function will ignore
+  **         the txgain_db and rxgain_db parameters and scale absolute gain presuming a
+  **         0dB/0dB coefficient set.
+  */
+  /*
+  ** 6.0.0 - Modifying where gain/attenuation is placed to minimize clipping.
+  **
+  **         RX Path:   -30dB < gain <  0dB -   All in RXACGAIN
+  **                      0dB < gain <  6dB -   All in RXACEQ
+  **
+  **         TX Path:   -30dB < gain <  0dB -   All in TXACEQ
+  **                      0dB < gain <  6dB -   All in TXACGAIN
+  */
+  /* Test against max gain */
+  if (gain > PROSLIC_EXTENDED_GAIN_MAX)
+  {
+    errVal = RC_GAIN_OUT_OF_RANGE;
+#ifdef ENABLE_DEBUG
+    if(pProslic->debugMode)
+    {
+      LOGPRINT("%sdbgSetGain : Gain %d out of range\n", LOGPRINT_PREFIX, (int)gain);
+    }
+#endif
+    gain = PROSLIC_EXTENDED_GAIN_MAX; /* Clamp to maximum */
+  }
+
+  /* Test against min gain */
+  if (gain < PROSLIC_GAIN_MIN)
+  {
+    errVal = RC_GAIN_OUT_OF_RANGE;
+#ifdef ENABLE_DEBUG
+    if(pProslic->debugMode)
+    {
+      LOGPRINT("%sdbgSetGain : Gain %d out of range\n", LOGPRINT_PREFIX, (int)gain);
+    }
+#endif
+    gain = PROSLIC_GAIN_MIN; /* Clamp to minimum */
+  }
+
+  /* Distribute gain */
+  if(gain == 0)
+  {
+    gain_pga = 0;
+    gain_eq = 0;
+  }
+  else if(gain > PROSLIC_GAIN_MAX)
+  {
+    if(tx_rx_sel == TXACGAIN_SEL)
+    {
+      gain_pga = PROSLIC_GAIN_MAX;
+      gain_eq = gain - PROSLIC_GAIN_MAX;
+    }
+    else
+    {
+      gain_pga = gain - PROSLIC_GAIN_MAX;
+      gain_eq = PROSLIC_GAIN_MAX;
+    }
+  }
+  else if(gain > 0)
+  {
+    if(tx_rx_sel == TXACGAIN_SEL)
+    {
+      gain_pga = gain;
+      gain_eq  = 0;
+    }
+    else
+    {
+      gain_pga = 0;
+      gain_eq = gain;
+    }
+  }
+  else
+  {
+    if(tx_rx_sel == TXACGAIN_SEL)
+    {
+      gain_pga = 0;
+      gain_eq  = gain;
+    }
+    else
+    {
+      gain_pga = gain;
+      gain_eq = 0;
+    }
+
+  }
+
+  /*
+  ** Lookup PGA Appropriate PGA Gain
+  */
+  i=0;
+  do
+  {
+    if(gainScaleTable[i].gain >= gain_pga)
+    {
+      break;
+    }
+    i++;
+  }
+  while (gainScaleTable[i].gain!=0xff);
+
+  /* Set to maximum value if exceeding maximum value from table */
+  if(gainScaleTable[i].gain == 0xff)
+  {
+    i--;
+    errVal = RC_GAIN_DELTA_TOO_LARGE;
+  }
+
+  if(tx_rx_sel == TXACGAIN_SEL)
+  {
+    Si3228x_audioGain_Presets[0].acgain =
+      (Si3228x_Impedance_Presets[impedance_preset].txgain/1000)
+      *gainScaleTable[i].scale;
+  }
+  else
+  {
+    Si3228x_audioGain_Presets[1].acgain =
+      (Si3228x_Impedance_Presets[impedance_preset].rxgain/1000)
+      *gainScaleTable[i].scale;
+  }
+
+  /*
+  ** Lookup EQ Gain
+  */
+  i=0;
+  do
+  {
+    if(gainScaleTable[i].gain >= gain_eq)
+    {
+      break;
+    }
+    i++;
+  }
+  while (gainScaleTable[i].gain!=0xff);
+
+  /* Set to maximum value if exceeding maximum value from table */
+  if(gainScaleTable[i].gain == 0xff)
+  {
+    i--;
+    errVal = RC_GAIN_DELTA_TOO_LARGE;
+  }
+
+  if(tx_rx_sel == TXACGAIN_SEL)
+  {
+    /*sign extend negative numbers*/
+    if (Si3228x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c0 & 0x10000000L)
+    {
+      Si3228x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c0 |= 0xf0000000L;
+    }
+    if (Si3228x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c1 & 0x10000000L)
+    {
+      Si3228x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c1 |= 0xf0000000L;
+    }
+    if (Si3228x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c2 & 0x10000000L)
+    {
+      Si3228x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c2 |= 0xf0000000L;
+    }
+    if (Si3228x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c3 & 0x10000000L)
+    {
+      Si3228x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c3 |= 0xf0000000L;
+    }
+
+    Si3228x_audioGain_Presets[0].aceq_c0 = ((int32)
+                                            Si3228x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c0/1000)
+                                           *gainScaleTable[i].scale;
+    Si3228x_audioGain_Presets[0].aceq_c1 = ((int32)
+                                            Si3228x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c1/1000)
+                                           *gainScaleTable[i].scale;
+    Si3228x_audioGain_Presets[0].aceq_c2 = ((int32)
+                                            Si3228x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c2/1000)
+                                           *gainScaleTable[i].scale;
+    Si3228x_audioGain_Presets[0].aceq_c3 = ((int32)
+                                            Si3228x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c3/1000)
+                                           *gainScaleTable[i].scale;
+  }
+  else
+  {
+    /*sign extend negative numbers*/
+    if (Si3228x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c0 & 0x10000000L)
+    {
+      Si3228x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c0 |= 0xf0000000L;
+    }
+    if (Si3228x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c1 & 0x10000000L)
+    {
+      Si3228x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c1 |= 0xf0000000L;
+    }
+    if (Si3228x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c2 & 0x10000000L)
+    {
+      Si3228x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c2 |= 0xf0000000L;
+    }
+    if (Si3228x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c3 & 0x10000000L)
+    {
+      Si3228x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c3 |= 0xf0000000L;
+    }
+
+    Si3228x_audioGain_Presets[1].aceq_c0 = ((int32)
+                                            Si3228x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c0/1000)
+                                           *gainScaleTable[i].scale;
+    Si3228x_audioGain_Presets[1].aceq_c1 = ((int32)
+                                            Si3228x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c1/1000)
+                                           *gainScaleTable[i].scale;
+    Si3228x_audioGain_Presets[1].aceq_c2 = ((int32)
+                                            Si3228x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c2/1000)
+                                           *gainScaleTable[i].scale;
+    Si3228x_audioGain_Presets[1].aceq_c3 = ((int32)
+                                            Si3228x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c3/1000)
+                                           *gainScaleTable[i].scale;
+  }
+
+
+  return errVal;
+}
+
+#else /* ENABLE_HIRES_GAIN */
+/* Same as Si3228x_dbgSetGain() except gain is expressed in dB*10 to achieve 0.1dB resolution */
+static int Si3228x_dbgSetGainHiRes (proslicChanType *pProslic, int32 gain,
+                                    int impedance_preset, int tx_rx_sel)
+{
+  int errVal = 0;
+  int32 i;
+  int32 coarseGainIndex, fineGainIndex;
+  int32 gain_pga, gain_eq;
+  int32 coarseGain, fineGain;
+  int32 tmp;
+  const ProSLIC_GainScaleLookup coarseGainScaleTable[]
+  =  /*  gain, scale=10^(gain/20) */
+  {
+    {-30, 32},
+    {-29, 35},
+    {-28, 40},
+    {-27, 45},
+    {-26, 50},
+    {-25, 56},
+    {-24, 63},
+    {-23, 71},
+    {-22, 79},
+    {-21, 89},
+    {-20, 100},
+    {-19, 112},
+    {-18, 126},
+    {-17, 141},
+    {-16, 158},
+    {-15, 178},
+    {-14, 200},
+    {-13, 224},
+    {-12, 251},
+    {-11, 282},
+    {-10, 316},
+    {-9, 355},
+    {-8, 398},
+    {-7, 447},
+    {-6, 501},
+    {-5, 562},
+    {-4, 631},
+    {-3, 708},
+    {-2, 794},
+    {-1, 891},
+    {0, 1000},
+    {1, 1122},
+    {2, 1259},
+    {3, 1413},
+    {4, 1585},
+    {5, 1778},
+    {6, 1995},
+    {0xff,0}  /* terminator */
+  };
+
+  const ProSLIC_GainScaleLookup fineGainScaleTable[]
+  =  /*  gain, scale=10^(gain/20) */
+  {
+    {-9, 902},
+    {-8, 912},
+    {-7, 923},
+    {-6, 933},
+    {-5, 944},
+    {-4, 955},
+    {-3, 966},
+    {-2, 977},
+    {-1, 989},
+    {0, 1000},
+    {1, 1012},
+    {2, 1023},
+    {3, 1035},
+    {4, 1047},
+    {5, 1059},
+    {6, 1072},
+    {7, 1084},
+    {8, 1096},
+    {9, 1109},
+    {0xff,0}  /* terminator */
+  };
+
+  /*
+  ** 6.0.0 - Modifying where gain/attenuation is placed to minimize clipping.
+  **
+  **         RX Path:   -30dB < gain <  0dB -   All in RXACGAIN
+  **                      0dB < gain <  6dB -   All in RXACEQ
+  **
+  **         TX Path:   -30dB < gain <  0dB -   All in TXACEQ
+  **                      0dB < gain <  6dB -   All in TXACGAIN
+  **
+  ** 6.2.1 - Added option for fine gain adjust.  All fine adjustment done
+  **         in RXACGAIN and TXACEQ
+  */
+
+  SILABS_UNREFERENCED_PARAMETER(pProslic);
+  /* Test against max gain */
+  if (gain > (PROSLIC_GAIN_MAX*10L))
+  {
+    errVal = RC_GAIN_OUT_OF_RANGE;
+#ifdef ENABLE_DEBUG
+    if(pProslic->debugMode)
+    {
+      LOGPRINT("%s dbgSetGain : Gain %d dB*10 out of range\n", LOGPRINT_PREFIX, gain);
+    }
+#endif
+    gain = (PROSLIC_GAIN_MAX*10L); /* Clamp to maximum */
+  }
+
+  /* Test against min gain */
+  if (gain < (PROSLIC_GAIN_MIN*10L))
+  {
+    errVal = RC_GAIN_OUT_OF_RANGE;
+#ifdef ENABLE_DEBUG
+    if(pProslic->debugMode)
+    {
+      LOGPRINT("%sdbgSetGain : Gain %d dB*10 out of range\n", LOGPRINT_PREFIX, gain);
+    }
+#endif
+    gain = (PROSLIC_GAIN_MIN*10); /* Clamp to minimum */
+  }
+
+  /* Distribute gain */
+  coarseGain = gain/10L;
+  fineGain = gain - (coarseGain*10L);
+
+  /* Distribute coarseGain */
+  if(coarseGain == 0)
+  {
+    gain_pga = 0;
+    gain_eq = 0;
+  }
+  else if(coarseGain > 0)
+  {
+    if(tx_rx_sel == TXACGAIN_SEL)
+    {
+      gain_pga = coarseGain;
+      gain_eq  = 0;
+    }
+    else
+    {
+      gain_pga = 0;
+      gain_eq = coarseGain;
+    }
+  }
+  else
+  {
+    if(tx_rx_sel == TXACGAIN_SEL)
+    {
+      gain_pga = 0;
+      gain_eq  = coarseGain;
+    }
+    else
+    {
+      gain_pga = coarseGain;
+      gain_eq = 0;
+    }
+  }
+
+  /*
+  ** Lookup PGA Appopriate PGA Gain
+  */
+  i=0;
+  do
+  {
+    if(coarseGainScaleTable[i].gain >= gain_pga)
+    {
+      break;
+    }
+    i++;
+  }
+  while (coarseGainScaleTable[i].gain!=0xff);
+
+  /* Set to maximum value if exceeding maximum value from table */
+  if(coarseGainScaleTable[i].gain == 0xff)
+  {
+    i--;
+    errVal = RC_GAIN_DELTA_TOO_LARGE;
+  }
+
+  coarseGainIndex = i;  /* Store coarse index */
+
+  /* Find fineGain */
+  i = 0;
+  do
+  {
+    if(fineGainScaleTable[i].gain >= fineGain)
+    {
+      break;
+    }
+    i++;
+  }
+  while (fineGainScaleTable[i].gain!=0xff);
+
+  /* Set to maximum value if exceeding maximum value from table */
+  if(fineGainScaleTable[i].gain == 0xff)
+  {
+    i--;
+    errVal = RC_GAIN_DELTA_TOO_LARGE;
+  }
+
+  fineGainIndex = i;
+
+  if(tx_rx_sel == TXACGAIN_SEL)
+  {
+    Si3228x_audioGain_Presets[0].acgain = ((
+        Si3228x_Impedance_Presets[impedance_preset].txgain/1000L)
+                                           *coarseGainScaleTable[coarseGainIndex].scale); /* /1000L * fineGainScaleTable[fineGainIndex].scale; */
+  }
+  else
+  {
+    Si3228x_audioGain_Presets[1].acgain = ((
+        Si3228x_Impedance_Presets[impedance_preset].rxgain/1000L)
+                                           *coarseGainScaleTable[coarseGainIndex].scale)/1000L *
+                                          fineGainScaleTable[fineGainIndex].scale;
+  }
+
+  /*
+  ** Lookup EQ Gain
+  */
+  i=0;
+  do
+  {
+    if(coarseGainScaleTable[i].gain >= gain_eq)
+    {
+      break;
+    }
+    i++;
+  }
+  while (coarseGainScaleTable[i].gain!=0xff);
+
+  /* Set to maximum value if exceeding maximum value from table */
+  if(coarseGainScaleTable[i].gain == 0xff)
+  {
+    i--;
+    errVal = RC_GAIN_DELTA_TOO_LARGE;
+  }
+
+  coarseGainIndex = i;  /* Store coarse index */
+
+  if(tx_rx_sel == TXACGAIN_SEL)
+  {
+    /*sign extend negative numbers*/
+    if (Si3228x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c0 & 0x10000000L)
+    {
+      Si3228x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c0 |= 0xf0000000L;
+    }
+    if (Si3228x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c1 & 0x10000000L)
+    {
+      Si3228x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c1 |= 0xf0000000L;
+    }
+    if (Si3228x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c2 & 0x10000000L)
+    {
+      Si3228x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c2 |= 0xf0000000L;
+    }
+    if (Si3228x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c3 & 0x10000000L)
+    {
+      Si3228x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c3 |= 0xf0000000L;
+    }
+
+    tmp = (((int32)
+            Si3228x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c0/1000L)
+           *coarseGainScaleTable[coarseGainIndex].scale);
+    tmp = tmp / (int32)1000L;
+    tmp = tmp * (int32)fineGainScaleTable[fineGainIndex].scale;
+    Si3228x_audioGain_Presets[0].aceq_c0 = tmp;
+
+    tmp = (((int32)
+            Si3228x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c1/1000L)
+           *coarseGainScaleTable[coarseGainIndex].scale);
+    tmp = tmp / (int32)1000L;
+    tmp = tmp * (int32)fineGainScaleTable[fineGainIndex].scale;
+    Si3228x_audioGain_Presets[0].aceq_c1 = tmp;
+
+    tmp = (((int32)
+            Si3228x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c2/1000L)
+           *coarseGainScaleTable[coarseGainIndex].scale);
+    tmp = tmp / (int32)1000L;
+    tmp = tmp * (int32)fineGainScaleTable[fineGainIndex].scale;
+    Si3228x_audioGain_Presets[0].aceq_c2 = tmp;
+
+    tmp = (((int32)
+            Si3228x_Impedance_Presets[impedance_preset].audioEQ.txaceq_c3/1000L)
+           *coarseGainScaleTable[coarseGainIndex].scale);
+    tmp = tmp / (int32)1000L;
+    tmp = tmp * (int32)fineGainScaleTable[fineGainIndex].scale;
+    Si3228x_audioGain_Presets[0].aceq_c3 = tmp;
+  }
+  else
+  {
+    /*sign extend negative numbers*/
+    if (Si3228x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c0 & 0x10000000L)
+    {
+      Si3228x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c0 |= 0xf0000000L;
+    }
+    if (Si3228x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c1 & 0x10000000L)
+    {
+      Si3228x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c1 |= 0xf0000000L;
+    }
+    if (Si3228x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c2 & 0x10000000L)
+    {
+      Si3228x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c2 |= 0xf0000000L;
+    }
+    if (Si3228x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c3 & 0x10000000L)
+    {
+      Si3228x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c3 |= 0xf0000000L;
+    }
+
+    Si3228x_audioGain_Presets[1].aceq_c0 = ((int32)
+                                            Si3228x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c0/1000)
+                                           *coarseGainScaleTable[i].scale;
+    Si3228x_audioGain_Presets[1].aceq_c1 = ((int32)
+                                            Si3228x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c1/1000)
+                                           *coarseGainScaleTable[i].scale;
+    Si3228x_audioGain_Presets[1].aceq_c2 = ((int32)
+                                            Si3228x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c2/1000)
+                                           *coarseGainScaleTable[i].scale;
+    Si3228x_audioGain_Presets[1].aceq_c3 = ((int32)
+                                            Si3228x_Impedance_Presets[impedance_preset].audioEQ.rxaceq_c3/1000)
+                                           *coarseGainScaleTable[i].scale;
+  }
+
+
+  return errVal;
+}
+#endif
+/*
+** Function: PROSLIC_dbgSetTXGain
+**
+** Description:
+** Provisionary function for setting up
+** TX gain
+*/
+int Si3228x_dbgSetTXGain (proslicChanType *pProslic, int32 gain,
+                          int impedance_preset, int audio_gain_preset)
+{
+#ifdef ENABLE_HIRES_GAIN
+  return Si3228x_dbgSetGainHiRes(pProslic,gain,impedance_preset,
+                                 audio_gain_preset);
+#else
+  return Si3228x_dbgSetGain(pProslic,gain,impedance_preset,audio_gain_preset);
+#endif
+}
+
+/*
+** Function: PROSLIC_dbgSetRXGain
+**
+** Description:
+** Provisionary function for setting up
+** RX gain
+*/
+int Si3228x_dbgSetRXGain (proslicChanType *pProslic, int32 gain,
+                          int impedance_preset, int audio_gain_preset)
+{
+#ifdef ENABLE_HIRES_GAIN
+  return Si3228x_dbgSetGainHiRes(pProslic,gain,impedance_preset,
+                                 audio_gain_preset);
+#else
+  return Si3228x_dbgSetGain(pProslic,gain,impedance_preset,audio_gain_preset);
+#endif
+}
+
+
+/*
+** Function: Si3228x_LineMonitor
+**
+** Description:
+** Monitor line voltages and currents
+*/
+int Si3228x_LineMonitor(proslicChanType *pProslic, proslicMonitorType *monitor)
+{
+  if(pProslic->channelEnable)
+  {
+    monitor->vtr    = ReadRAM(pProHW,pProslic->channel,VDIFF_FILT);
+    if(monitor->vtr & 0x10000000L)
+    {
+      monitor->vtr |= 0xf0000000L;
+    }
+    monitor->vtr /= SCALE_V_MADC;
+
+    monitor->vtip    = ReadRAM(pProHW,pProslic->channel,VTIP);
+    if(monitor->vtip & 0x10000000L)
+    {
+      monitor->vtip |= 0xf0000000L;
+    }
+    monitor->vtip /= SCALE_V_MADC;
+
+    monitor->vring    = ReadRAM(pProHW,pProslic->channel,VRING);
+    if(monitor->vring & 0x10000000L)
+    {
+      monitor->vring |= 0xf0000000L;
+    }
+    monitor->vring /= SCALE_V_MADC;
+
+    monitor->vlong    = ReadRAM(pProHW,pProslic->channel,MADC_VLONG);
+    if(monitor->vlong & 0x10000000L)
+    {
+      monitor->vlong |= 0xf0000000L;
+    }
+    monitor->vlong /= SCALE_V_MADC;
+
+    monitor->vbat    = ReadRAM(pProHW,pProslic->channel,MADC_VBAT);
+    if(monitor->vbat & 0x10000000L)
+    {
+      monitor->vbat |= 0xf0000000L;
+    }
+    monitor->vbat /= SCALE_V_MADC;
+
+    monitor->vdc = 0; /* Si3228x has no SVDC */
+
+    monitor->itr  = ReadRAM(pProHW,pProslic->channel,MADC_ILOOP);
+    if(monitor->itr & 0x10000000L)
+    {
+      monitor->itr |= 0xf0000000L;
+    }
+    monitor->itr /= SCALE_I_MADC;
+
+    monitor->itip  = ReadRAM(pProHW,pProslic->channel,MADC_ITIP);
+    if(monitor->itip & 0x10000000L)
+    {
+      monitor->itip |= 0xf0000000L;
+    }
+    monitor->itip /= SCALE_I_MADC;
+
+    monitor->iring  = ReadRAM(pProHW,pProslic->channel,MADC_IRING);
+    if(monitor->iring & 0x10000000L)
+    {
+      monitor->iring |= 0xf0000000L;
+    }
+    monitor->iring /= SCALE_I_MADC;
+
+    monitor->ilong  = ReadRAM(pProHW,pProslic->channel,MADC_ILONG);
+    if(monitor->ilong & 0x10000000L)
+    {
+      monitor->ilong |= 0xf0000000L;
+    }
+    monitor->ilong /= SCALE_I_MADC;
+
+    monitor->p_hvic  = ReadRAM(pProHW,pProslic->channel,P_Q1_D); /* P_HVIC_LPF */
+    if(monitor->p_hvic & 0x10000000L)
+    {
+      monitor->p_hvic |= 0xf0000000L;
+    }
+    monitor->p_hvic /= SCALE_P_MADC;
+
+  }
+
+  return 0;
+}
+
+/*
+** Function: Si3228x_PSTNCheck
+**
+** Description:
+** Continuous monitoring of longitudinal current.
+** If an average of N samples exceed avgThresh or a
+** single sample exceeds singleThresh, the linefeed
+** is forced into the open state.
+**
+** This protects the port from connecting to a live
+** pstn line (faster than power alarm).
+**
+** TODO:  need error handling
+*/
+int Si3228x_PSTNCheck (proslicChanType *pProslic,
+                       proslicPSTNCheckObjType *pPSTNCheck)
+{
+  uInt8 i;
+
+  if(pPSTNCheck->samples == 0)
+  {
+    return RC_NONE;
+  }
+
+  /* Adjust buffer index */
+  if(pPSTNCheck->count >= pPSTNCheck->samples)
+  {
+    pPSTNCheck->buffFull = TRUE;
+    pPSTNCheck->count = 0;   /* reset buffer ptr */
+  }
+
+  /* Read next sample */
+  pPSTNCheck->ilong[pPSTNCheck->count]  = ReadRAM(pProHW,pProslic->channel,
+                                          MADC_ILONG);
+  if(pPSTNCheck->ilong[pPSTNCheck->count] & 0x10000000L)
+  {
+    pPSTNCheck->ilong[pPSTNCheck->count] |= 0xf0000000L;
+  }
+  pPSTNCheck->ilong[pPSTNCheck->count] /= SCALE_I_MADC;
+
+  /* Monitor magnitude only */
+  if(pPSTNCheck->ilong[pPSTNCheck->count] < 0)
+  {
+    pPSTNCheck->ilong[pPSTNCheck->count] = -pPSTNCheck->ilong[pPSTNCheck->count];
+  }
+
+  /* Quickly test for single measurement violation */
+  if(pPSTNCheck->ilong[pPSTNCheck->count] > pPSTNCheck->singleThresh)
+  {
+    return 1;  /* fail */
+  }
+
+  /* Average once buffer is full */
+  if(pPSTNCheck->buffFull == TRUE)
+  {
+    pPSTNCheck->avgIlong = 0;
+    for(i=0; i<pPSTNCheck->samples; i++)
+    {
+      pPSTNCheck->avgIlong += pPSTNCheck->ilong[i];
+    }
+    pPSTNCheck->avgIlong /= pPSTNCheck->samples;
+
+    if(pPSTNCheck->avgIlong > pPSTNCheck->avgThresh)
+    {
+      /* reinit obj and return fail */
+      pPSTNCheck->count = 0;
+      pPSTNCheck->buffFull = FALSE;
+      return 1;
+    }
+    else
+    {
+      pPSTNCheck->count++;
+      return 0;
+    }
+  }
+  else
+  {
+    pPSTNCheck->count++;
+    return 0;
+  }
+}
+
+
+
+/*
+** Function: Si3228x_GetRAMScale
+**
+** Description:
+** Read scale factor for passed RAM location
+**
+** Return Value:
+** int32 scale
+*/
+static int32 Si3228x_GetRAMScale(uInt16 addr)
+{
+  int32 scale;
+
+  switch(addr)
+  {
+    case MADC_ILOOP:
+    case MADC_ITIP:
+    case MADC_IRING:
+    case MADC_ILONG:
+      scale = SCALE_I_MADC;
+      break;
+
+    case MADC_VTIPC:
+    case MADC_VRINGC:
+    case MADC_VBAT:
+    case MADC_VLONG:
+    case MADC_VDC:
+    case MADC_VDC_OS:
+    case VDIFF_SENSE:
+    case VDIFF_FILT:
+    case VDIFF_COARSE:
+    case VTIP:
+    case VRING:
+    case SI3228X_PRAM_VBATH_NEON:
+      scale = SCALE_V_MADC;
+      break;
+
+    case P_HVIC:
+    case P_Q1_D:   /* P_HVIC_LPF */
+      scale = SCALE_P_MADC;
+      break;
+    default:
+      scale = 1;
+      break;
+  }
+
+  return scale;
+}
+
+/*
+** Function: Si3228x_ReadMADCScaled
+**
+** Description:
+** Read MADC (or other sensed voltages/currents) and
+** return scaled value in int32 format.
+**
+** Return Value:
+** int32 voltage in mV or
+** int32 current in uA
+*/
+int32 Si3228x_ReadMADCScaled(proslicChanType_ptr pProslic,uInt16 addr,
+                             int32 scale)
+{
+  int32 data;
+
+  /*
+  ** Read 29-bit RAM and sign extend to 32-bits
+  */
+  data = ReadRAM(pProHW,pProslic->channel,addr);
+  if(data & 0x10000000L)
+  {
+    data |= 0xF0000000L;
+  }
+
+  /*
+  ** Scale to provided value, or use defaults if scale = 0
+  */
+  if(scale == 0)
+  {
+    scale = Si3228x_GetRAMScale(addr);
+  }
+
+  data /= scale;
+
+  return data;
+}
+
+#ifdef PSTN_DET_ENABLE
+/*
+** Function: abs_int32
+**
+** Description:
+** abs implementation for int32 type
+*/
+static int32 abs_int32(int32 a)
+{
+  if(a < 0)
+  {
+    return -1*a;
+  }
+  return a;
+}
+
+/*
+** Function: Si3228x_DiffPSTNCheck
+**
+** Description:
+** Monitor for excessive longitudinal current, which
+** would be present if a live pstn line was connected
+** to the port.
+**
+** Returns:
+** RC_NONE             - test in progress
+** RC_COMPLETE_NO_ERR  - test complete, no alarms or errors
+** RC_PSTN_OPEN_FEMF   - test detected foreign voltage
+**
+*/
+
+int Si3228x_DiffPSTNCheck (proslicChanType *pProslic,
+                           proslicDiffPSTNCheckObjType *pPSTNCheck)
+{
+  uInt8 loop_status;
+  int i;
+
+  if(pProslic->channelType != PROSLIC)
+  {
+    return RC_CHANNEL_TYPE_ERR;    /* Ignore DAA channels */
+  }
+
+
+  switch(pPSTNCheck->pState.stage)
+  {
+    case 0:
+      /* Optional OPEN foreign voltage measurement - only execute if LCS = 0 */
+      /* Disable low power mode */
+      pPSTNCheck->enhanceRegSave = ReadReg(pProHW,pProslic->channel,ENHANCE);
+      if(pProslic->deviceId->chipRev != 0)    /* must stay in pwrsave mode on rev A */
+      {
+        WriteReg(pProHW,pProslic->channel, ENHANCE,
+                 pPSTNCheck->enhanceRegSave&0x07); /* Disable powersave */
+      }
+      pPSTNCheck->vdiff1_avg = 0;
+      pPSTNCheck->vdiff2_avg = 0;
+      pPSTNCheck->iloop1_avg = 0;
+      pPSTNCheck->iloop2_avg = 0;
+      pPSTNCheck->return_status = RC_COMPLETE_NO_ERR;
+      /* Do OPEN state hazardous voltage measurement if enabled and ONHOOK */
+      ProSLIC_ReadHookStatus(pProslic,&loop_status);
+      if((loop_status == PROSLIC_ONHOOK)&&(pPSTNCheck->femf_enable == 1))
+      {
+        pPSTNCheck->pState.stage++;
+      }
+      else
+      {
+        pPSTNCheck->pState.stage = 10;
+      }
+      return RC_NONE;
+
+    case 1:
+      /* Change linefeed to OPEN state for HAZV measurement, setup coarse sensors */
+      pPSTNCheck->lfstate_entry = ReadReg(pProHW,pProslic->channel, LINEFEED);
+      ProSLIC_SetLinefeedStatus(pProslic,LF_OPEN);
+      pPSTNCheck->pState.stage++;
+      return RC_NONE;
+
+    case 2:
+      /* Settle */
+      ProSLIC_PSTN_delay_poll(&(pPSTNCheck->pState), PSTN_DET_OPEN_FEMF_SETTLE);
+      return RC_NONE;
+
+    case 3:
+      /* Measure HAZV */
+      pPSTNCheck->vdiff_open = Si3228x_ReadMADCScaled(pProslic,VDIFF_COARSE,0);
+      /* Stop PSTN check if differential voltage > max_femf_vopen present */
+#ifdef ENABLE_DEBUG
+      if (pProslic->debugMode)
+      {
+        LOGPRINT("%sDiff PSTN : Vopen = %d mV\n", LOGPRINT_PREFIX,
+                 pPSTNCheck->vdiff_open);
+      }
+#endif
+      if(abs_int32(pPSTNCheck->vdiff_open) > pPSTNCheck->max_femf_vopen)
+      {
+        pPSTNCheck->pState.stage = 70;
+        pPSTNCheck->return_status = RC_PSTN_OPEN_FEMF;
+      }
+      else
+      {
+        pPSTNCheck->pState.stage = 10;
+      }
+      return 0;
+
+    case 10:
+      /* Load first DC feed preset */
+      ProSLIC_DCFeedSetup(pProslic,pPSTNCheck->dcfPreset1);
+      ProSLIC_SetLinefeedStatus(pProslic,LF_FWD_ACTIVE);
+      pPSTNCheck->pState.stage++;
+      return RC_NONE;
+
+    case 11:
+      /* Settle */
+      ProSLIC_PSTN_delay_poll(&(pPSTNCheck->pState), PSTN_DET_DIFF_IV1_SETTLE);
+      return RC_NONE;
+
+    case 12:
+      /* Measure VDIFF and ILOOP, switch to 2nd DCFEED setup */
+      pPSTNCheck->vdiff1[pPSTNCheck->pState.sampleIterations] =
+        Si3228x_ReadMADCScaled(pProslic,VDIFF_FILT,0);
+      pPSTNCheck->iloop1[pPSTNCheck->pState.sampleIterations] =
+        Si3228x_ReadMADCScaled(pProslic,MADC_ILOOP,0);
+#ifdef ENABLE_DEBUG
+      if (pProslic->debugMode)
+      {
+        LOGPRINT("%sDiff PSTN : Vdiff1[%d] = %d mV\n",
+                 LOGPRINT_PREFIX,
+                 pPSTNCheck->pState.sampleIterations,
+                 pPSTNCheck->vdiff1[pPSTNCheck->pState.sampleIterations]);
+        LOGPRINT("%sDiff PSTN : Iloop1[%d] = %d uA\n",
+                 LOGPRINT_PREFIX,
+                 pPSTNCheck->pState.sampleIterations,
+                 pPSTNCheck->iloop1[pPSTNCheck->pState.sampleIterations]);
+      }
+#endif
+      pPSTNCheck->pState.sampleIterations++;
+      if(pPSTNCheck->pState.sampleIterations >= pPSTNCheck->samples)
+      {
+        ProSLIC_DCFeedSetup(pProslic,pPSTNCheck->dcfPreset2);
+        pPSTNCheck->pState.stage++;
+        pPSTNCheck->pState.sampleIterations = 0;
+      }
+      return RC_NONE;
+
+    case 13:
+      /* Settle feed 500ms */
+      ProSLIC_PSTN_delay_poll(&(pPSTNCheck->pState), PSTN_DET_DIFF_IV2_SETTLE);
+      return RC_NONE;
+
+    case 14:
+      /* Measure VDIFF and ILOOP*/
+      pPSTNCheck->vdiff2[pPSTNCheck->pState.sampleIterations] =
+        Si3228x_ReadMADCScaled(pProslic,VDIFF_FILT,0);
+      pPSTNCheck->iloop2[pPSTNCheck->pState.sampleIterations] =
+        Si3228x_ReadMADCScaled(pProslic,MADC_ILOOP,0);
+#ifdef ENABLE_DEBUG
+      if (pProslic->debugMode)
+      {
+        LOGPRINT("%sDiff PSTN : Vdiff2[%d] = %d mV\n", LOGPRINT_PREFIX,
+                 pPSTNCheck->pState.sampleIterations,
+                 pPSTNCheck->vdiff2[pPSTNCheck->pState.sampleIterations]);
+        LOGPRINT("%sDiff PSTN : Iloop2[%d] = %d uA\n", LOGPRINT_PREFIX,
+                 pPSTNCheck->pState.sampleIterations,
+                 pPSTNCheck->iloop2[pPSTNCheck->pState.sampleIterations]);
+      }
+#endif
+      pPSTNCheck->pState.sampleIterations++;
+      if(pPSTNCheck->pState.sampleIterations >= pPSTNCheck->samples)
+      {
+        /* Compute averages */
+        for (i=0; i<pPSTNCheck->samples; i++)
+        {
+          pPSTNCheck->vdiff1_avg += pPSTNCheck->vdiff1[i];
+          pPSTNCheck->iloop1_avg += pPSTNCheck->iloop1[i];
+          pPSTNCheck->vdiff2_avg += pPSTNCheck->vdiff2[i];
+          pPSTNCheck->iloop2_avg += pPSTNCheck->iloop2[i];
+        }
+        pPSTNCheck->vdiff1_avg /= pPSTNCheck->samples;
+        pPSTNCheck->iloop1_avg /= pPSTNCheck->samples;
+        pPSTNCheck->vdiff2_avg /= pPSTNCheck->samples;
+        pPSTNCheck->iloop2_avg /= pPSTNCheck->samples;
+
+        /* Force small (probably offset) currents to minimum value */
+        if(abs_int32(pPSTNCheck->iloop1_avg) < PSTN_DET_MIN_ILOOP)
+        {
+          pPSTNCheck->iloop1_avg = PSTN_DET_MIN_ILOOP;
+        }
+        if(abs_int32(pPSTNCheck->iloop2_avg) < PSTN_DET_MIN_ILOOP)
+        {
+          pPSTNCheck->iloop2_avg = PSTN_DET_MIN_ILOOP;
+        }
+
+
+        /* Calculate measured loop impedance */
+        pPSTNCheck->rl1 = abs_int32((
+                                      pPSTNCheck->vdiff1_avg*1000L)/pPSTNCheck->iloop1_avg);
+        pPSTNCheck->rl2 = abs_int32((
+                                      pPSTNCheck->vdiff2_avg*1000L)/pPSTNCheck->iloop2_avg);
+
+        /* Force non-zero loop resistance */
+        if(pPSTNCheck->rl1 == 0)
+        {
+          pPSTNCheck->rl1 = 1;
+        }
+        if(pPSTNCheck->rl2 == 0)
+        {
+          pPSTNCheck->rl2 = 1;
+        }
+
+        /* Qualify loop impedances */
+        pPSTNCheck->rl_ratio = (pPSTNCheck->rl1*1000L)/pPSTNCheck->rl2;
+#ifdef ENABLE_DEBUG
+        if (pProslic->debugMode)
+        {
+          const char func_string[] = "DiffPSTN: ";
+          LOGPRINT("%s%sVDIFF1 = %d mV\n", LOGPRINT_PREFIX, func_string,
+                   pPSTNCheck->vdiff1_avg);
+          LOGPRINT("%s%sILOOP1 = %d uA\n", LOGPRINT_PREFIX, func_string,
+                   pPSTNCheck->iloop1_avg);
+          LOGPRINT("%s%sVDIFF2 = %d mV\n", LOGPRINT_PREFIX, func_string,
+                   pPSTNCheck->vdiff2_avg);
+          LOGPRINT("%s%sILOOP2 = %d uA\n", LOGPRINT_PREFIX, func_string,
+                   pPSTNCheck->iloop2_avg);
+          LOGPRINT("%s%sRL1 = %d ohm\n", LOGPRINT_PREFIX, func_string,
+                   pPSTNCheck->rl1);
+          LOGPRINT("%s%sRL2 = %d ohm\n", LOGPRINT_PREFIX, func_string,
+                   pPSTNCheck->rl2);
+          LOGPRINT("%s%sRL_Ratio = %d \n", LOGPRINT_PREFIX, func_string,
+                   pPSTNCheck->rl_ratio);
+        }
+#endif
+
+        /* Restore */
+        pPSTNCheck->pState.sampleIterations = 0;
+        pPSTNCheck->pState.stage = 70;
+      }
+      return RC_NONE;
+
+    case 70:  /* Reset test state, restore entry conditions */
+      ProSLIC_DCFeedSetup(pProslic,pPSTNCheck->entryDCFeedPreset);
+      ProSLIC_SetLinefeedStatus(pProslic,pPSTNCheck->lfstate_entry);
+      if(pProslic->deviceId->chipRev != 0)
+      {
+        WriteReg(pProHW,pProslic->channel,ENHANCE, pPSTNCheck->enhanceRegSave);
+      }
+      pPSTNCheck->pState.stage = 0;
+      pPSTNCheck->pState.waitIterations = 0;
+      pPSTNCheck->pState.sampleIterations = 0;
+      return pPSTNCheck->return_status;
+
+  }
+  return RC_NONE;
+}
+
+#endif
+
Index: linux-5.4.171/sound/soc/codecs/si3218x/src/si_voice.c
===================================================================
--- linux-5.4.171.orig/sound/soc/codecs/si3218x/src/si_voice.c	2022-02-07 17:55:33.855596500 +0800
+++ linux-5.4.171/sound/soc/codecs/si3218x/src/si_voice.c	2022-02-23 09:24:10.204997500 +0800
@@ -39,13 +39,23 @@
 #endif
 
 #ifdef SI3226X
+#if 0 //D2 MOD.
 #include "si3226x.h"
 #include "si3226x_intf.h"
+#else
+#include "../inc/si3226x.h"
+#include "../inc/si3226x_intf.h"
+#endif //D2 MOD.
 #endif
 
 #ifdef SI3228X
+#if 0 //D2 MOD.
 #include "si3228x.h"
 #include "si3228x_intf.h"
+#else
+#include "../inc/si3228x.h"
+#include "../inc/si3228x_intf.h"
+#endif //D2 MOD.
 #endif
 
 #define pCtrl(X)           (X)->deviceId->ctrlInterface
Index: linux-5.4.171/sound/soc/mediatek/mt79xx/modules.builtin
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-5.4.171/sound/soc/mediatek/mt79xx/modules.builtin	2022-02-23 10:48:18.306301510 +0800
@@ -0,0 +1,2 @@
+sound/soc/mediatek/mt79xx/snd-soc-mt79xx-afe.ko
+sound/soc/mediatek/mt79xx/mt79xx-si3218x.ko
Index: linux-5.4.171/sound/soc/mediatek/mt79xx/modules.order
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-5.4.171/sound/soc/mediatek/mt79xx/modules.order	2022-02-23 10:48:27.766176577 +0800
@@ -0,0 +1,1 @@
+
Index: linux-5.4.171/sound/soc/mediatek/mt79xx/mt79xx-dai-etdm.c
===================================================================
--- linux-5.4.171.orig/sound/soc/mediatek/mt79xx/mt79xx-dai-etdm.c	2022-02-07 17:55:33.855596500 +0800
+++ linux-5.4.171/sound/soc/mediatek/mt79xx/mt79xx-dai-etdm.c	2022-02-23 04:54:57.139997500 +0800
@@ -195,7 +195,11 @@ static int mtk_dai_etdm_config(struct mt
 	mask |= ETDM_FMT_MASK;
 	val |= ETDM_FMT(etdm_data->format);
 	mask |= ETDM_CH_NUM_MASK;
+#if 1 // D2 MOD.
+	val |= ETDM_CH_NUM(8);
+#else
 	val |= ETDM_CH_NUM(get_etdm_ch_fixup(channels));
+#endif // D2 MOD.
 	mask |= RELATCH_SRC_MASK;
 	val |= RELATCH_SRC(APLL_CLK);
 
@@ -215,6 +219,26 @@ static int mtk_dai_etdm_config(struct mt
 		/* set ETDM_OUT5_CON5 */
 		regmap_update_bits(afe->regmap, ETDM_OUT5_CON5,
 				   ETDM_CLK_DIV_MASK, ETDM_CLK_DIV);
+#if 1 // D2 MOD.
+        if (MTK_ETDM_RATE_8K == etdm_rate) {
+            printk("%s %d D2 debug PCM STREAM PLAYBACK set 8K etdm rate \n", __func__, __LINE__);
+        }
+        else if (MTK_ETDM_RATE_16K == etdm_rate) {
+            printk("%s %d D2 debug PCM STREAM PLAYBACK set 16K etdm rate, channel: (%d) %d \n", __func__, __LINE__, channels, get_etdm_ch_fixup(channels));
+        }
+        else {
+            printk("%s %d D2 debug PCM STREAM PLAYBACK set %d (WARNING) etdm rate \n", __func__, __LINE__, etdm_rate);
+        }
+        if (0 == afe_rate) {
+            printk("%s %d D2 debug PCM STREAM PLAYBACK set 8K afe rate \n", __func__, __LINE__);
+        }
+        else if (4 == afe_rate) {
+            printk("%s %d D2 debug PCM STREAM PLAYBACK set 16K afe rate \n", __func__, __LINE__);
+        }
+        else {
+            printk("%s %d D2 debug PCM STREAM PLAYBACK set %d (WARNING) afe rate \n", __func__, __LINE__, afe_rate);
+        }
+#endif // D2 MOD.
 		break;
 	case SNDRV_PCM_STREAM_CAPTURE:
 		/* set ETDM_IN5_CON0 */
@@ -233,6 +257,26 @@ static int mtk_dai_etdm_config(struct mt
 		/* set ETDM_IN5_CON4 */
 		regmap_update_bits(afe->regmap, ETDM_IN5_CON4,
 				   IN_RELATCH_MASK, IN_RELATCH(afe_rate));
+#if 1 // D2 MOD.
+        if (MTK_ETDM_RATE_8K == etdm_rate) {
+            printk("%s %d D2 debug PCM STREAM CAPTURE set 8K etdm rate \n", __func__, __LINE__);
+        }
+        else if (MTK_ETDM_RATE_16K == etdm_rate) {
+            printk("%s %d D2 debug PCM STREAM CAPTURE set 16K etdm rate, channels: (%d) %d \n", __func__, __LINE__, channels, get_etdm_ch_fixup(channels));
+        }
+        else {
+            printk("%s %d D2 debug PCM STREAM CAPTURE set %d (WARNING) etdm rate \n", __func__, __LINE__, etdm_rate);
+        }
+        if (0 == afe_rate) {
+            printk("%s %d D2 debug PCM STREAM CAPTURE set 8K afe rate \n", __func__, __LINE__);
+        }
+        else if (4 == afe_rate) {
+            printk("%s %d D2 debug PCM STREAM CAPTURE set 16K afe rate \n", __func__, __LINE__);
+        }
+        else {
+            printk("%s %d D2 debug PCM STREAM CAPTURE set %d (WARNING) afe rate \n", __func__, __LINE__, afe_rate);
+        }
+#endif // D2 MOD.
 		break;
 	default:
 		break;
@@ -262,17 +306,21 @@ static int mtk_dai_etdm_trigger(struct s
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
+#if 0 // D2 MOD.
 		regmap_update_bits(afe->regmap, ETDM_IN5_CON0, ETDM_EN_MASK,
 				   ETDM_EN);
 		regmap_update_bits(afe->regmap, ETDM_OUT5_CON0, ETDM_EN_MASK,
 				   ETDM_EN);
+#endif // D2 MOD.
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
 	case SNDRV_PCM_TRIGGER_SUSPEND:
+#if 0 // D2 MOD.
 		regmap_update_bits(afe->regmap, ETDM_IN5_CON0, ETDM_EN_MASK,
 				   0);
 		regmap_update_bits(afe->regmap, ETDM_OUT5_CON0, ETDM_EN_MASK,
 				   0);
+#endif // D2 MOD.
 		break;
 	default:
 		break;
Index: linux-5.4.171/sound/soc/mediatek/mt79xx/mt79xx-si3218x.c
===================================================================
--- linux-5.4.171.orig/sound/soc/mediatek/mt79xx/mt79xx-si3218x.c	2022-02-07 17:55:33.855596500 +0800
+++ linux-5.4.171/sound/soc/mediatek/mt79xx/mt79xx-si3218x.c	2022-02-23 04:54:53.876997500 +0800
@@ -13,6 +13,7 @@
 #include "mt79xx-afe-common.h"
 #include "mt79xx-reg.h"
 #include "../common/mtk-afe-platform-driver.h"
+#define PCM_16K // D2 MOD.
 
 enum {
 	HOPPING_CLK = 0,
@@ -94,8 +95,14 @@ static int mt79xx_si3218x_init(struct sn
 			   ETDM_BIT_LEN(16));
 	regmap_update_bits(afe->regmap, ETDM_IN5_CON0, ETDM_WRD_LEN_MASK,
 			   ETDM_WRD_LEN(16));
+#ifdef PCM_16K // D2 MOD.
+	regmap_update_bits(afe->regmap, ETDM_IN5_CON0, ETDM_CH_NUM_MASK,
+			   ETDM_CH_NUM(8));
+	printk("%s %d D2 debug Configure ETDM_IN5_CON0 to 8 channels.\n", __func__, __LINE__);
+#else
 	regmap_update_bits(afe->regmap, ETDM_IN5_CON0, ETDM_CH_NUM_MASK,
 			   ETDM_CH_NUM(4));
+#endif // D2 MOD.
 	regmap_update_bits(afe->regmap, ETDM_IN5_CON0, RELATCH_SRC_MASK,
 			   RELATCH_SRC(APLL_CLK));
 
@@ -103,6 +110,7 @@ static int mt79xx_si3218x_init(struct sn
 	regmap_update_bits(afe->regmap, ETDM_IN5_CON2, IN_CLK_SRC_MASK,
 			   IN_CLK_SRC(APLL_CLK));
 
+#ifdef PCM_16K // D2 MOD.
 	/* set ETDM_IN5_CON3 */
 	regmap_update_bits(afe->regmap, ETDM_IN5_CON3, IN_SEL_FS_MASK,
 			   IN_SEL_FS(ETDM_FS_16K));
@@ -112,6 +120,17 @@ static int mt79xx_si3218x_init(struct sn
 			   IN_CLK_INV);
 	regmap_update_bits(afe->regmap, ETDM_IN5_CON4, IN_RELATCH_MASK,
 			   IN_RELATCH(AFE_FS_16K));
+#else
+	/* set ETDM_IN5_CON3 */
+	regmap_update_bits(afe->regmap, ETDM_IN5_CON3, IN_SEL_FS_MASK,
+			   IN_SEL_FS(ETDM_FS_8K));
+
+	/* set ETDM_IN5_CON4 */
+	regmap_update_bits(afe->regmap, ETDM_IN5_CON4, IN_CLK_INV_MASK,
+			   IN_CLK_INV);
+	regmap_update_bits(afe->regmap, ETDM_IN5_CON4, IN_RELATCH_MASK,
+			   IN_RELATCH(AFE_FS_8K));
+#endif // D2 MOD.
 
 	/* set ETDM_OUT5_CON0 */
 	regmap_update_bits(afe->regmap, ETDM_OUT5_CON0, ETDM_FMT_MASK,
@@ -120,11 +139,17 @@ static int mt79xx_si3218x_init(struct sn
 			   ETDM_BIT_LEN(16));
 	regmap_update_bits(afe->regmap, ETDM_OUT5_CON0, ETDM_WRD_LEN_MASK,
 			   ETDM_WRD_LEN(16));
+#ifdef PCM_16K // D2 MOD.
+	regmap_update_bits(afe->regmap, ETDM_OUT5_CON0, ETDM_CH_NUM_MASK,
+			   ETDM_CH_NUM(8));
+#else
 	regmap_update_bits(afe->regmap, ETDM_OUT5_CON0, ETDM_CH_NUM_MASK,
 			   ETDM_CH_NUM(4));
+#endif // D2 MOD.
 	regmap_update_bits(afe->regmap, ETDM_OUT5_CON0, RELATCH_SRC_MASK,
 			   RELATCH_SRC(APLL_CLK));
 
+#ifdef PCM_16K // D2 MOD.
 	/* set ETDM_OUT5_CON4 */
 	regmap_update_bits(afe->regmap, ETDM_OUT5_CON4, OUT_SEL_FS_MASK,
 			   OUT_SEL_FS(ETDM_FS_16K));
@@ -132,6 +157,15 @@ static int mt79xx_si3218x_init(struct sn
 			   OUT_CLK_SRC(APLL_CLK));
 	regmap_update_bits(afe->regmap, ETDM_OUT5_CON4, OUT_RELATCH_MASK,
 			   OUT_RELATCH(AFE_FS_16K));
+#else
+	/* set ETDM_OUT5_CON4 */
+	regmap_update_bits(afe->regmap, ETDM_OUT5_CON4, OUT_SEL_FS_MASK,
+			   OUT_SEL_FS(ETDM_FS_8K));
+	regmap_update_bits(afe->regmap, ETDM_OUT5_CON4, OUT_CLK_SRC_MASK,
+			   OUT_CLK_SRC(APLL_CLK));
+	regmap_update_bits(afe->regmap, ETDM_OUT5_CON4, OUT_RELATCH_MASK,
+			   OUT_RELATCH(AFE_FS_8K));
+#endif // D2 MOD.
 
 	/* set ETDM_OUT5_CON5 */
 	regmap_update_bits(afe->regmap, ETDM_OUT5_CON5, OUT_CLK_INV_MASK,
@@ -139,9 +173,11 @@ static int mt79xx_si3218x_init(struct sn
 	regmap_update_bits(afe->regmap, ETDM_OUT5_CON5, ETDM_CLK_DIV_MASK,
 			   ETDM_CLK_DIV);
 
+#if 0 // D2 MOD: disable external loopback.
 	/* set external loopback */
 	regmap_update_bits(afe->regmap, ETDM_4_7_COWORK_CON0, OUT_SEL_MASK,
 			   OUT_SEL(ETDM_IN5));
+#endif // D2 MOD.
 
 	/* enable ETDM */
 	regmap_update_bits(afe->regmap, ETDM_IN5_CON0, ETDM_EN_MASK,
